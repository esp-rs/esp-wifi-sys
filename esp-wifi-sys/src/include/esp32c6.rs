/* automatically generated by rust-bindgen 0.66.1 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NANO_MALLOC: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_BACKWARD_BINARY_COMPAT: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_NOT_FINISHED: u32 = 268;
pub const ESP_ERR_NOT_ALLOWED: u32 = 269;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const ESP_ERR_HW_CRYPTO_BASE: u32 = 49152;
pub const ESP_ERR_MEMPROT_BASE: u32 = 53248;
pub const ESP_EVENT_ANY_ID: i32 = -1;
pub const WIFI_AP_DEFAULT_MAX_IDLE_PERIOD: u32 = 292;
pub const WIFI_ACTIVE_SCAN_MIN_DEFAULT_TIME: u32 = 0;
pub const WIFI_ACTIVE_SCAN_MAX_DEFAULT_TIME: u32 = 120;
pub const WIFI_PASSIVE_SCAN_DEFAULT_TIME: u32 = 360;
pub const WIFI_SCAN_HOME_CHANNEL_DWELL_DEFAULT_TIME: u32 = 30;
pub const WIFI_PROTOCOL_11B: u32 = 1;
pub const WIFI_PROTOCOL_11G: u32 = 2;
pub const WIFI_PROTOCOL_11N: u32 = 4;
pub const WIFI_PROTOCOL_LR: u32 = 8;
pub const WIFI_PROTOCOL_11A: u32 = 16;
pub const WIFI_PROTOCOL_11AC: u32 = 32;
pub const WIFI_PROTOCOL_11AX: u32 = 64;
pub const SAE_H2E_IDENTIFIER_LEN: u32 = 32;
pub const WIFI_VENDOR_IE_ELEMENT_ID: u32 = 221;
pub const WIFI_PROMIS_FILTER_MASK_ALL: u32 = 4294967295;
pub const WIFI_PROMIS_FILTER_MASK_MGMT: u32 = 1;
pub const WIFI_PROMIS_FILTER_MASK_CTRL: u32 = 2;
pub const WIFI_PROMIS_FILTER_MASK_DATA: u32 = 4;
pub const WIFI_PROMIS_FILTER_MASK_MISC: u32 = 8;
pub const WIFI_PROMIS_FILTER_MASK_DATA_MPDU: u32 = 16;
pub const WIFI_PROMIS_FILTER_MASK_DATA_AMPDU: u32 = 32;
pub const WIFI_PROMIS_FILTER_MASK_FCSFAIL: u32 = 64;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ALL: u32 = 4286578688;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_WRAPPER: u32 = 8388608;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BAR: u32 = 16777216;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BA: u32 = 33554432;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_PSPOLL: u32 = 67108864;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_RTS: u32 = 134217728;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CTS: u32 = 268435456;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ACK: u32 = 536870912;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFEND: u32 = 1073741824;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFENDACK: u32 = 2147483648;
pub const WIFI_EVENT_MASK_ALL: u32 = 4294967295;
pub const WIFI_EVENT_MASK_NONE: u32 = 0;
pub const ESP_WIFI_NAN_MAX_SVC_SUPPORTED: u32 = 2;
pub const ESP_WIFI_NAN_DATAPATH_MAX_PEERS: u32 = 2;
pub const ESP_WIFI_NDP_ROLE_INITIATOR: u32 = 1;
pub const ESP_WIFI_NDP_ROLE_RESPONDER: u32 = 2;
pub const ESP_WIFI_MAX_SVC_NAME_LEN: u32 = 256;
pub const ESP_WIFI_MAX_FILTER_LEN: u32 = 256;
pub const ESP_WIFI_MAX_SVC_INFO_LEN: u32 = 64;
pub const ESP_WIFI_MAX_FUP_SSI_LEN: u32 = 2048;
pub const ESP_WIFI_MAX_SVC_SSI_LEN: u32 = 512;
pub const ESP_WIFI_MAX_NEIGHBOR_REP_LEN: u32 = 64;
pub const WIFI_OUI_LEN: u32 = 3;
pub const MAX_SSID_LEN: u32 = 32;
pub const MAX_PASSPHRASE_LEN: u32 = 64;
pub const MAX_WPS_AP_CRED: u32 = 3;
pub const WIFI_STATIS_BUFFER: u32 = 1;
pub const WIFI_STATIS_RXTX: u32 = 2;
pub const WIFI_STATIS_HW: u32 = 4;
pub const WIFI_STATIS_DIAG: u32 = 8;
pub const WIFI_STATIS_PS: u32 = 16;
pub const WIFI_STATIS_ALL: i32 = -1;
pub const WIFI_MAX_SUPPORT_COUNTRY_NUM: u32 = 176;
pub const WIFI_MAX_REGULATORY_RULE_NUM: u32 = 2;
pub const ESP_WIFI_MAX_CONN_NUM: u32 = 10;
pub const ESP_WIFI_CRYPTO_VERSION: u32 = 1;
pub const ESP_ERR_WIFI_NOT_INIT: u32 = 12289;
pub const ESP_ERR_WIFI_NOT_STARTED: u32 = 12290;
pub const ESP_ERR_WIFI_NOT_STOPPED: u32 = 12291;
pub const ESP_ERR_WIFI_IF: u32 = 12292;
pub const ESP_ERR_WIFI_MODE: u32 = 12293;
pub const ESP_ERR_WIFI_STATE: u32 = 12294;
pub const ESP_ERR_WIFI_CONN: u32 = 12295;
pub const ESP_ERR_WIFI_NVS: u32 = 12296;
pub const ESP_ERR_WIFI_MAC: u32 = 12297;
pub const ESP_ERR_WIFI_SSID: u32 = 12298;
pub const ESP_ERR_WIFI_PASSWORD: u32 = 12299;
pub const ESP_ERR_WIFI_TIMEOUT: u32 = 12300;
pub const ESP_ERR_WIFI_WAKE_FAIL: u32 = 12301;
pub const ESP_ERR_WIFI_WOULD_BLOCK: u32 = 12302;
pub const ESP_ERR_WIFI_NOT_CONNECT: u32 = 12303;
pub const ESP_ERR_WIFI_POST: u32 = 12306;
pub const ESP_ERR_WIFI_INIT_STATE: u32 = 12307;
pub const ESP_ERR_WIFI_STOP_STATE: u32 = 12308;
pub const ESP_ERR_WIFI_NOT_ASSOC: u32 = 12309;
pub const ESP_ERR_WIFI_TX_DISALLOW: u32 = 12310;
pub const ESP_ERR_WIFI_TWT_FULL: u32 = 12311;
pub const ESP_ERR_WIFI_TWT_SETUP_TIMEOUT: u32 = 12312;
pub const ESP_ERR_WIFI_TWT_SETUP_TXFAIL: u32 = 12313;
pub const ESP_ERR_WIFI_TWT_SETUP_REJECT: u32 = 12314;
pub const ESP_ERR_WIFI_DISCARD: u32 = 12315;
pub const ESP_ERR_WIFI_ROC_IN_PROGRESS: u32 = 12316;
pub const WIFI_STATIC_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_CACHE_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_RX_MGMT_BUF_NUM_DEF: u32 = 0;
pub const WIFI_CSI_ENABLED: u32 = 0;
pub const WIFI_AMPDU_RX_ENABLED: u32 = 0;
pub const WIFI_AMPDU_TX_ENABLED: u32 = 0;
pub const WIFI_AMSDU_TX_ENABLED: u32 = 0;
pub const WIFI_NVS_ENABLED: u32 = 0;
pub const WIFI_NANO_FORMAT_ENABLED: u32 = 0;
pub const WIFI_INIT_CONFIG_MAGIC: u32 = 523190095;
pub const WIFI_DEFAULT_RX_BA_WIN: u32 = 0;
pub const WIFI_TASK_CORE_ID: u32 = 0;
pub const WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const WIFI_STA_DISCONNECTED_PM_ENABLED: u32 = 0;
pub const WIFI_ENABLE_WPA3_SAE: u32 = 0;
pub const WIFI_ENABLE_SPIRAM: u32 = 0;
pub const WIFI_FTM_INITIATOR: u32 = 0;
pub const WIFI_FTM_RESPONDER: u32 = 0;
pub const WIFI_ENABLE_GCMP: u32 = 0;
pub const WIFI_ENABLE_GMAC: u32 = 0;
pub const WIFI_ENABLE_11R: u32 = 0;
pub const WIFI_ENABLE_ENTERPRISE: u32 = 0;
pub const WIFI_DUMP_HESIGB_ENABLED: u32 = 0;
pub const WIFI_TX_HETB_QUEUE_NUM: u32 = 1;
pub const CONFIG_FEATURE_WPA3_SAE_BIT: u32 = 1;
pub const CONFIG_FEATURE_CACHE_TX_BUF_BIT: u32 = 2;
pub const CONFIG_FEATURE_FTM_INITIATOR_BIT: u32 = 4;
pub const CONFIG_FEATURE_FTM_RESPONDER_BIT: u32 = 8;
pub const CONFIG_FEATURE_GCMP_BIT: u32 = 16;
pub const CONFIG_FEATURE_GMAC_BIT: u32 = 32;
pub const CONFIG_FEATURE_11R_BIT: u32 = 64;
pub const CONFIG_FEATURE_WIFI_ENT_BIT: u32 = 128;
pub const WIFI_FEATURE_CAPS: u32 = 0;
pub const ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE: u32 = 0;
pub const WIFI_LOG_SUBMODULE_ALL: u32 = 0;
pub const WIFI_LOG_SUBMODULE_INIT: u32 = 1;
pub const WIFI_LOG_SUBMODULE_IOCTL: u32 = 2;
pub const WIFI_LOG_SUBMODULE_CONN: u32 = 4;
pub const WIFI_LOG_SUBMODULE_SCAN: u32 = 8;
pub const ESP_WIFI_OS_ADAPTER_VERSION: u32 = 8;
pub const ESP_WIFI_OS_ADAPTER_MAGIC: u32 = 3735928495;
pub const OSI_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const OSI_QUEUE_SEND_FRONT: u32 = 0;
pub const OSI_QUEUE_SEND_BACK: u32 = 1;
pub const OSI_QUEUE_SEND_OVERWRITE: u32 = 2;
pub const SOC_ADC_SUPPORTED: u32 = 1;
pub const SOC_DEDICATED_GPIO_SUPPORTED: u32 = 1;
pub const SOC_UART_SUPPORTED: u32 = 1;
pub const SOC_UHCI_SUPPORTED: u32 = 1;
pub const SOC_GDMA_SUPPORTED: u32 = 1;
pub const SOC_AHB_GDMA_SUPPORTED: u32 = 1;
pub const SOC_GPTIMER_SUPPORTED: u32 = 1;
pub const SOC_PCNT_SUPPORTED: u32 = 1;
pub const SOC_MCPWM_SUPPORTED: u32 = 1;
pub const SOC_TWAI_SUPPORTED: u32 = 1;
pub const SOC_ETM_SUPPORTED: u32 = 1;
pub const SOC_PARLIO_SUPPORTED: u32 = 1;
pub const SOC_BT_SUPPORTED: u32 = 1;
pub const SOC_IEEE802154_SUPPORTED: u32 = 1;
pub const SOC_ASYNC_MEMCPY_SUPPORTED: u32 = 1;
pub const SOC_USB_SERIAL_JTAG_SUPPORTED: u32 = 1;
pub const SOC_TEMP_SENSOR_SUPPORTED: u32 = 1;
pub const SOC_PHY_SUPPORTED: u32 = 1;
pub const SOC_WIFI_SUPPORTED: u32 = 1;
pub const SOC_SUPPORTS_SECURE_DL_MODE: u32 = 1;
pub const SOC_ULP_SUPPORTED: u32 = 1;
pub const SOC_LP_CORE_SUPPORTED: u32 = 1;
pub const SOC_EFUSE_KEY_PURPOSE_FIELD: u32 = 1;
pub const SOC_EFUSE_SUPPORTED: u32 = 1;
pub const SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const SOC_I2S_SUPPORTED: u32 = 1;
pub const SOC_RMT_SUPPORTED: u32 = 1;
pub const SOC_SDM_SUPPORTED: u32 = 1;
pub const SOC_GPSPI_SUPPORTED: u32 = 1;
pub const SOC_LEDC_SUPPORTED: u32 = 1;
pub const SOC_I2C_SUPPORTED: u32 = 1;
pub const SOC_SYSTIMER_SUPPORTED: u32 = 1;
pub const SOC_SUPPORT_COEXISTENCE: u32 = 1;
pub const SOC_AES_SUPPORTED: u32 = 1;
pub const SOC_MPI_SUPPORTED: u32 = 1;
pub const SOC_SHA_SUPPORTED: u32 = 1;
pub const SOC_HMAC_SUPPORTED: u32 = 1;
pub const SOC_DIG_SIGN_SUPPORTED: u32 = 1;
pub const SOC_ECC_SUPPORTED: u32 = 1;
pub const SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const SOC_SDIO_SLAVE_SUPPORTED: u32 = 1;
pub const SOC_BOD_SUPPORTED: u32 = 1;
pub const SOC_APM_SUPPORTED: u32 = 1;
pub const SOC_PMU_SUPPORTED: u32 = 1;
pub const SOC_PAU_SUPPORTED: u32 = 1;
pub const SOC_LP_TIMER_SUPPORTED: u32 = 1;
pub const SOC_LP_AON_SUPPORTED: u32 = 1;
pub const SOC_LP_PERIPHERALS_SUPPORTED: u32 = 1;
pub const SOC_LP_I2C_SUPPORTED: u32 = 1;
pub const SOC_ULP_LP_UART_SUPPORTED: u32 = 1;
pub const SOC_CLK_TREE_SUPPORTED: u32 = 1;
pub const SOC_ASSIST_DEBUG_SUPPORTED: u32 = 1;
pub const SOC_WDT_SUPPORTED: u32 = 1;
pub const SOC_SPI_FLASH_SUPPORTED: u32 = 1;
pub const SOC_RNG_SUPPORTED: u32 = 1;
pub const SOC_LIGHT_SLEEP_SUPPORTED: u32 = 1;
pub const SOC_DEEP_SLEEP_SUPPORTED: u32 = 1;
pub const SOC_MODEM_CLOCK_SUPPORTED: u32 = 1;
pub const SOC_PM_SUPPORTED: u32 = 1;
pub const SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const SOC_XTAL_CLOCK_PATH_DEPENDS_ON_TOP_DOMAIN: u32 = 1;
pub const SOC_AES_SUPPORT_DMA: u32 = 1;
pub const SOC_AES_GDMA: u32 = 1;
pub const SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const SOC_ADC_DIG_IIR_FILTER_SUPPORTED: u32 = 1;
pub const SOC_ADC_MONITOR_SUPPORTED: u32 = 1;
pub const SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const SOC_ADC_PERIPH_NUM: u32 = 1;
pub const SOC_ADC_MAX_CHANNEL_NUM: u32 = 7;
pub const SOC_ADC_ATTEN_NUM: u32 = 4;
pub const SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 1;
pub const SOC_ADC_PATT_LEN_MAX: u32 = 8;
pub const SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 12;
pub const SOC_ADC_DIGI_IIR_FILTER_NUM: u32 = 2;
pub const SOC_ADC_DIGI_MONITOR_NUM: u32 = 2;
pub const SOC_ADC_DIGI_RESULT_BYTES: u32 = 4;
pub const SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 4;
pub const SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 83333;
pub const SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 611;
pub const SOC_ADC_RTC_MIN_BITWIDTH: u32 = 12;
pub const SOC_ADC_RTC_MAX_BITWIDTH: u32 = 12;
pub const SOC_ADC_CALIBRATION_V1_SUPPORTED: u32 = 1;
pub const SOC_ADC_SELF_HW_CALI_SUPPORTED: u32 = 1;
pub const SOC_ADC_CALIB_CHAN_COMPENS_SUPPORTED: u32 = 1;
pub const SOC_ADC_TEMPERATURE_SHARE_INTR: u32 = 1;
pub const SOC_ADC_SHARED_POWER: u32 = 1;
pub const SOC_APB_BACKUP_DMA: u32 = 0;
pub const SOC_BROWNOUT_RESET_SUPPORTED: u32 = 1;
pub const SOC_SHARED_IDCACHE_SUPPORTED: u32 = 1;
pub const SOC_CACHE_FREEZE_SUPPORTED: u32 = 1;
pub const SOC_CPU_CORES_NUM: u32 = 1;
pub const SOC_CPU_INTR_NUM: u32 = 32;
pub const SOC_CPU_HAS_FLEXIBLE_INTC: u32 = 1;
pub const SOC_INT_PLIC_SUPPORTED: u32 = 1;
pub const SOC_CPU_HAS_CSR_PC: u32 = 1;
pub const SOC_CPU_BREAKPOINTS_NUM: u32 = 4;
pub const SOC_CPU_WATCHPOINTS_NUM: u32 = 4;
pub const SOC_CPU_WATCHPOINT_MAX_REGION_SIZE: u32 = 2147483648;
pub const SOC_CPU_HAS_PMA: u32 = 1;
pub const SOC_CPU_IDRAM_SPLIT_USING_PMP: u32 = 1;
pub const SOC_CPU_PMP_REGION_GRANULARITY: u32 = 4;
pub const SOC_DS_SIGNATURE_MAX_BIT_LEN: u32 = 3072;
pub const SOC_DS_KEY_PARAM_MD_IV_LENGTH: u32 = 16;
pub const SOC_DS_KEY_CHECK_MAX_WAIT_US: u32 = 1100;
pub const SOC_AHB_GDMA_VERSION: u32 = 1;
pub const SOC_GDMA_NUM_GROUPS_MAX: u32 = 1;
pub const SOC_GDMA_PAIRS_PER_GROUP_MAX: u32 = 3;
pub const SOC_GDMA_SUPPORT_ETM: u32 = 1;
pub const SOC_GDMA_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_ETM_GROUPS: u32 = 1;
pub const SOC_ETM_CHANNELS_PER_GROUP: u32 = 50;
pub const SOC_ETM_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_GPIO_PORT: u32 = 1;
pub const SOC_GPIO_PIN_COUNT: u32 = 31;
pub const SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER: u32 = 1;
pub const SOC_GPIO_FLEX_GLITCH_FILTER_NUM: u32 = 8;
pub const SOC_GPIO_SUPPORT_ETM: u32 = 1;
pub const SOC_GPIO_SUPPORT_RTC_INDEPENDENT: u32 = 1;
pub const SOC_GPIO_SUPPORT_DEEPSLEEP_WAKEUP: u32 = 1;
pub const SOC_LP_IO_CLOCK_IS_INDEPENDENT: u32 = 1;
pub const SOC_GPIO_VALID_GPIO_MASK: u32 = 2147483647;
pub const SOC_GPIO_VALID_OUTPUT_GPIO_MASK: u32 = 2147483647;
pub const SOC_GPIO_IN_RANGE_MAX: u32 = 30;
pub const SOC_GPIO_OUT_RANGE_MAX: u32 = 30;
pub const SOC_GPIO_DEEP_SLEEP_WAKE_SUPPORTED_PIN_CNT: u32 = 8;
pub const SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u32 = 2147483392;
pub const SOC_GPIO_SUPPORT_FORCE_HOLD: u32 = 1;
pub const SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP: u32 = 1;
pub const SOC_GPIO_SUPPORT_HOLD_SINGLE_IO_IN_DSLP: u32 = 1;
pub const SOC_GPIO_CLOCKOUT_BY_GPIO_MATRIX: u32 = 1;
pub const SOC_CLOCKOUT_HAS_SOURCE_GATE: u32 = 1;
pub const SOC_GPIO_CLOCKOUT_CHANNEL_NUM: u32 = 3;
pub const SOC_RTCIO_PIN_COUNT: u32 = 8;
pub const SOC_RTCIO_INPUT_OUTPUT_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_HOLD_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_WAKE_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_EDGE_WAKE_SUPPORTED: u32 = 1;
pub const SOC_DEDIC_GPIO_OUT_CHANNELS_NUM: u32 = 8;
pub const SOC_DEDIC_GPIO_IN_CHANNELS_NUM: u32 = 8;
pub const SOC_DEDIC_PERIPH_ALWAYS_ENABLE: u32 = 1;
pub const SOC_I2C_NUM: u32 = 2;
pub const SOC_HP_I2C_NUM: u32 = 1;
pub const SOC_I2C_FIFO_LEN: u32 = 32;
pub const SOC_I2C_CMD_REG_NUM: u32 = 8;
pub const SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const SOC_I2C_SUPPORT_HW_FSM_RST: u32 = 1;
pub const SOC_I2C_SUPPORT_HW_CLR_BUS: u32 = 1;
pub const SOC_I2C_SUPPORT_XTAL: u32 = 1;
pub const SOC_I2C_SUPPORT_RTC: u32 = 1;
pub const SOC_I2C_SUPPORT_10BIT_ADDR: u32 = 1;
pub const SOC_I2C_SLAVE_SUPPORT_BROADCAST: u32 = 1;
pub const SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE: u32 = 1;
pub const SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS: u32 = 1;
pub const SOC_I2C_SLAVE_SUPPORT_SLAVE_UNMATCH: u32 = 1;
pub const SOC_I2C_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_LP_I2C_NUM: u32 = 1;
pub const SOC_LP_I2C_FIFO_LEN: u32 = 16;
pub const SOC_I2S_NUM: u32 = 1;
pub const SOC_I2S_HW_VERSION_2: u32 = 1;
pub const SOC_I2S_SUPPORTS_ETM: u32 = 1;
pub const SOC_I2S_SUPPORTS_XTAL: u32 = 1;
pub const SOC_I2S_SUPPORTS_PLL_F160M: u32 = 1;
pub const SOC_I2S_SUPPORTS_PCM: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM_TX: u32 = 1;
pub const SOC_I2S_SUPPORTS_PCM2PDM: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM_RX: u32 = 1;
pub const SOC_I2S_PDM_MAX_TX_LINES: u32 = 2;
pub const SOC_I2S_PDM_MAX_RX_LINES: u32 = 1;
pub const SOC_I2S_SUPPORTS_TDM: u32 = 1;
pub const SOC_I2S_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_LEDC_SUPPORT_PLL_DIV_CLOCK: u32 = 1;
pub const SOC_LEDC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const SOC_LEDC_TIMER_NUM: u32 = 4;
pub const SOC_LEDC_CHANNEL_NUM: u32 = 6;
pub const SOC_LEDC_TIMER_BIT_WIDTH: u32 = 20;
pub const SOC_LEDC_SUPPORT_FADE_STOP: u32 = 1;
pub const SOC_LEDC_GAMMA_CURVE_FADE_SUPPORTED: u32 = 1;
pub const SOC_LEDC_GAMMA_CURVE_FADE_RANGE_MAX: u32 = 16;
pub const SOC_LEDC_FADE_PARAMS_BIT_WIDTH: u32 = 10;
pub const SOC_LEDC_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_MMU_PAGE_SIZE_CONFIGURABLE: u32 = 1;
pub const SOC_MMU_PAGE_SIZE_8KB_SUPPORTED: u32 = 1;
pub const SOC_MMU_PERIPH_NUM: u32 = 1;
pub const SOC_MMU_LINEAR_ADDRESS_REGION_NUM: u32 = 1;
pub const SOC_MMU_DI_VADDR_SHARED: u32 = 1;
pub const SOC_MPU_CONFIGURABLE_REGIONS_SUPPORTED: u32 = 0;
pub const SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const SOC_MPU_REGION_RO_SUPPORTED: u32 = 0;
pub const SOC_MPU_REGION_WO_SUPPORTED: u32 = 0;
pub const SOC_PCNT_GROUPS: u32 = 1;
pub const SOC_PCNT_UNITS_PER_GROUP: u32 = 4;
pub const SOC_PCNT_CHANNELS_PER_UNIT: u32 = 2;
pub const SOC_PCNT_THRES_POINT_PER_UNIT: u32 = 2;
pub const SOC_PCNT_SUPPORT_RUNTIME_THRES_UPDATE: u32 = 1;
pub const SOC_PCNT_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_RMT_GROUPS: u32 = 1;
pub const SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 2;
pub const SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 2;
pub const SOC_RMT_CHANNELS_PER_GROUP: u32 = 4;
pub const SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 48;
pub const SOC_RMT_SUPPORT_RX_PINGPONG: u32 = 1;
pub const SOC_RMT_SUPPORT_RX_DEMODULATION: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_ASYNC_STOP: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_LOOP_COUNT: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_SYNCHRO: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY: u32 = 1;
pub const SOC_RMT_SUPPORT_XTAL: u32 = 1;
pub const SOC_RMT_SUPPORT_RC_FAST: u32 = 1;
pub const SOC_RMT_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_MCPWM_GROUPS: u32 = 1;
pub const SOC_MCPWM_TIMERS_PER_GROUP: u32 = 3;
pub const SOC_MCPWM_OPERATORS_PER_GROUP: u32 = 3;
pub const SOC_MCPWM_COMPARATORS_PER_OPERATOR: u32 = 2;
pub const SOC_MCPWM_GENERATORS_PER_OPERATOR: u32 = 2;
pub const SOC_MCPWM_TRIGGERS_PER_OPERATOR: u32 = 2;
pub const SOC_MCPWM_GPIO_FAULTS_PER_GROUP: u32 = 3;
pub const SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP: u32 = 1;
pub const SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER: u32 = 3;
pub const SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP: u32 = 3;
pub const SOC_MCPWM_SWSYNC_CAN_PROPAGATE: u32 = 1;
pub const SOC_MCPWM_SUPPORT_ETM: u32 = 1;
pub const SOC_MCPWM_CAPTURE_CLK_FROM_GROUP: u32 = 1;
pub const SOC_MCPWM_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_PARLIO_GROUPS: u32 = 1;
pub const SOC_PARLIO_TX_UNITS_PER_GROUP: u32 = 1;
pub const SOC_PARLIO_RX_UNITS_PER_GROUP: u32 = 1;
pub const SOC_PARLIO_TX_UNIT_MAX_DATA_WIDTH: u32 = 16;
pub const SOC_PARLIO_RX_UNIT_MAX_DATA_WIDTH: u32 = 16;
pub const SOC_PARLIO_TX_RX_SHARE_INTERRUPT: u32 = 1;
pub const SOC_PARLIO_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_MPI_MEM_BLOCKS_NUM: u32 = 4;
pub const SOC_MPI_OPERATIONS_NUM: u32 = 3;
pub const SOC_RSA_MAX_BIT_LEN: u32 = 3072;
pub const SOC_SHA_DMA_MAX_BUFFER_SIZE: u32 = 3968;
pub const SOC_SHA_SUPPORT_DMA: u32 = 1;
pub const SOC_SHA_SUPPORT_RESUME: u32 = 1;
pub const SOC_SHA_GDMA: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA224: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const SOC_SDM_GROUPS: u32 = 1;
pub const SOC_SDM_CHANNELS_PER_GROUP: u32 = 4;
pub const SOC_SDM_CLK_SUPPORT_PLL_F80M: u32 = 1;
pub const SOC_SDM_CLK_SUPPORT_XTAL: u32 = 1;
pub const SOC_SPI_PERIPH_NUM: u32 = 2;
pub const SOC_SPI_MAX_CS_NUM: u32 = 6;
pub const SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const SOC_SPI_SUPPORT_DDRCLK: u32 = 1;
pub const SOC_SPI_SLAVE_SUPPORT_SEG_TRANS: u32 = 1;
pub const SOC_SPI_SUPPORT_CD_SIG: u32 = 1;
pub const SOC_SPI_SUPPORT_CONTINUOUS_TRANS: u32 = 1;
pub const SOC_SPI_SUPPORT_SLAVE_HD_VER2: u32 = 1;
pub const SOC_SPI_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_SPI_SUPPORT_CLK_XTAL: u32 = 1;
pub const SOC_SPI_SUPPORT_CLK_PLL_F80M: u32 = 1;
pub const SOC_SPI_SUPPORT_CLK_RC_FAST: u32 = 1;
pub const SOC_SPI_SCT_SUPPORTED: u32 = 1;
pub const SOC_SPI_SCT_REG_NUM: u32 = 14;
pub const SOC_SPI_SCT_BUFFER_NUM_MAX: u32 = 15;
pub const SOC_SPI_SCT_CONF_BITLEN_MAX: u32 = 262138;
pub const SOC_MEMSPI_IS_INDEPENDENT: u32 = 1;
pub const SOC_SPI_MAX_PRE_DIVIDER: u32 = 16;
pub const SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_AUTO_RESUME: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_IDLE_INTR: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_SW_SUSPEND: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_CHECK_SUS: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_WRAP: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const SOC_SYSTIMER_COUNTER_NUM: u32 = 2;
pub const SOC_SYSTIMER_ALARM_NUM: u32 = 3;
pub const SOC_SYSTIMER_BIT_WIDTH_LO: u32 = 32;
pub const SOC_SYSTIMER_BIT_WIDTH_HI: u32 = 20;
pub const SOC_SYSTIMER_FIXED_DIVIDER: u32 = 1;
pub const SOC_SYSTIMER_SUPPORT_RC_FAST: u32 = 1;
pub const SOC_SYSTIMER_INT_LEVEL: u32 = 1;
pub const SOC_SYSTIMER_ALARM_MISS_COMPENSATE: u32 = 1;
pub const SOC_SYSTIMER_SUPPORT_ETM: u32 = 1;
pub const SOC_LP_TIMER_BIT_WIDTH_LO: u32 = 32;
pub const SOC_LP_TIMER_BIT_WIDTH_HI: u32 = 16;
pub const SOC_TIMER_GROUPS: u32 = 2;
pub const SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 1;
pub const SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 54;
pub const SOC_TIMER_GROUP_SUPPORT_XTAL: u32 = 1;
pub const SOC_TIMER_GROUP_SUPPORT_RC_FAST: u32 = 1;
pub const SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 2;
pub const SOC_TIMER_SUPPORT_ETM: u32 = 1;
pub const SOC_TIMER_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_MWDT_SUPPORT_XTAL: u32 = 1;
pub const SOC_MWDT_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_TWAI_CONTROLLER_NUM: u32 = 2;
pub const SOC_TWAI_MASK_FILTER_NUM: u32 = 1;
pub const SOC_TWAI_CLK_SUPPORT_XTAL: u32 = 1;
pub const SOC_TWAI_BRP_MIN: u32 = 2;
pub const SOC_TWAI_BRP_MAX: u32 = 32768;
pub const SOC_TWAI_SUPPORTS_RX_STATUS: u32 = 1;
pub const SOC_TWAI_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_EFUSE_DIS_DOWNLOAD_ICACHE: u32 = 1;
pub const SOC_EFUSE_DIS_PAD_JTAG: u32 = 1;
pub const SOC_EFUSE_DIS_USB_JTAG: u32 = 1;
pub const SOC_EFUSE_DIS_DIRECT_BOOT: u32 = 1;
pub const SOC_EFUSE_SOFT_DIS_JTAG: u32 = 1;
pub const SOC_EFUSE_DIS_ICACHE: u32 = 1;
pub const SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK: u32 = 1;
pub const SOC_SECURE_BOOT_V2_RSA: u32 = 1;
pub const SOC_SECURE_BOOT_V2_ECC: u32 = 1;
pub const SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 3;
pub const SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: u32 = 1;
pub const SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY: u32 = 1;
pub const SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 64;
pub const SOC_FLASH_ENCRYPTION_XTS_AES: u32 = 1;
pub const SOC_FLASH_ENCRYPTION_XTS_AES_128: u32 = 1;
pub const SOC_APM_CTRL_FILTER_SUPPORTED: u32 = 1;
pub const SOC_APM_LP_APM0_SUPPORTED: u32 = 1;
pub const SOC_APM_SUPPORT_LP_TEE_CTRL: u32 = 1;
pub const SOC_CRYPTO_DPA_PROTECTION_SUPPORTED: u32 = 1;
pub const SOC_UART_NUM: u32 = 3;
pub const SOC_UART_HP_NUM: u32 = 2;
pub const SOC_UART_LP_NUM: u32 = 1;
pub const SOC_UART_FIFO_LEN: u32 = 128;
pub const SOC_LP_UART_FIFO_LEN: u32 = 16;
pub const SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const SOC_UART_SUPPORT_PLL_F80M_CLK: u32 = 1;
pub const SOC_UART_SUPPORT_RTC_CLK: u32 = 1;
pub const SOC_UART_SUPPORT_XTAL_CLK: u32 = 1;
pub const SOC_UART_SUPPORT_WAKEUP_INT: u32 = 1;
pub const SOC_UART_HAS_LP_UART: u32 = 1;
pub const SOC_UART_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_UART_SUPPORT_FSM_TX_WAIT_SEND: u32 = 1;
pub const SOC_UART_WAKEUP_CHARS_SEQ_MAX_LEN: u32 = 5;
pub const SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE: u32 = 1;
pub const SOC_UART_WAKEUP_SUPPORT_FIFO_THRESH_MODE: u32 = 1;
pub const SOC_UART_WAKEUP_SUPPORT_START_BIT_MODE: u32 = 1;
pub const SOC_UART_WAKEUP_SUPPORT_CHAR_SEQ_MODE: u32 = 1;
pub const SOC_UHCI_NUM: u32 = 1;
pub const SOC_COEX_HW_PTI: u32 = 1;
pub const SOC_EXTERNAL_COEX_ADVANCE: u32 = 1;
pub const SOC_EXTERNAL_COEX_LEADER_TX_LINE: u32 = 0;
pub const SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 84;
pub const SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH: u32 = 12;
pub const SOC_RTC_MEM_SUPPORT_SPEED_MODE_SWITCH: u32 = 1;
pub const SOC_PM_SUPPORT_WIFI_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_BEACON_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_BT_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_EXT1_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_EXT1_WAKEUP_MODE_PER_PIN: u32 = 1;
pub const SOC_PM_SUPPORT_CPU_PD: u32 = 1;
pub const SOC_PM_SUPPORT_MODEM_PD: u32 = 1;
pub const SOC_PM_SUPPORT_XTAL32K_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RC32K_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RC_FAST_PD: u32 = 1;
pub const SOC_PM_SUPPORT_VDDSDIO_PD: u32 = 1;
pub const SOC_PM_SUPPORT_TOP_PD: u32 = 1;
pub const SOC_PM_SUPPORT_HP_AON_PD: u32 = 1;
pub const SOC_PM_SUPPORT_MAC_BB_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RTC_PERIPH_PD: u32 = 1;
pub const SOC_PM_SUPPORT_PMU_MODEM_STATE: u32 = 1;
pub const MAC_SUPPORT_PMU_MODEM_STATE: u32 = 1;
pub const SOC_PM_SUPPORT_PMU_CLK_ICG: u32 = 1;
pub const SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY: u32 = 1;
pub const SOC_PM_CPU_RETENTION_BY_SW: u32 = 1;
pub const SOC_PM_MODEM_RETENTION_BY_REGDMA: u32 = 1;
pub const SOC_PM_RETENTION_HAS_CLOCK_BUG: u32 = 1;
pub const SOC_EXT_MEM_CACHE_TAG_IN_CPU_DOMAIN: u32 = 1;
pub const SOC_PM_PAU_LINK_NUM: u32 = 4;
pub const SOC_PM_PAU_REGDMA_LINK_MULTI_ADDR: u32 = 1;
pub const SOC_PM_PAU_REGDMA_LINK_WIFIMAC: u32 = 1;
pub const SOC_PM_PAU_REGDMA_UPDATE_CACHE_BEFORE_WAIT_COMPARE: u32 = 1;
pub const SOC_PM_PMU_MIN_SLP_SLOW_CLK_CYCLE_FIXED: u32 = 1;
pub const SOC_PM_RETENTION_MODULE_NUM: u32 = 32;
pub const SOC_CLK_RC_FAST_SUPPORT_CALIBRATION: u32 = 1;
pub const SOC_MODEM_CLOCK_IS_INDEPENDENT: u32 = 1;
pub const SOC_CLK_XTAL32K_SUPPORTED: u32 = 1;
pub const SOC_CLK_OSC_SLOW_SUPPORTED: u32 = 1;
pub const SOC_CLK_RC32K_SUPPORTED: u32 = 1;
pub const SOC_CLK_LP_FAST_SUPPORT_XTAL_D2: u32 = 1;
pub const SOC_RCC_IS_INDEPENDENT: u32 = 1;
pub const SOC_CLK_ANA_I2C_MST_HAS_ROOT_GATE: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_SUPPORT_XTAL: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_INTR_SUPPORT: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_SUPPORT_ETM: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_UNDER_PD_TOP_DOMAIN: u32 = 1;
pub const SOC_RNG_CLOCK_IS_INDEPENDENT: u32 = 1;
pub const SOC_WIFI_HW_TSF: u32 = 1;
pub const SOC_WIFI_FTM_SUPPORT: u32 = 1;
pub const SOC_WIFI_GCMP_SUPPORT: u32 = 1;
pub const SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const SOC_WIFI_HE_SUPPORT: u32 = 1;
pub const SOC_WIFI_MAC_VERSION_NUM: u32 = 2;
pub const SOC_BLE_SUPPORTED: u32 = 1;
pub const SOC_BLE_MESH_SUPPORTED: u32 = 1;
pub const SOC_ESP_NIMBLE_CONTROLLER: u32 = 1;
pub const SOC_BLE_50_SUPPORTED: u32 = 1;
pub const SOC_BLE_DEVICE_PRIVACY_SUPPORTED: u32 = 1;
pub const SOC_BLE_POWER_CONTROL_SUPPORTED: u32 = 1;
pub const SOC_BLE_PERIODIC_ADV_ENH_SUPPORTED: u32 = 1;
pub const SOC_BLUFI_SUPPORTED: u32 = 1;
pub const SOC_BLE_MULTI_CONN_OPTIMIZATION: u32 = 1;
pub const SOC_BLE_USE_WIFI_PWR_CLK_WORKAROUND: u32 = 1;
pub const SOC_PHY_COMBO_MODULE: u32 = 1;
pub const SOC_CAPS_NO_RESET_BY_ANA_BOD: u32 = 1;
pub const SOC_LP_CORE_SINGLE_INTERRUPT_VECTOR: u32 = 1;
pub const SOC_LP_CORE_SUPPORT_ETM: u32 = 1;
pub const SOC_DEBUG_HAVE_OCD_STUB_BINS: u32 = 1;
pub const ESP_CAL_DATA_CHECK_FAIL: u32 = 1;
pub const CONFIG_SOC_ADC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEDICATED_GPIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_UHCI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GDMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_AHB_GDMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PCNT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MCPWM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TWAI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ETM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PARLIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_IEEE802154_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TEMP_SENSOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PHY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORTS_SECURE_DL_MODE: u32 = 1;
pub const CONFIG_SOC_ULP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LP_CORE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD: u32 = 1;
pub const CONFIG_SOC_EFUSE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPSPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORT_COEXISTENCE: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_HMAC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DIG_SIGN_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ECC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDIO_SLAVE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BOD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_APM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PMU_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PAU_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LP_TIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LP_AON_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LP_PERIPHERALS_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LP_I2C_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ULP_LP_UART_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_TREE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ASSIST_DEBUG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WDT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_FLASH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RNG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LIGHT_SLEEP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEEP_SLEEP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MODEM_CLOCK_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const CONFIG_SOC_XTAL_CLOCK_PATH_DEPENDS_ON_TOP_DOMAIN: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_AES_GDMA: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_MONITOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_PERIPH_NUM: u32 = 1;
pub const CONFIG_SOC_ADC_MAX_CHANNEL_NUM: u32 = 7;
pub const CONFIG_SOC_ADC_ATTEN_NUM: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 1;
pub const CONFIG_SOC_ADC_PATT_LEN_MAX: u32 = 8;
pub const CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_MONITOR_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_RESULT_BYTES: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 4;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 83333;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 611;
pub const CONFIG_SOC_ADC_RTC_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_RTC_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_CALIB_CHAN_COMPENS_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_TEMPERATURE_SHARE_INTR: u32 = 1;
pub const CONFIG_SOC_ADC_SHARED_POWER: u32 = 1;
pub const CONFIG_SOC_BROWNOUT_RESET_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHARED_IDCACHE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CACHE_FREEZE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CPU_CORES_NUM: u32 = 1;
pub const CONFIG_SOC_CPU_INTR_NUM: u32 = 32;
pub const CONFIG_SOC_CPU_HAS_FLEXIBLE_INTC: u32 = 1;
pub const CONFIG_SOC_INT_PLIC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CPU_HAS_CSR_PC: u32 = 1;
pub const CONFIG_SOC_CPU_BREAKPOINTS_NUM: u32 = 4;
pub const CONFIG_SOC_CPU_WATCHPOINTS_NUM: u32 = 4;
pub const CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE: u32 = 2147483648;
pub const CONFIG_SOC_CPU_HAS_PMA: u32 = 1;
pub const CONFIG_SOC_CPU_IDRAM_SPLIT_USING_PMP: u32 = 1;
pub const CONFIG_SOC_CPU_PMP_REGION_GRANULARITY: u32 = 4;
pub const CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN: u32 = 3072;
pub const CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH: u32 = 16;
pub const CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US: u32 = 1100;
pub const CONFIG_SOC_AHB_GDMA_VERSION: u32 = 1;
pub const CONFIG_SOC_GDMA_NUM_GROUPS_MAX: u32 = 1;
pub const CONFIG_SOC_GDMA_PAIRS_PER_GROUP_MAX: u32 = 3;
pub const CONFIG_SOC_GDMA_SUPPORT_ETM: u32 = 1;
pub const CONFIG_SOC_GDMA_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_ETM_GROUPS: u32 = 1;
pub const CONFIG_SOC_ETM_CHANNELS_PER_GROUP: u32 = 50;
pub const CONFIG_SOC_ETM_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_GPIO_PORT: u32 = 1;
pub const CONFIG_SOC_GPIO_PIN_COUNT: u32 = 31;
pub const CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER: u32 = 1;
pub const CONFIG_SOC_GPIO_FLEX_GLITCH_FILTER_NUM: u32 = 8;
pub const CONFIG_SOC_GPIO_SUPPORT_ETM: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_RTC_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_DEEPSLEEP_WAKEUP: u32 = 1;
pub const CONFIG_SOC_LP_IO_CLOCK_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_GPIO_IN_RANGE_MAX: u32 = 30;
pub const CONFIG_SOC_GPIO_OUT_RANGE_MAX: u32 = 30;
pub const CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_VALID_GPIO_MASK: u32 = 0;
pub const CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_SUPPORTED_PIN_CNT: u32 = 8;
pub const CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u32 = 2147483392;
pub const CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_HOLD_SINGLE_IO_IN_DSLP: u32 = 1;
pub const CONFIG_SOC_GPIO_CLOCKOUT_BY_GPIO_MATRIX: u32 = 1;
pub const CONFIG_SOC_CLOCKOUT_HAS_SOURCE_GATE: u32 = 1;
pub const CONFIG_SOC_GPIO_CLOCKOUT_CHANNEL_NUM: u32 = 3;
pub const CONFIG_SOC_RTCIO_PIN_COUNT: u32 = 8;
pub const CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_HOLD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_WAKE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_EDGE_WAKE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_PERIPH_ALWAYS_ENABLE: u32 = 1;
pub const CONFIG_SOC_I2C_NUM: u32 = 2;
pub const CONFIG_SOC_HP_I2C_NUM: u32 = 1;
pub const CONFIG_SOC_I2C_FIFO_LEN: u32 = 32;
pub const CONFIG_SOC_I2C_CMD_REG_NUM: u32 = 8;
pub const CONFIG_SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_HW_FSM_RST: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_RTC: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_10BIT_ADDR: u32 = 1;
pub const CONFIG_SOC_I2C_SLAVE_SUPPORT_BROADCAST: u32 = 1;
pub const CONFIG_SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE: u32 = 1;
pub const CONFIG_SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS: u32 = 1;
pub const CONFIG_SOC_I2C_SLAVE_SUPPORT_SLAVE_UNMATCH: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_LP_I2C_NUM: u32 = 1;
pub const CONFIG_SOC_LP_I2C_FIFO_LEN: u32 = 16;
pub const CONFIG_SOC_I2S_NUM: u32 = 1;
pub const CONFIG_SOC_I2S_HW_VERSION_2: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_ETM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_XTAL: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PLL_F160M: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PCM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_TX: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PCM2PDM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_RX: u32 = 1;
pub const CONFIG_SOC_I2S_PDM_MAX_TX_LINES: u32 = 2;
pub const CONFIG_SOC_I2S_PDM_MAX_RX_LINES: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_TDM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_PLL_DIV_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_TIMER_NUM: u32 = 4;
pub const CONFIG_SOC_LEDC_CHANNEL_NUM: u32 = 6;
pub const CONFIG_SOC_LEDC_TIMER_BIT_WIDTH: u32 = 20;
pub const CONFIG_SOC_LEDC_SUPPORT_FADE_STOP: u32 = 1;
pub const CONFIG_SOC_LEDC_GAMMA_CURVE_FADE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LEDC_GAMMA_CURVE_FADE_RANGE_MAX: u32 = 16;
pub const CONFIG_SOC_LEDC_FADE_PARAMS_BIT_WIDTH: u32 = 10;
pub const CONFIG_SOC_LEDC_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_MMU_PAGE_SIZE_CONFIGURABLE: u32 = 1;
pub const CONFIG_SOC_MMU_PAGE_SIZE_8KB_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MMU_PERIPH_NUM: u32 = 1;
pub const CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM: u32 = 1;
pub const CONFIG_SOC_MMU_DI_VADDR_SHARED: u32 = 1;
pub const CONFIG_SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const CONFIG_SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const CONFIG_SOC_PCNT_GROUPS: u32 = 1;
pub const CONFIG_SOC_PCNT_UNITS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_PCNT_CHANNELS_PER_UNIT: u32 = 2;
pub const CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT: u32 = 2;
pub const CONFIG_SOC_PCNT_SUPPORT_RUNTIME_THRES_UPDATE: u32 = 1;
pub const CONFIG_SOC_PCNT_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_RMT_GROUPS: u32 = 1;
pub const CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_RMT_CHANNELS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 48;
pub const CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_RC_FAST: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_MCPWM_GROUPS: u32 = 1;
pub const CONFIG_SOC_MCPWM_TIMERS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_OPERATORS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_COMPARATORS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_GENERATORS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_TRIGGERS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_GPIO_FAULTS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP: u32 = 1;
pub const CONFIG_SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER: u32 = 3;
pub const CONFIG_SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_SWSYNC_CAN_PROPAGATE: u32 = 1;
pub const CONFIG_SOC_MCPWM_SUPPORT_ETM: u32 = 1;
pub const CONFIG_SOC_MCPWM_CAPTURE_CLK_FROM_GROUP: u32 = 1;
pub const CONFIG_SOC_MCPWM_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_PARLIO_GROUPS: u32 = 1;
pub const CONFIG_SOC_PARLIO_TX_UNITS_PER_GROUP: u32 = 1;
pub const CONFIG_SOC_PARLIO_RX_UNITS_PER_GROUP: u32 = 1;
pub const CONFIG_SOC_PARLIO_TX_UNIT_MAX_DATA_WIDTH: u32 = 16;
pub const CONFIG_SOC_PARLIO_RX_UNIT_MAX_DATA_WIDTH: u32 = 16;
pub const CONFIG_SOC_PARLIO_TX_RX_SHARE_INTERRUPT: u32 = 1;
pub const CONFIG_SOC_PARLIO_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_MPI_MEM_BLOCKS_NUM: u32 = 4;
pub const CONFIG_SOC_MPI_OPERATIONS_NUM: u32 = 3;
pub const CONFIG_SOC_RSA_MAX_BIT_LEN: u32 = 3072;
pub const CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE: u32 = 3968;
pub const CONFIG_SOC_SHA_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_RESUME: u32 = 1;
pub const CONFIG_SOC_SHA_GDMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA224: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const CONFIG_SOC_SDM_GROUPS: u32 = 1;
pub const CONFIG_SOC_SDM_CHANNELS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_SDM_CLK_SUPPORT_PLL_F80M: u32 = 1;
pub const CONFIG_SOC_SDM_CLK_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_SPI_MAX_CS_NUM: u32 = 6;
pub const CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const CONFIG_SOC_SPI_SUPPORT_DDRCLK: u32 = 1;
pub const CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CD_SIG: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_XTAL: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_PLL_F80M: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_RC_FAST: u32 = 1;
pub const CONFIG_SOC_SPI_SCT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_SCT_REG_NUM: u32 = 14;
pub const CONFIG_SOC_SPI_SCT_BUFFER_NUM_MAX: u32 = 1;
pub const CONFIG_SOC_SPI_SCT_CONF_BITLEN_MAX: u32 = 262138;
pub const CONFIG_SOC_MEMSPI_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_SPI_MAX_PRE_DIVIDER: u32 = 16;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_IDLE_INTR: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_CHECK_SUS: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_WRAP: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_COUNTER_NUM: u32 = 2;
pub const CONFIG_SOC_SYSTIMER_ALARM_NUM: u32 = 3;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO: u32 = 32;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI: u32 = 20;
pub const CONFIG_SOC_SYSTIMER_FIXED_DIVIDER: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_SUPPORT_RC_FAST: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_INT_LEVEL: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_SUPPORT_ETM: u32 = 1;
pub const CONFIG_SOC_LP_TIMER_BIT_WIDTH_LO: u32 = 32;
pub const CONFIG_SOC_LP_TIMER_BIT_WIDTH_HI: u32 = 16;
pub const CONFIG_SOC_TIMER_GROUPS: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 54;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_RC_FAST: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 2;
pub const CONFIG_SOC_TIMER_SUPPORT_ETM: u32 = 1;
pub const CONFIG_SOC_TIMER_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_MWDT_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_MWDT_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_TWAI_CONTROLLER_NUM: u32 = 2;
pub const CONFIG_SOC_TWAI_MASK_FILTER_NUM: u32 = 1;
pub const CONFIG_SOC_TWAI_CLK_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_TWAI_BRP_MIN: u32 = 2;
pub const CONFIG_SOC_TWAI_BRP_MAX: u32 = 32768;
pub const CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS: u32 = 1;
pub const CONFIG_SOC_TWAI_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_PAD_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_USB_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT: u32 = 1;
pub const CONFIG_SOC_EFUSE_SOFT_DIS_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_ICACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_V2_RSA: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_V2_ECC: u32 = 1;
pub const CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 3;
pub const CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: u32 = 1;
pub const CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 64;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128: u32 = 1;
pub const CONFIG_SOC_APM_CTRL_FILTER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_APM_LP_APM0_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_APM_SUPPORT_LP_TEE_CTRL: u32 = 1;
pub const CONFIG_SOC_CRYPTO_DPA_PROTECTION_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_UART_NUM: u32 = 3;
pub const CONFIG_SOC_UART_HP_NUM: u32 = 2;
pub const CONFIG_SOC_UART_LP_NUM: u32 = 1;
pub const CONFIG_SOC_UART_FIFO_LEN: u32 = 128;
pub const CONFIG_SOC_LP_UART_FIFO_LEN: u32 = 16;
pub const CONFIG_SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const CONFIG_SOC_UART_SUPPORT_PLL_F80M_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_RTC_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_XTAL_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_WAKEUP_INT: u32 = 1;
pub const CONFIG_SOC_UART_HAS_LP_UART: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND: u32 = 1;
pub const CONFIG_SOC_UART_WAKEUP_CHARS_SEQ_MAX_LEN: u32 = 5;
pub const CONFIG_SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE: u32 = 1;
pub const CONFIG_SOC_UART_WAKEUP_SUPPORT_FIFO_THRESH_MODE: u32 = 1;
pub const CONFIG_SOC_UART_WAKEUP_SUPPORT_START_BIT_MODE: u32 = 1;
pub const CONFIG_SOC_UART_WAKEUP_SUPPORT_CHAR_SEQ_MODE: u32 = 1;
pub const CONFIG_SOC_UHCI_NUM: u32 = 1;
pub const CONFIG_SOC_COEX_HW_PTI: u32 = 1;
pub const CONFIG_SOC_EXTERNAL_COEX_ADVANCE: u32 = 1;
pub const CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 21;
pub const CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH: u32 = 12;
pub const CONFIG_SOC_RTC_MEM_SUPPORT_SPEED_MODE_SWITCH: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_BEACON_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_BT_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP_MODE_PER_PIN: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_CPU_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_MODEM_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_XTAL32K_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RC32K_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RC_FAST_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_TOP_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_HP_AON_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_MAC_BB_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_PMU_MODEM_STATE: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_PMU_CLK_ICG: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY: u32 = 1;
pub const CONFIG_SOC_PM_CPU_RETENTION_BY_SW: u32 = 1;
pub const CONFIG_SOC_PM_MODEM_RETENTION_BY_REGDMA: u32 = 1;
pub const CONFIG_SOC_PM_RETENTION_HAS_CLOCK_BUG: u32 = 1;
pub const CONFIG_SOC_EXT_MEM_CACHE_TAG_IN_CPU_DOMAIN: u32 = 1;
pub const CONFIG_SOC_PM_PAU_LINK_NUM: u32 = 4;
pub const CONFIG_SOC_PM_PAU_REGDMA_LINK_MULTI_ADDR: u32 = 1;
pub const CONFIG_SOC_PM_PAU_REGDMA_LINK_WIFIMAC: u32 = 1;
pub const CONFIG_SOC_PM_PAU_REGDMA_UPDATE_CACHE_BEFORE_WAIT_COMPARE: u32 = 1;
pub const CONFIG_SOC_PM_PMU_MIN_SLP_SLOW_CLK_CYCLE_FIXED: u32 = 1;
pub const CONFIG_SOC_PM_RETENTION_MODULE_NUM: u32 = 32;
pub const CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION: u32 = 1;
pub const CONFIG_SOC_MODEM_CLOCK_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_CLK_XTAL32K_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_OSC_SLOW_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_RC32K_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_LP_FAST_SUPPORT_XTAL_D2: u32 = 1;
pub const CONFIG_SOC_RCC_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_CLK_ANA_I2C_MST_HAS_ROOT_GATE: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_INTR_SUPPORT: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_ETM: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_SLEEP_RETENTION: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_UNDER_PD_TOP_DOMAIN: u32 = 1;
pub const CONFIG_SOC_RNG_CLOCK_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_WIFI_HW_TSF: u32 = 1;
pub const CONFIG_SOC_WIFI_FTM_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_GCMP_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_HE_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_MAC_VERSION_NUM: u32 = 2;
pub const CONFIG_SOC_BLE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_MESH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ESP_NIMBLE_CONTROLLER: u32 = 1;
pub const CONFIG_SOC_BLE_50_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_DEVICE_PRIVACY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_POWER_CONTROL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_PERIODIC_ADV_ENH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLUFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_MULTI_CONN_OPTIMIZATION: u32 = 1;
pub const CONFIG_SOC_BLE_USE_WIFI_PWR_CLK_WORKAROUND: u32 = 1;
pub const CONFIG_SOC_PHY_COMBO_MODULE: u32 = 1;
pub const CONFIG_SOC_CAPS_NO_RESET_BY_ANA_BOD: u32 = 1;
pub const CONFIG_SOC_LP_CORE_SINGLE_INTERRUPT_VECTOR: u32 = 1;
pub const CONFIG_SOC_LP_CORE_SUPPORT_ETM: u32 = 1;
pub const CONFIG_SOC_DEBUG_HAVE_OCD_STUB_BINS: u32 = 1;
pub const CONFIG_IDF_CMAKE: u32 = 1;
pub const CONFIG_IDF_TOOLCHAIN: &[u8; 4] = b"gcc\0";
pub const CONFIG_IDF_TOOLCHAIN_GCC: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH_RISCV: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH: &[u8; 6] = b"riscv\0";
pub const CONFIG_IDF_TARGET: &[u8; 8] = b"esp32c6\0";
pub const CONFIG_IDF_INIT_VERSION: &[u8; 6] = b"5.5.1\0";
pub const CONFIG_IDF_TARGET_ESP32C6: u32 = 1;
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 13;
pub const CONFIG_APP_BUILD_TYPE_APP_2NDBOOT: u32 = 1;
pub const CONFIG_APP_BUILD_GENERATE_BINARIES: u32 = 1;
pub const CONFIG_APP_BUILD_BOOTLOADER: u32 = 1;
pub const CONFIG_APP_BUILD_USE_FLASH_SECTIONS: u32 = 1;
pub const CONFIG_APP_REPRODUCIBLE_BUILD: u32 = 1;
pub const CONFIG_BOOTLOADER_PROJECT_VER: u32 = 1;
pub const CONFIG_BOOTLOADER_OFFSET_IN_FLASH: u32 = 0;
pub const CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_VERSION_1: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_VERSION: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_INFO: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_LOG_TIMESTAMP_SOURCE_CPU_TICKS: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_MODE_TEXT_EN: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_MODE_TEXT: u32 = 1;
pub const CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT: u32 = 1;
pub const CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_BOOTLOADER_RESERVE_RTC_SIZE: u32 = 0;
pub const CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED: u32 = 1;
pub const CONFIG_SECURE_BOOT_V2_ECC_SUPPORTED: u32 = 1;
pub const CONFIG_SECURE_BOOT_V2_PREFERRED: u32 = 1;
pub const CONFIG_SECURE_ROM_DL_MODE_ENABLED: u32 = 1;
pub const CONFIG_APP_RETRIEVE_LEN_ELF_SHA: u32 = 9;
pub const CONFIG_ESP_ROM_HAS_CRC_LE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_CRC_BE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_JPEG_DECODE: u32 = 1;
pub const CONFIG_ESP_ROM_UART_CLK_IS_XTAL: u32 = 1;
pub const CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM: u32 = 3;
pub const CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING: u32 = 1;
pub const CONFIG_ESP_ROM_GET_CLK_FREQ: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_RVFPLIB: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_HAL_WDT: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_HAL_SYSTIMER: u32 = 1;
pub const CONFIG_ESP_ROM_SYSTIMER_INIT_PATCH: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_HEAP_TLSF: u32 = 1;
pub const CONFIG_ESP_ROM_TLSF_CHECK_PATCH: u32 = 1;
pub const CONFIG_ESP_ROM_MULTI_HEAP_WALK_PATCH: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_LAYOUT_TABLE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SPI_FLASH: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SPI_FLASH_MMAP: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_REGI2C_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB_NORMAL_FORMAT: u32 = 1;
pub const CONFIG_ESP_ROM_REV0_HAS_NO_ECDSA_INTERFACE: u32 = 1;
pub const CONFIG_ESP_ROM_WDT_INIT_PATCH: u32 = 1;
pub const CONFIG_ESP_ROM_NEEDS_SET_CACHE_MMU_SIZE: u32 = 1;
pub const CONFIG_ESP_ROM_RAM_APP_NEEDS_MMU_INIT: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SW_FLOAT: u32 = 1;
pub const CONFIG_ESP_ROM_USB_OTG_NUM: i32 = -1;
pub const CONFIG_ESP_ROM_HAS_VERSION: u32 = 1;
pub const CONFIG_ESP_ROM_SUPPORT_DEEP_SLEEP_WAKEUP_STUB: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_OUTPUT_PUTC_FUNC: u32 = 1;
pub const CONFIG_ESP_ROM_NO_USB_SERIAL_OUTPUT_API: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SUBOPTIMAL_NEWLIB_ON_MISALIGNED_MEMORY: u32 = 1;
pub const CONFIG_BOOT_ROM_LOG_ALWAYS_ON: u32 = 1;
pub const CONFIG_SECURE_TEE_LOG_LEVEL: u32 = 0;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &[u8; 4] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_80M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &[u8; 4] = b"80m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &[u8; 4] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &[u8; 14] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &[u8; 11] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &[u8; 15] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &[u8; 25] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT: u32 = 1;
pub const CONFIG_COMPILER_ASSERT_NDEBUG_EVALUATE: u32 = 1;
pub const CONFIG_COMPILER_FLOAT_LIB_FROM_RVFPLIB: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT: u32 = 1;
pub const CONFIG_COMPILER_HIDE_PATHS_MACROS: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_COMPILER_DISABLE_DEFAULT_ERRORS: u32 = 1;
pub const CONFIG_COMPILER_RT_LIB_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_RT_LIB_NAME: &[u8; 4] = b"gcc\0";
pub const CONFIG_COMPILER_ORPHAN_SECTIONS_WARNING: u32 = 1;
pub const CONFIG_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_UART_NONE: u32 = 1;
pub const CONFIG_APPTRACE_UART_TASK_PRIO: u32 = 1;
pub const CONFIG_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 256;
pub const CONFIG_ESP_TLS_USING_MBEDTLS: u32 = 1;
pub const CONFIG_ESP_TLS_USE_DS_PERIPHERAL: u32 = 1;
pub const CONFIG_ESP_TLS_DYN_BUF_STRATEGY_SUPPORTED: u32 = 1;
pub const CONFIG_ESP_COEX_ENABLED: u32 = 1;
pub const CONFIG_ESP_COEX_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_GPTIMER_OBJ_CACHE_SAFE: u32 = 1;
pub const CONFIG_I2C_MASTER_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_MCPWM_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_MCPWM_OBJ_CACHE_SAFE: u32 = 1;
pub const CONFIG_PARLIO_TX_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_PARLIO_RX_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_PARLIO_OBJ_CACHE_SAFE: u32 = 1;
pub const CONFIG_RMT_ENCODER_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_RMT_TX_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_RMT_RX_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_RMT_OBJ_CACHE_SAFE: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_USJ_ENABLE_USB_SERIAL_JTAG: u32 = 1;
pub const CONFIG_ETH_ENABLED: u32 = 1;
pub const CONFIG_ETH_USE_SPI_ETHERNET: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_ENABLED: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_SUPPORT_TASKS: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_MAX_TASKS: u32 = 32;
pub const CONFIG_ESPHID_TASK_SIZE_BT: u32 = 2048;
pub const CONFIG_ESPHID_TASK_SIZE_BLE: u32 = 4096;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_ESP_HTTP_CLIENT_EVENT_POST_TIMEOUT: u32 = 2000;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 1024;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_HTTPD_PURGE_BUF_LEN: u32 = 32;
pub const CONFIG_HTTPD_SERVER_EVENT_POST_TIMEOUT: u32 = 2000;
pub const CONFIG_ESP_HTTPS_OTA_EVENT_POST_TIMEOUT: u32 = 2000;
pub const CONFIG_ESP_HTTPS_SERVER_EVENT_POST_TIMEOUT: u32 = 2000;
pub const CONFIG_ESP32C6_REV_MIN_0: u32 = 1;
pub const CONFIG_ESP32C6_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP32C6_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_EFUSE_BLOCK_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP_EFUSE_BLOCK_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_BT: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_IEEE802154: u32 = 1;
pub const CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY: u32 = 0;
pub const CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS: u32 = 1;
pub const CONFIG_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP_PERIPH_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_REGI2C_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_GDMA_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_GDMA_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_GDMA_OBJ_DRAM_SAFE: u32 = 1;
pub const CONFIG_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_XTAL_FREQ: u32 = 40;
pub const CONFIG_ESP_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP_BROWNOUT_USE_INTR: u32 = 1;
pub const CONFIG_ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_INTR_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_ESP_NETIF_TCPIP_LWIP: u32 = 1;
pub const CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API: u32 = 1;
pub const CONFIG_ESP_NETIF_REPORT_DATA_TRAFFIC: u32 = 1;
pub const CONFIG_ESP_PHY_ENABLED: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_RF_CAL_PARTIAL: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_MODE: u32 = 0;
pub const CONFIG_ESP_PHY_PLL_TRACK_PERIOD_MS: u32 = 1000;
pub const CONFIG_ESP_PHY_IRAM_OPT: u32 = 1;
pub const CONFIG_PM_SLEEP_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_PM_SLP_IRAM_OPT: u32 = 1;
pub const CONFIG_PM_SLP_DEFAULT_PARAMS_OPT: u32 = 1;
pub const CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP: u32 = 1;
pub const CONFIG_ESP_ROM_PRINT_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_CRYPTO_DPA_PROTECTION_AT_STARTUP: u32 = 1;
pub const CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_LOW: u32 = 1;
pub const CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP_SYSTEM_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS: u32 = 0;
pub const CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_NO_BACKTRACE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PMP_IDRAM_SPLIT: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG: u32 = 1;
pub const CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG_ENABLED: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_TASK_WDT_EN: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_INIT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4: u32 = 1;
pub const CONFIG_ESP_SYSTEM_HW_STACK_GUARD: u32 = 1;
pub const CONFIG_ESP_SYSTEM_BBPLL_RECALIB: u32 = 1;
pub const CONFIG_ESP_SYSTEM_HW_PC_RECORD: u32 = 1;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_ESP_TIMER_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_TIMER_INTERRUPT_LEVEL: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_TIMER_IMPL_SYSTIMER: u32 = 1;
pub const CONFIG_ESP_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER: u32 = 1;
pub const CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF: u32 = 0;
pub const CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM_DEF: u32 = 5;
pub const CONFIG_ESP_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_EXTRA_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_SLP_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_MIN_ACTIVE_TIME: u32 = 50;
pub const CONFIG_ESP_WIFI_BSS_MAX_IDLE_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_MAX_ACTIVE_TIME: u32 = 10;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_WAIT_BROADCAST_DATA_TIME: u32 = 15;
pub const CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE: u32 = 1;
pub const CONFIG_ESP_WIFI_GMAC_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM: u32 = 7;
pub const CONFIG_ESP_WIFI_TX_HETB_QUEUE_NUM: u32 = 3;
pub const CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT: u32 = 1;
pub const CONFIG_ESP_COREDUMP_ENABLE_TO_NONE: u32 = 1;
pub const CONFIG_FATFS_VOLUME_COUNT: u32 = 2;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_SECTOR_4096: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FATFS_USE_STRFUNC_NONE: u32 = 1;
pub const CONFIG_FATFS_VFS_FSTAT_BLKSIZE: u32 = 0;
pub const CONFIG_FATFS_LINK_LOCK: u32 = 1;
pub const CONFIG_FATFS_DONT_TRUST_FREE_CLUSTER_CNT: u32 = 0;
pub const CONFIG_FATFS_DONT_TRUST_LAST_ALLOC: u32 = 0;
pub const CONFIG_FREERTOS_UNICORE: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_OPTIMIZED_SCHEDULER: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_USE_TIMERS: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME: &[u8; 8] = b"Tmr Svc\0";
pub const CONFIG_FREERTOS_TIMER_TASK_NO_AFFINITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_SERVICE_TASK_CORE_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 1;
pub const CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER: u32 = 1;
pub const CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1: u32 = 1;
pub const CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER: u32 = 1;
pub const CONFIG_FREERTOS_PORT: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const CONFIG_FREERTOS_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT: u32 = 1;
pub const CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH: u32 = 1;
pub const CONFIG_FREERTOS_NUMBER_OF_CORES: u32 = 1;
pub const CONFIG_FREERTOS_IN_IRAM: u32 = 1;
pub const CONFIG_HAL_ASSERTION_EQUALS_SYSTEM: u32 = 1;
pub const CONFIG_HAL_DEFAULT_ASSERTION_LEVEL: u32 = 1;
pub const CONFIG_HAL_SYSTIMER_USE_ROM_IMPL: u32 = 1;
pub const CONFIG_HAL_WDT_USE_ROM_IMPL: u32 = 1;
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_HEAP_TRACING_OFF: u32 = 1;
pub const CONFIG_HEAP_TLSF_USE_ROM_IMPL: u32 = 1;
pub const CONFIG_IEEE802154_ENABLED: u32 = 1;
pub const CONFIG_IEEE802154_RX_BUFFER_SIZE: u32 = 20;
pub const CONFIG_IEEE802154_CCA_ED: u32 = 1;
pub const CONFIG_IEEE802154_CCA_MODE: u32 = 1;
pub const CONFIG_IEEE802154_CCA_THRESHOLD: i32 = -60;
pub const CONFIG_IEEE802154_PENDING_TABLE_SIZE: u32 = 20;
pub const CONFIG_IEEE802154_TIMING_OPTIMIZATION: u32 = 1;
pub const CONFIG_LOG_VERSION_1: u32 = 1;
pub const CONFIG_LOG_VERSION: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT: u32 = 1;
pub const CONFIG_LOG_MAXIMUM_LEVEL: u32 = 3;
pub const CONFIG_LOG_DYNAMIC_LEVEL_CONTROL: u32 = 1;
pub const CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_AND_LINKED_LIST: u32 = 1;
pub const CONFIG_LOG_TAG_LEVEL_CACHE_BINARY_MIN_HEAP: u32 = 1;
pub const CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_SIZE: u32 = 31;
pub const CONFIG_LOG_TIMESTAMP_SOURCE_RTOS: u32 = 1;
pub const CONFIG_LOG_MODE_TEXT_EN: u32 = 1;
pub const CONFIG_LOG_MODE_TEXT: u32 = 1;
pub const CONFIG_LOG_IN_IRAM: u32 = 1;
pub const CONFIG_LWIP_ENABLE: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &[u8; 10] = b"espressif\0";
pub const CONFIG_LWIP_TCPIP_TASK_PRIO: u32 = 18;
pub const CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 1;
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_ND6: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_IP_DEFAULT_TTL: u32 = 64;
pub const CONFIG_LWIP_IP4_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP6_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP_REASS_MAX_PBUFS: u32 = 10;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_ESP_MLDV6_REPORT: u32 = 1;
pub const CONFIG_LWIP_MLDV6_TMR_INTERVAL: u32 = 40;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID: u32 = 1;
pub const CONFIG_LWIP_DHCP_OPTIONS_LEN: u32 = 69;
pub const CONFIG_LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const CONFIG_LWIP_DHCP_COARSE_TIMER_SECS: u32 = 1;
pub const CONFIG_LWIP_DHCPS: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_DHCPS_STATIC_ENTRIES: u32 = 1;
pub const CONFIG_LWIP_DHCPS_ADD_DNS: u32 = 1;
pub const CONFIG_LWIP_IPV4: u32 = 1;
pub const CONFIG_LWIP_IPV6: u32 = 1;
pub const CONFIG_LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION: u32 = 1;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1440;
pub const CONFIG_LWIP_TCP_TMR_INTERVAL: u32 = 250;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 5760;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5760;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OOSEQ_TIMEOUT: u32 = 6;
pub const CONFIG_LWIP_TCP_OOSEQ_MAX_PBUFS: u32 = 4;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_TCP_RTO_TIME: u32 = 1500;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS: u32 = 5;
pub const CONFIG_LWIP_IPV6_ND6_NUM_PREFIXES: u32 = 5;
pub const CONFIG_LWIP_IPV6_ND6_NUM_ROUTERS: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_DESTINATIONS: u32 = 10;
pub const CONFIG_LWIP_ICMP: u32 = 1;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_SNTP_MAX_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_LWIP_SNTP_STARTUP_DELAY: u32 = 1;
pub const CONFIG_LWIP_SNTP_MAXIMUM_STARTUP_DELAY: u32 = 5000;
pub const CONFIG_LWIP_DNS_MAX_HOST_IP: u32 = 1;
pub const CONFIG_LWIP_DNS_MAX_SERVERS: u32 = 3;
pub const CONFIG_LWIP_BRIDGEIF_MAX_PORTS: u32 = 7;
pub const CONFIG_LWIP_ESP_LWIP_ASSERT: u32 = 1;
pub const CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_ROUTE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_ND6_GET_GW_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_INPUT_DEFAULT: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE: u32 = 1;
pub const CONFIG_MBEDTLS_PKCS7_C: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS: u32 = 200;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_MBEDTLS_AES_USE_INTERRUPT: u32 = 1;
pub const CONFIG_MBEDTLS_AES_INTERRUPT_LEVEL: u32 = 0;
pub const CONFIG_MBEDTLS_GCM_SUPPORT_NON_AES_CIPHER: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_MPI: u32 = 1;
pub const CONFIG_MBEDTLS_LARGE_KEY_SOFTWARE_MPI: u32 = 1;
pub const CONFIG_MBEDTLS_MPI_USE_INTERRUPT: u32 = 1;
pub const CONFIG_MBEDTLS_MPI_INTERRUPT_LEVEL: u32 = 0;
pub const CONFIG_MBEDTLS_HARDWARE_ECC: u32 = 1;
pub const CONFIG_MBEDTLS_ECC_OTHER_CURVES_SOFT_FALLBACK: u32 = 1;
pub const CONFIG_MBEDTLS_ROM_MD5: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_DETERMINISTIC: u32 = 1;
pub const CONFIG_MBEDTLS_SHA512_C: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_PK_PARSE_EC_EXTENDED: u32 = 1;
pub const CONFIG_MBEDTLS_PK_PARSE_EC_COMPRESSED: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MBEDTLS_ERROR_STRINGS: u32 = 1;
pub const CONFIG_MBEDTLS_FS_IO: u32 = 1;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_LIBC_NEWLIB: u32 = 1;
pub const CONFIG_LIBC_MISC_IN_IRAM: u32 = 1;
pub const CONFIG_LIBC_LOCKS_PLACE_IN_IRAM: u32 = 1;
pub const CONFIG_LIBC_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_LIBC_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_LIBC_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_PATCH_VERSION: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8] = b"pthread\0";
pub const CONFIG_MMU_PAGE_SIZE_32KB: u32 = 1;
pub const CONFIG_MMU_PAGE_MODE: &[u8; 5] = b"32KB\0";
pub const CONFIG_MMU_PAGE_SIZE: u32 = 32768;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC: u32 = 1;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET: u32 = 1;
pub const CONFIG_SPI_FLASH_SUSPEND_TSUS_VAL_US: u32 = 50;
pub const CONFIG_SPI_FLASH_PLACE_FUNCTIONS_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_YIELD_DURING_ERASE: u32 = 1;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS: u32 = 20;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_TICKS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE: u32 = 8192;
pub const CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_GD_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_GD_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_WS_TRANSPORT: u32 = 1;
pub const CONFIG_WS_BUFFER_SIZE: u32 = 1024;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_VFS_SUPPORT_IO: u32 = 1;
pub const CONFIG_VFS_SUPPORT_DIR: u32 = 1;
pub const CONFIG_VFS_SUPPORT_SELECT: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_VFS_MAX_COUNT: u32 = 8;
pub const CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_VFS_INITIALIZE_DEV_NULL: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES: u32 = 16;
pub const CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT: u32 = 30;
pub const CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_CONSOLE_UART: u32 = 1;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP32_WIFI_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_BROWNOUT_INTR: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU: u32 = 1;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_ESP_WIFI_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_GDBSTUB_MAX_TASKS: u32 = 32;
pub const CONFIG_GDBSTUB_SUPPORT_TASKS: u32 = 1;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_SILENT: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTION_LEVEL: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_PERIPH_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_ISR: u32 = 1;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1440;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5760;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5760;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const BLE_NPL_OS_ALIGNMENT: u32 = 4;
pub const SOC_CLK_RC_FAST_FREQ_APPROX: u32 = 17500000;
pub const SOC_CLK_RC_SLOW_FREQ_APPROX: u32 = 136000;
pub const SOC_CLK_RC32K_FREQ_APPROX: u32 = 32768;
pub const SOC_CLK_XTAL32K_FREQ_APPROX: u32 = 32768;
pub const SOC_CLK_OSC_SLOW_FREQ_APPROX: u32 = 32768;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const BIT63: i64 = -9223372036854775808;
pub const BIT62: u64 = 4611686018427387904;
pub const BIT61: u64 = 2305843009213693952;
pub const BIT60: u64 = 1152921504606846976;
pub const BIT59: u64 = 576460752303423488;
pub const BIT58: u64 = 288230376151711744;
pub const BIT57: u64 = 144115188075855872;
pub const BIT56: u64 = 72057594037927936;
pub const BIT55: u64 = 36028797018963968;
pub const BIT54: u64 = 18014398509481984;
pub const BIT53: u64 = 9007199254740992;
pub const BIT52: u64 = 4503599627370496;
pub const BIT51: u64 = 2251799813685248;
pub const BIT50: u64 = 1125899906842624;
pub const BIT49: u64 = 562949953421312;
pub const BIT48: u64 = 281474976710656;
pub const BIT47: u64 = 140737488355328;
pub const BIT46: u64 = 70368744177664;
pub const BIT45: u64 = 35184372088832;
pub const BIT44: u64 = 17592186044416;
pub const BIT43: u64 = 8796093022208;
pub const BIT42: u64 = 4398046511104;
pub const BIT41: u64 = 2199023255552;
pub const BIT40: u64 = 1099511627776;
pub const BIT39: u64 = 549755813888;
pub const BIT38: u64 = 274877906944;
pub const BIT37: u64 = 137438953472;
pub const BIT36: u64 = 68719476736;
pub const BIT35: u64 = 34359738368;
pub const BIT34: u64 = 17179869184;
pub const BIT33: u64 = 8589934592;
pub const BIT32: u64 = 4294967296;
pub const DR_REG_PLIC_MX_BASE: u32 = 536875008;
pub const DR_REG_PLIC_UX_BASE: u32 = 536876032;
pub const DR_REG_CLINT_M_BASE: u32 = 536877056;
pub const DR_REG_CLINT_U_BASE: u32 = 536878080;
pub const DR_REG_CLINT_U_END: u32 = 536879104;
pub const DR_REG_UART_BASE: u32 = 1610612736;
pub const DR_REG_UART1_BASE: u32 = 1610616832;
pub const DR_REG_SPI0_BASE: u32 = 1610620928;
pub const DR_REG_SPI1_BASE: u32 = 1610625024;
pub const DR_REG_I2C_EXT_BASE: u32 = 1610629120;
pub const DR_REG_UHCI0_BASE: u32 = 1610633216;
pub const DR_REG_RMT_BASE: u32 = 1610637312;
pub const DR_REG_LEDC_BASE: u32 = 1610641408;
pub const DR_REG_TIMERGROUP0_BASE: u32 = 1610645504;
pub const DR_REG_TIMERGROUP1_BASE: u32 = 1610649600;
pub const DR_REG_SYSTIMER_BASE: u32 = 1610653696;
pub const DR_REG_TWAI0_BASE: u32 = 1610657792;
pub const DR_REG_I2S_BASE: u32 = 1610661888;
pub const DR_REG_TWAI1_BASE: u32 = 1610665984;
pub const DR_REG_APB_SARADC_BASE: u32 = 1610670080;
pub const DR_REG_USB_SERIAL_JTAG_BASE: u32 = 1610674176;
pub const DR_REG_INTMTX_BASE: u32 = 1610678272;
pub const DR_REG_ATOMIC_BASE: u32 = 1610682368;
pub const DR_REG_PCNT_BASE: u32 = 1610686464;
pub const DR_REG_SOC_ETM_BASE: u32 = 1610690560;
pub const DR_REG_MCPWM_BASE: u32 = 1610694656;
pub const DR_REG_PARL_IO_BASE: u32 = 1610698752;
pub const DR_REG_HINF_BASE: u32 = 1610702848;
pub const DR_REG_SLC_BASE: u32 = 1610706944;
pub const DR_REG_SLCHOST_BASE: u32 = 1610711040;
pub const DR_REG_PVT_MONITOR_BASE: u32 = 1610715136;
pub const DR_REG_GDMA_BASE: u32 = 1611137024;
pub const DR_REG_SPI2_BASE: u32 = 1611141120;
pub const DR_REG_AES_BASE: u32 = 1611169792;
pub const DR_REG_SHA_BASE: u32 = 1611173888;
pub const DR_REG_RSA_BASE: u32 = 1611177984;
pub const DR_REG_ECC_MULT_BASE: u32 = 1611182080;
pub const DR_REG_DS_BASE: u32 = 1611186176;
pub const DR_REG_HMAC_BASE: u32 = 1611190272;
pub const DR_REG_IO_MUX_BASE: u32 = 1611202560;
pub const DR_REG_GPIO_BASE: u32 = 1611206656;
pub const DR_REG_GPIO_EXT_BASE: u32 = 1611210496;
pub const DR_REG_MEM_MONITOR_BASE: u32 = 1611210752;
pub const DR_REG_PAU_BASE: u32 = 1611214848;
pub const DR_REG_HP_SYSTEM_BASE: u32 = 1611223040;
pub const DR_REG_PCR_BASE: u32 = 1611227136;
pub const DR_REG_TEE_BASE: u32 = 1611235328;
pub const DR_REG_HP_APM_BASE: u32 = 1611239424;
pub const DR_REG_LP_APM0_BASE: u32 = 1611241472;
pub const DR_REG_MISC_BASE: u32 = 1611264000;
pub const DR_REG_I2C_ANA_MST_BASE: u32 = 1611331584;
pub const DR_REG_PMU_BASE: u32 = 1611333632;
pub const DR_REG_LP_CLKRST_BASE: u32 = 1611334656;
pub const DR_REG_EFUSE_BASE: u32 = 1611335680;
pub const DR_REG_LP_TIMER_BASE: u32 = 1611336704;
pub const DR_REG_LP_AON_BASE: u32 = 1611337728;
pub const DR_REG_LP_UART_BASE: u32 = 1611338752;
pub const DR_REG_LP_I2C_BASE: u32 = 1611339776;
pub const DR_REG_LP_WDT_BASE: u32 = 1611340800;
pub const DR_REG_LP_IO_BASE: u32 = 1611341824;
pub const DR_REG_LP_I2C_ANA_MST_BASE: u32 = 1611342848;
pub const DR_REG_LPPERI_BASE: u32 = 1611343872;
pub const DR_REG_LP_ANALOG_PERI_BASE: u32 = 1611344896;
pub const DR_REG_LP_TEE_BASE: u32 = 1611346944;
pub const DR_REG_LP_APM_BASE: u32 = 1611347968;
pub const DR_REG_OPT_DEBUG_BASE: u32 = 1611348992;
pub const DR_REG_TRACE_BASE: u32 = 1611399168;
pub const DR_REG_ASSIST_DEBUG_BASE: u32 = 1611407360;
pub const DR_REG_CPU_BUS_MONITOR_BASE: u32 = 1611407360;
pub const DR_REG_INTPRI_BASE: u32 = 1611419648;
pub const DR_REG_EXTMEM_BASE: u32 = 1611431936;
pub const PWDET_CONF_REG: u32 = 1611270160;
pub const IEEE802154_REG_BASE: u32 = 1611280384;
pub const PRO_CPU_NUM: u32 = 0;
pub const APB_CLK_FREQ_ROM: u32 = 40000000;
pub const CPU_CLK_FREQ_ROM: u32 = 40000000;
pub const CPU_CLK_FREQ_MHZ_BTLD: u32 = 80;
pub const APB_CLK_FREQ: u32 = 40000000;
pub const MODEM_REQUIRED_MIN_APB_CLK_FREQ: u32 = 80000000;
pub const REF_CLK_FREQ: u32 = 1000000;
pub const XTAL_CLK_FREQ: u32 = 40000000;
pub const SOC_IROM_LOW: u32 = 1107296256;
pub const SOC_DROM_LOW: u32 = 1107296256;
pub const SOC_IROM_MASK_LOW: u32 = 1073741824;
pub const SOC_IROM_MASK_HIGH: u32 = 1074069504;
pub const SOC_DROM_MASK_LOW: u32 = 1073741824;
pub const SOC_DROM_MASK_HIGH: u32 = 1074069504;
pub const SOC_IRAM_LOW: u32 = 1082130432;
pub const SOC_IRAM_HIGH: u32 = 1082654720;
pub const SOC_DRAM_LOW: u32 = 1082130432;
pub const SOC_DRAM_HIGH: u32 = 1082654720;
pub const SOC_RTC_IRAM_LOW: u32 = 1342177280;
pub const SOC_RTC_IRAM_HIGH: u32 = 1342193664;
pub const SOC_RTC_DRAM_LOW: u32 = 1342177280;
pub const SOC_RTC_DRAM_HIGH: u32 = 1342193664;
pub const SOC_RTC_DATA_LOW: u32 = 1342177280;
pub const SOC_RTC_DATA_HIGH: u32 = 1342193664;
pub const SOC_DIRAM_IRAM_LOW: u32 = 1082130432;
pub const SOC_DIRAM_IRAM_HIGH: u32 = 1082654720;
pub const SOC_DIRAM_DRAM_LOW: u32 = 1082130432;
pub const SOC_DIRAM_DRAM_HIGH: u32 = 1082654720;
pub const SOC_DMA_LOW: u32 = 1082130432;
pub const SOC_DMA_HIGH: u32 = 1082654720;
pub const SOC_BYTE_ACCESSIBLE_LOW: u32 = 1082130432;
pub const SOC_BYTE_ACCESSIBLE_HIGH: u32 = 1082654720;
pub const SOC_MEM_INTERNAL_LOW: u32 = 1082130432;
pub const SOC_MEM_INTERNAL_HIGH: u32 = 1082654720;
pub const SOC_MEM_INTERNAL_LOW1: u32 = 1082130432;
pub const SOC_MEM_INTERNAL_HIGH1: u32 = 1082654720;
pub const SOC_MAX_CONTIGUOUS_RAM_SIZE: u32 = 524288;
pub const SOC_PERIPHERAL_LOW: u32 = 1610612736;
pub const SOC_PERIPHERAL_HIGH: u32 = 1611661312;
pub const SOC_CPU_SUBSYSTEM_LOW: u32 = 536870912;
pub const SOC_CPU_SUBSYSTEM_HIGH: u32 = 805306368;
pub const SOC_ROM_STACK_START: u32 = 1082648080;
pub const SOC_ROM_STACK_SIZE: u32 = 8192;
pub const ETS_T1_WDT_INUM: u32 = 24;
pub const ETS_CACHEERR_INUM: u32 = 25;
pub const ETS_MEMPROT_ERR_INUM: u32 = 26;
pub const ETS_ASSIST_DEBUG_INUM: u32 = 27;
pub const ETS_MAX_INUM: u32 = 31;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_UART0_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_SPI2_INUM: u32 = 1;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_INVALID_INUM: u32 = 0;
pub const SOC_INTERRUPT_LEVEL_MEDIUM: u32 = 4;
pub const ETS_INT_WDT_INUM: u32 = 24;
pub const PMU_HP_ACTIVE_DIG_POWER_REG: u32 = 1611333632;
pub const PMU_HP_ACTIVE_VDD_SPI_PD_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE_VDD_SPI_PD_EN_S: u32 = 21;
pub const PMU_HP_ACTIVE_HP_MEM_DSLP_V: u32 = 1;
pub const PMU_HP_ACTIVE_HP_MEM_DSLP_S: u32 = 22;
pub const PMU_HP_ACTIVE_PD_HP_MEM_PD_EN: u32 = 15;
pub const PMU_HP_ACTIVE_PD_HP_MEM_PD_EN_V: u32 = 15;
pub const PMU_HP_ACTIVE_PD_HP_MEM_PD_EN_S: u32 = 23;
pub const PMU_HP_ACTIVE_PD_HP_WIFI_PD_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE_PD_HP_WIFI_PD_EN_S: u32 = 27;
pub const PMU_HP_ACTIVE_PD_HP_CPU_PD_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE_PD_HP_CPU_PD_EN_S: u32 = 29;
pub const PMU_HP_ACTIVE_PD_HP_AON_PD_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE_PD_HP_AON_PD_EN_S: u32 = 30;
pub const PMU_HP_ACTIVE_PD_TOP_PD_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE_PD_TOP_PD_EN_S: u32 = 31;
pub const PMU_HP_ACTIVE_ICG_HP_FUNC_REG: u32 = 1611333636;
pub const PMU_HP_ACTIVE_DIG_ICG_FUNC_EN: u32 = 4294967295;
pub const PMU_HP_ACTIVE_DIG_ICG_FUNC_EN_V: u32 = 4294967295;
pub const PMU_HP_ACTIVE_DIG_ICG_FUNC_EN_S: u32 = 0;
pub const PMU_HP_ACTIVE_ICG_HP_APB_REG: u32 = 1611333640;
pub const PMU_HP_ACTIVE_DIG_ICG_APB_EN: u32 = 4294967295;
pub const PMU_HP_ACTIVE_DIG_ICG_APB_EN_V: u32 = 4294967295;
pub const PMU_HP_ACTIVE_DIG_ICG_APB_EN_S: u32 = 0;
pub const PMU_HP_ACTIVE_ICG_MODEM_REG: u32 = 1611333644;
pub const PMU_HP_ACTIVE_DIG_ICG_MODEM_CODE: u32 = 3;
pub const PMU_HP_ACTIVE_DIG_ICG_MODEM_CODE_V: u32 = 3;
pub const PMU_HP_ACTIVE_DIG_ICG_MODEM_CODE_S: u32 = 30;
pub const PMU_HP_ACTIVE_HP_SYS_CNTL_REG: u32 = 1611333648;
pub const PMU_HP_ACTIVE_UART_WAKEUP_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE_UART_WAKEUP_EN_S: u32 = 24;
pub const PMU_HP_ACTIVE_LP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_HP_ACTIVE_LP_PAD_HOLD_ALL_S: u32 = 25;
pub const PMU_HP_ACTIVE_HP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_HP_ACTIVE_HP_PAD_HOLD_ALL_S: u32 = 26;
pub const PMU_HP_ACTIVE_DIG_PAD_SLP_SEL_V: u32 = 1;
pub const PMU_HP_ACTIVE_DIG_PAD_SLP_SEL_S: u32 = 27;
pub const PMU_HP_ACTIVE_DIG_PAUSE_WDT_V: u32 = 1;
pub const PMU_HP_ACTIVE_DIG_PAUSE_WDT_S: u32 = 28;
pub const PMU_HP_ACTIVE_DIG_CPU_STALL_V: u32 = 1;
pub const PMU_HP_ACTIVE_DIG_CPU_STALL_S: u32 = 29;
pub const PMU_HP_ACTIVE_HP_CK_POWER_REG: u32 = 1611333652;
pub const PMU_HP_ACTIVE_I2C_ISO_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE_I2C_ISO_EN_S: u32 = 26;
pub const PMU_HP_ACTIVE_I2C_RETENTION_V: u32 = 1;
pub const PMU_HP_ACTIVE_I2C_RETENTION_S: u32 = 27;
pub const PMU_HP_ACTIVE_XPD_BB_I2C_V: u32 = 1;
pub const PMU_HP_ACTIVE_XPD_BB_I2C_S: u32 = 28;
pub const PMU_HP_ACTIVE_XPD_BBPLL_I2C_V: u32 = 1;
pub const PMU_HP_ACTIVE_XPD_BBPLL_I2C_S: u32 = 29;
pub const PMU_HP_ACTIVE_XPD_BBPLL_V: u32 = 1;
pub const PMU_HP_ACTIVE_XPD_BBPLL_S: u32 = 30;
pub const PMU_HP_ACTIVE_BIAS_REG: u32 = 1611333656;
pub const PMU_HP_ACTIVE_XPD_BIAS_V: u32 = 1;
pub const PMU_HP_ACTIVE_XPD_BIAS_S: u32 = 25;
pub const PMU_HP_ACTIVE_DBG_ATTEN: u32 = 15;
pub const PMU_HP_ACTIVE_DBG_ATTEN_V: u32 = 15;
pub const PMU_HP_ACTIVE_DBG_ATTEN_S: u32 = 26;
pub const PMU_HP_ACTIVE_PD_CUR_V: u32 = 1;
pub const PMU_HP_ACTIVE_PD_CUR_S: u32 = 30;
pub const PMU_HP_ACTIVE_BIAS_SLEEP_V: u32 = 1;
pub const PMU_HP_ACTIVE_BIAS_SLEEP_S: u32 = 31;
pub const PMU_HP_ACTIVE_BACKUP_REG: u32 = 1611333660;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE: u32 = 3;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE_V: u32 = 3;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE_S: u32 = 4;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE: u32 = 3;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE_V: u32 = 3;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE_S: u32 = 6;
pub const PMU_HP_ACTIVE_RETENTION_MODE_V: u32 = 1;
pub const PMU_HP_ACTIVE_RETENTION_MODE_S: u32 = 10;
pub const PMU_HP_SLEEP2ACTIVE_RETENTION_EN_V: u32 = 1;
pub const PMU_HP_SLEEP2ACTIVE_RETENTION_EN_S: u32 = 11;
pub const PMU_HP_MODEM2ACTIVE_RETENTION_EN_V: u32 = 1;
pub const PMU_HP_MODEM2ACTIVE_RETENTION_EN_S: u32 = 12;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_CLK_SEL: u32 = 3;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_CLK_SEL_V: u32 = 3;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_CLK_SEL_S: u32 = 14;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_CLK_SEL: u32 = 3;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_CLK_SEL_V: u32 = 3;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_CLK_SEL_S: u32 = 16;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_MODE: u32 = 7;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_MODE_V: u32 = 7;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_MODE_S: u32 = 20;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_MODE: u32 = 7;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_MODE_V: u32 = 7;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_MODE_S: u32 = 23;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_EN_V: u32 = 1;
pub const PMU_HP_SLEEP2ACTIVE_BACKUP_EN_S: u32 = 29;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_EN_V: u32 = 1;
pub const PMU_HP_MODEM2ACTIVE_BACKUP_EN_S: u32 = 30;
pub const PMU_HP_ACTIVE_BACKUP_CLK_REG: u32 = 1611333664;
pub const PMU_HP_ACTIVE_BACKUP_ICG_FUNC_EN: u32 = 4294967295;
pub const PMU_HP_ACTIVE_BACKUP_ICG_FUNC_EN_V: u32 = 4294967295;
pub const PMU_HP_ACTIVE_BACKUP_ICG_FUNC_EN_S: u32 = 0;
pub const PMU_HP_ACTIVE_SYSCLK_REG: u32 = 1611333668;
pub const PMU_HP_ACTIVE_DIG_SYS_CLK_NO_DIV_V: u32 = 1;
pub const PMU_HP_ACTIVE_DIG_SYS_CLK_NO_DIV_S: u32 = 26;
pub const PMU_HP_ACTIVE_ICG_SYS_CLOCK_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE_ICG_SYS_CLOCK_EN_S: u32 = 27;
pub const PMU_HP_ACTIVE_SYS_CLK_SLP_SEL_V: u32 = 1;
pub const PMU_HP_ACTIVE_SYS_CLK_SLP_SEL_S: u32 = 28;
pub const PMU_HP_ACTIVE_ICG_SLP_SEL_V: u32 = 1;
pub const PMU_HP_ACTIVE_ICG_SLP_SEL_S: u32 = 29;
pub const PMU_HP_ACTIVE_DIG_SYS_CLK_SEL: u32 = 3;
pub const PMU_HP_ACTIVE_DIG_SYS_CLK_SEL_V: u32 = 3;
pub const PMU_HP_ACTIVE_DIG_SYS_CLK_SEL_S: u32 = 30;
pub const PMU_HP_ACTIVE_HP_REGULATOR0_REG: u32 = 1611333672;
pub const PMU_LP_DBIAS_VOL: u32 = 31;
pub const PMU_LP_DBIAS_VOL_V: u32 = 31;
pub const PMU_LP_DBIAS_VOL_S: u32 = 4;
pub const PMU_HP_DBIAS_VOL: u32 = 31;
pub const PMU_HP_DBIAS_VOL_V: u32 = 31;
pub const PMU_HP_DBIAS_VOL_S: u32 = 9;
pub const PMU_DIG_REGULATOR0_DBIAS_SEL_V: u32 = 1;
pub const PMU_DIG_REGULATOR0_DBIAS_SEL_S: u32 = 14;
pub const PMU_DIG_DBIAS_INIT_V: u32 = 1;
pub const PMU_DIG_DBIAS_INIT_S: u32 = 15;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD_V: u32 = 1;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD_S: u32 = 16;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD_V: u32 = 1;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD_S: u32 = 17;
pub const PMU_HP_ACTIVE_HP_REGULATOR_XPD_V: u32 = 1;
pub const PMU_HP_ACTIVE_HP_REGULATOR_XPD_S: u32 = 18;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS: u32 = 15;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS_V: u32 = 15;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS_S: u32 = 19;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS: u32 = 15;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS_V: u32 = 15;
pub const PMU_HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS_S: u32 = 23;
pub const PMU_HP_ACTIVE_HP_REGULATOR_DBIAS: u32 = 31;
pub const PMU_HP_ACTIVE_HP_REGULATOR_DBIAS_V: u32 = 31;
pub const PMU_HP_ACTIVE_HP_REGULATOR_DBIAS_S: u32 = 27;
pub const PMU_HP_ACTIVE_HP_REGULATOR1_REG: u32 = 1611333676;
pub const PMU_HP_ACTIVE_HP_REGULATOR_DRV_B: u32 = 16777215;
pub const PMU_HP_ACTIVE_HP_REGULATOR_DRV_B_V: u32 = 16777215;
pub const PMU_HP_ACTIVE_HP_REGULATOR_DRV_B_S: u32 = 8;
pub const PMU_HP_ACTIVE_XTAL_REG: u32 = 1611333680;
pub const PMU_HP_ACTIVE_XPD_XTAL_V: u32 = 1;
pub const PMU_HP_ACTIVE_XPD_XTAL_S: u32 = 31;
pub const PMU_HP_MODEM_DIG_POWER_REG: u32 = 1611333684;
pub const PMU_HP_MODEM_VDD_SPI_PD_EN_V: u32 = 1;
pub const PMU_HP_MODEM_VDD_SPI_PD_EN_S: u32 = 21;
pub const PMU_HP_MODEM_HP_MEM_DSLP_V: u32 = 1;
pub const PMU_HP_MODEM_HP_MEM_DSLP_S: u32 = 22;
pub const PMU_HP_MODEM_PD_HP_MEM_PD_EN: u32 = 15;
pub const PMU_HP_MODEM_PD_HP_MEM_PD_EN_V: u32 = 15;
pub const PMU_HP_MODEM_PD_HP_MEM_PD_EN_S: u32 = 23;
pub const PMU_HP_MODEM_PD_HP_WIFI_PD_EN_V: u32 = 1;
pub const PMU_HP_MODEM_PD_HP_WIFI_PD_EN_S: u32 = 27;
pub const PMU_HP_MODEM_PD_HP_CPU_PD_EN_V: u32 = 1;
pub const PMU_HP_MODEM_PD_HP_CPU_PD_EN_S: u32 = 29;
pub const PMU_HP_MODEM_PD_HP_AON_PD_EN_V: u32 = 1;
pub const PMU_HP_MODEM_PD_HP_AON_PD_EN_S: u32 = 30;
pub const PMU_HP_MODEM_PD_TOP_PD_EN_V: u32 = 1;
pub const PMU_HP_MODEM_PD_TOP_PD_EN_S: u32 = 31;
pub const PMU_HP_MODEM_ICG_HP_FUNC_REG: u32 = 1611333688;
pub const PMU_HP_MODEM_DIG_ICG_FUNC_EN: u32 = 4294967295;
pub const PMU_HP_MODEM_DIG_ICG_FUNC_EN_V: u32 = 4294967295;
pub const PMU_HP_MODEM_DIG_ICG_FUNC_EN_S: u32 = 0;
pub const PMU_HP_MODEM_ICG_HP_APB_REG: u32 = 1611333692;
pub const PMU_HP_MODEM_DIG_ICG_APB_EN: u32 = 4294967295;
pub const PMU_HP_MODEM_DIG_ICG_APB_EN_V: u32 = 4294967295;
pub const PMU_HP_MODEM_DIG_ICG_APB_EN_S: u32 = 0;
pub const PMU_HP_MODEM_ICG_MODEM_REG: u32 = 1611333696;
pub const PMU_HP_MODEM_DIG_ICG_MODEM_CODE: u32 = 3;
pub const PMU_HP_MODEM_DIG_ICG_MODEM_CODE_V: u32 = 3;
pub const PMU_HP_MODEM_DIG_ICG_MODEM_CODE_S: u32 = 30;
pub const PMU_HP_MODEM_HP_SYS_CNTL_REG: u32 = 1611333700;
pub const PMU_HP_MODEM_UART_WAKEUP_EN_V: u32 = 1;
pub const PMU_HP_MODEM_UART_WAKEUP_EN_S: u32 = 24;
pub const PMU_HP_MODEM_LP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_HP_MODEM_LP_PAD_HOLD_ALL_S: u32 = 25;
pub const PMU_HP_MODEM_HP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_HP_MODEM_HP_PAD_HOLD_ALL_S: u32 = 26;
pub const PMU_HP_MODEM_DIG_PAD_SLP_SEL_V: u32 = 1;
pub const PMU_HP_MODEM_DIG_PAD_SLP_SEL_S: u32 = 27;
pub const PMU_HP_MODEM_DIG_PAUSE_WDT_V: u32 = 1;
pub const PMU_HP_MODEM_DIG_PAUSE_WDT_S: u32 = 28;
pub const PMU_HP_MODEM_DIG_CPU_STALL_V: u32 = 1;
pub const PMU_HP_MODEM_DIG_CPU_STALL_S: u32 = 29;
pub const PMU_HP_MODEM_HP_CK_POWER_REG: u32 = 1611333704;
pub const PMU_HP_MODEM_I2C_ISO_EN_V: u32 = 1;
pub const PMU_HP_MODEM_I2C_ISO_EN_S: u32 = 26;
pub const PMU_HP_MODEM_I2C_RETENTION_V: u32 = 1;
pub const PMU_HP_MODEM_I2C_RETENTION_S: u32 = 27;
pub const PMU_HP_MODEM_XPD_BB_I2C_V: u32 = 1;
pub const PMU_HP_MODEM_XPD_BB_I2C_S: u32 = 28;
pub const PMU_HP_MODEM_XPD_BBPLL_I2C_V: u32 = 1;
pub const PMU_HP_MODEM_XPD_BBPLL_I2C_S: u32 = 29;
pub const PMU_HP_MODEM_XPD_BBPLL_V: u32 = 1;
pub const PMU_HP_MODEM_XPD_BBPLL_S: u32 = 30;
pub const PMU_HP_MODEM_BIAS_REG: u32 = 1611333708;
pub const PMU_HP_MODEM_XPD_BIAS_V: u32 = 1;
pub const PMU_HP_MODEM_XPD_BIAS_S: u32 = 25;
pub const PMU_HP_MODEM_DBG_ATTEN: u32 = 15;
pub const PMU_HP_MODEM_DBG_ATTEN_V: u32 = 15;
pub const PMU_HP_MODEM_DBG_ATTEN_S: u32 = 26;
pub const PMU_HP_MODEM_PD_CUR_V: u32 = 1;
pub const PMU_HP_MODEM_PD_CUR_S: u32 = 30;
pub const PMU_HP_MODEM_BIAS_SLEEP_V: u32 = 1;
pub const PMU_HP_MODEM_BIAS_SLEEP_S: u32 = 31;
pub const PMU_HP_MODEM_BACKUP_REG: u32 = 1611333712;
pub const PMU_HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE: u32 = 3;
pub const PMU_HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE_V: u32 = 3;
pub const PMU_HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE_S: u32 = 4;
pub const PMU_HP_MODEM_RETENTION_MODE_V: u32 = 1;
pub const PMU_HP_MODEM_RETENTION_MODE_S: u32 = 10;
pub const PMU_HP_SLEEP2MODEM_RETENTION_EN_V: u32 = 1;
pub const PMU_HP_SLEEP2MODEM_RETENTION_EN_S: u32 = 11;
pub const PMU_HP_SLEEP2MODEM_BACKUP_CLK_SEL: u32 = 3;
pub const PMU_HP_SLEEP2MODEM_BACKUP_CLK_SEL_V: u32 = 3;
pub const PMU_HP_SLEEP2MODEM_BACKUP_CLK_SEL_S: u32 = 14;
pub const PMU_HP_SLEEP2MODEM_BACKUP_MODE: u32 = 7;
pub const PMU_HP_SLEEP2MODEM_BACKUP_MODE_V: u32 = 7;
pub const PMU_HP_SLEEP2MODEM_BACKUP_MODE_S: u32 = 20;
pub const PMU_HP_SLEEP2MODEM_BACKUP_EN_V: u32 = 1;
pub const PMU_HP_SLEEP2MODEM_BACKUP_EN_S: u32 = 29;
pub const PMU_HP_MODEM_BACKUP_CLK_REG: u32 = 1611333716;
pub const PMU_HP_MODEM_BACKUP_ICG_FUNC_EN: u32 = 4294967295;
pub const PMU_HP_MODEM_BACKUP_ICG_FUNC_EN_V: u32 = 4294967295;
pub const PMU_HP_MODEM_BACKUP_ICG_FUNC_EN_S: u32 = 0;
pub const PMU_HP_MODEM_SYSCLK_REG: u32 = 1611333720;
pub const PMU_HP_MODEM_DIG_SYS_CLK_NO_DIV_V: u32 = 1;
pub const PMU_HP_MODEM_DIG_SYS_CLK_NO_DIV_S: u32 = 26;
pub const PMU_HP_MODEM_ICG_SYS_CLOCK_EN_V: u32 = 1;
pub const PMU_HP_MODEM_ICG_SYS_CLOCK_EN_S: u32 = 27;
pub const PMU_HP_MODEM_SYS_CLK_SLP_SEL_V: u32 = 1;
pub const PMU_HP_MODEM_SYS_CLK_SLP_SEL_S: u32 = 28;
pub const PMU_HP_MODEM_ICG_SLP_SEL_V: u32 = 1;
pub const PMU_HP_MODEM_ICG_SLP_SEL_S: u32 = 29;
pub const PMU_HP_MODEM_DIG_SYS_CLK_SEL: u32 = 3;
pub const PMU_HP_MODEM_DIG_SYS_CLK_SEL_V: u32 = 3;
pub const PMU_HP_MODEM_DIG_SYS_CLK_SEL_S: u32 = 30;
pub const PMU_HP_MODEM_HP_REGULATOR0_REG: u32 = 1611333724;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_MEM_XPD_V: u32 = 1;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_MEM_XPD_S: u32 = 16;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD_V: u32 = 1;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD_S: u32 = 17;
pub const PMU_HP_MODEM_HP_REGULATOR_XPD_V: u32 = 1;
pub const PMU_HP_MODEM_HP_REGULATOR_XPD_S: u32 = 18;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS: u32 = 15;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS_V: u32 = 15;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS_S: u32 = 19;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS: u32 = 15;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS_V: u32 = 15;
pub const PMU_HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS_S: u32 = 23;
pub const PMU_HP_MODEM_HP_REGULATOR_DBIAS: u32 = 31;
pub const PMU_HP_MODEM_HP_REGULATOR_DBIAS_V: u32 = 31;
pub const PMU_HP_MODEM_HP_REGULATOR_DBIAS_S: u32 = 27;
pub const PMU_HP_MODEM_HP_REGULATOR1_REG: u32 = 1611333728;
pub const PMU_HP_MODEM_HP_REGULATOR_DRV_B: u32 = 16777215;
pub const PMU_HP_MODEM_HP_REGULATOR_DRV_B_V: u32 = 16777215;
pub const PMU_HP_MODEM_HP_REGULATOR_DRV_B_S: u32 = 8;
pub const PMU_HP_MODEM_XTAL_REG: u32 = 1611333732;
pub const PMU_HP_MODEM_XPD_XTAL_V: u32 = 1;
pub const PMU_HP_MODEM_XPD_XTAL_S: u32 = 31;
pub const PMU_HP_SLEEP_DIG_POWER_REG: u32 = 1611333736;
pub const PMU_HP_SLEEP_VDD_SPI_PD_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_VDD_SPI_PD_EN_S: u32 = 21;
pub const PMU_HP_SLEEP_HP_MEM_DSLP_V: u32 = 1;
pub const PMU_HP_SLEEP_HP_MEM_DSLP_S: u32 = 22;
pub const PMU_HP_SLEEP_PD_HP_MEM_PD_EN: u32 = 15;
pub const PMU_HP_SLEEP_PD_HP_MEM_PD_EN_V: u32 = 15;
pub const PMU_HP_SLEEP_PD_HP_MEM_PD_EN_S: u32 = 23;
pub const PMU_HP_SLEEP_PD_HP_WIFI_PD_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_PD_HP_WIFI_PD_EN_S: u32 = 27;
pub const PMU_HP_SLEEP_PD_HP_CPU_PD_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_PD_HP_CPU_PD_EN_S: u32 = 29;
pub const PMU_HP_SLEEP_PD_HP_AON_PD_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_PD_HP_AON_PD_EN_S: u32 = 30;
pub const PMU_HP_SLEEP_PD_TOP_PD_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_PD_TOP_PD_EN_S: u32 = 31;
pub const PMU_HP_SLEEP_ICG_HP_FUNC_REG: u32 = 1611333740;
pub const PMU_HP_SLEEP_DIG_ICG_FUNC_EN: u32 = 4294967295;
pub const PMU_HP_SLEEP_DIG_ICG_FUNC_EN_V: u32 = 4294967295;
pub const PMU_HP_SLEEP_DIG_ICG_FUNC_EN_S: u32 = 0;
pub const PMU_HP_SLEEP_ICG_HP_APB_REG: u32 = 1611333744;
pub const PMU_HP_SLEEP_DIG_ICG_APB_EN: u32 = 4294967295;
pub const PMU_HP_SLEEP_DIG_ICG_APB_EN_V: u32 = 4294967295;
pub const PMU_HP_SLEEP_DIG_ICG_APB_EN_S: u32 = 0;
pub const PMU_HP_SLEEP_ICG_MODEM_REG: u32 = 1611333748;
pub const PMU_HP_SLEEP_DIG_ICG_MODEM_CODE: u32 = 3;
pub const PMU_HP_SLEEP_DIG_ICG_MODEM_CODE_V: u32 = 3;
pub const PMU_HP_SLEEP_DIG_ICG_MODEM_CODE_S: u32 = 30;
pub const PMU_HP_SLEEP_HP_SYS_CNTL_REG: u32 = 1611333752;
pub const PMU_HP_SLEEP_UART_WAKEUP_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_UART_WAKEUP_EN_S: u32 = 24;
pub const PMU_HP_SLEEP_LP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_HP_SLEEP_LP_PAD_HOLD_ALL_S: u32 = 25;
pub const PMU_HP_SLEEP_HP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_HP_SLEEP_HP_PAD_HOLD_ALL_S: u32 = 26;
pub const PMU_HP_SLEEP_DIG_PAD_SLP_SEL_V: u32 = 1;
pub const PMU_HP_SLEEP_DIG_PAD_SLP_SEL_S: u32 = 27;
pub const PMU_HP_SLEEP_DIG_PAUSE_WDT_V: u32 = 1;
pub const PMU_HP_SLEEP_DIG_PAUSE_WDT_S: u32 = 28;
pub const PMU_HP_SLEEP_DIG_CPU_STALL_V: u32 = 1;
pub const PMU_HP_SLEEP_DIG_CPU_STALL_S: u32 = 29;
pub const PMU_HP_SLEEP_HP_CK_POWER_REG: u32 = 1611333756;
pub const PMU_HP_SLEEP_I2C_ISO_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_I2C_ISO_EN_S: u32 = 26;
pub const PMU_HP_SLEEP_I2C_RETENTION_V: u32 = 1;
pub const PMU_HP_SLEEP_I2C_RETENTION_S: u32 = 27;
pub const PMU_HP_SLEEP_XPD_BB_I2C_V: u32 = 1;
pub const PMU_HP_SLEEP_XPD_BB_I2C_S: u32 = 28;
pub const PMU_HP_SLEEP_XPD_BBPLL_I2C_V: u32 = 1;
pub const PMU_HP_SLEEP_XPD_BBPLL_I2C_S: u32 = 29;
pub const PMU_HP_SLEEP_XPD_BBPLL_V: u32 = 1;
pub const PMU_HP_SLEEP_XPD_BBPLL_S: u32 = 30;
pub const PMU_HP_SLEEP_BIAS_REG: u32 = 1611333760;
pub const PMU_HP_SLEEP_XPD_BIAS_V: u32 = 1;
pub const PMU_HP_SLEEP_XPD_BIAS_S: u32 = 25;
pub const PMU_HP_SLEEP_DBG_ATTEN: u32 = 15;
pub const PMU_HP_SLEEP_DBG_ATTEN_V: u32 = 15;
pub const PMU_HP_SLEEP_DBG_ATTEN_S: u32 = 26;
pub const PMU_HP_SLEEP_PD_CUR_V: u32 = 1;
pub const PMU_HP_SLEEP_PD_CUR_S: u32 = 30;
pub const PMU_HP_SLEEP_BIAS_SLEEP_V: u32 = 1;
pub const PMU_HP_SLEEP_BIAS_SLEEP_S: u32 = 31;
pub const PMU_HP_SLEEP_BACKUP_REG: u32 = 1611333764;
pub const PMU_HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE: u32 = 3;
pub const PMU_HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE_V: u32 = 3;
pub const PMU_HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE_S: u32 = 6;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE: u32 = 3;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE_V: u32 = 3;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE_S: u32 = 8;
pub const PMU_HP_SLEEP_RETENTION_MODE_V: u32 = 1;
pub const PMU_HP_SLEEP_RETENTION_MODE_S: u32 = 10;
pub const PMU_HP_MODEM2SLEEP_RETENTION_EN_V: u32 = 1;
pub const PMU_HP_MODEM2SLEEP_RETENTION_EN_S: u32 = 12;
pub const PMU_HP_ACTIVE2SLEEP_RETENTION_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE2SLEEP_RETENTION_EN_S: u32 = 13;
pub const PMU_HP_MODEM2SLEEP_BACKUP_CLK_SEL: u32 = 3;
pub const PMU_HP_MODEM2SLEEP_BACKUP_CLK_SEL_V: u32 = 3;
pub const PMU_HP_MODEM2SLEEP_BACKUP_CLK_SEL_S: u32 = 16;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_CLK_SEL: u32 = 3;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_CLK_SEL_V: u32 = 3;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_CLK_SEL_S: u32 = 18;
pub const PMU_HP_MODEM2SLEEP_BACKUP_MODE: u32 = 7;
pub const PMU_HP_MODEM2SLEEP_BACKUP_MODE_V: u32 = 7;
pub const PMU_HP_MODEM2SLEEP_BACKUP_MODE_S: u32 = 23;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_MODE: u32 = 7;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_MODE_V: u32 = 7;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_MODE_S: u32 = 26;
pub const PMU_HP_MODEM2SLEEP_BACKUP_EN_V: u32 = 1;
pub const PMU_HP_MODEM2SLEEP_BACKUP_EN_S: u32 = 30;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_EN_V: u32 = 1;
pub const PMU_HP_ACTIVE2SLEEP_BACKUP_EN_S: u32 = 31;
pub const PMU_HP_SLEEP_BACKUP_CLK_REG: u32 = 1611333768;
pub const PMU_HP_SLEEP_BACKUP_ICG_FUNC_EN: u32 = 4294967295;
pub const PMU_HP_SLEEP_BACKUP_ICG_FUNC_EN_V: u32 = 4294967295;
pub const PMU_HP_SLEEP_BACKUP_ICG_FUNC_EN_S: u32 = 0;
pub const PMU_HP_SLEEP_SYSCLK_REG: u32 = 1611333772;
pub const PMU_HP_SLEEP_DIG_SYS_CLK_NO_DIV_V: u32 = 1;
pub const PMU_HP_SLEEP_DIG_SYS_CLK_NO_DIV_S: u32 = 26;
pub const PMU_HP_SLEEP_ICG_SYS_CLOCK_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_ICG_SYS_CLOCK_EN_S: u32 = 27;
pub const PMU_HP_SLEEP_SYS_CLK_SLP_SEL_V: u32 = 1;
pub const PMU_HP_SLEEP_SYS_CLK_SLP_SEL_S: u32 = 28;
pub const PMU_HP_SLEEP_ICG_SLP_SEL_V: u32 = 1;
pub const PMU_HP_SLEEP_ICG_SLP_SEL_S: u32 = 29;
pub const PMU_HP_SLEEP_DIG_SYS_CLK_SEL: u32 = 3;
pub const PMU_HP_SLEEP_DIG_SYS_CLK_SEL_V: u32 = 3;
pub const PMU_HP_SLEEP_DIG_SYS_CLK_SEL_S: u32 = 30;
pub const PMU_HP_SLEEP_HP_REGULATOR0_REG: u32 = 1611333776;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD_V: u32 = 1;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD_S: u32 = 16;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD_V: u32 = 1;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD_S: u32 = 17;
pub const PMU_HP_SLEEP_HP_REGULATOR_XPD_V: u32 = 1;
pub const PMU_HP_SLEEP_HP_REGULATOR_XPD_S: u32 = 18;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS: u32 = 15;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS_V: u32 = 15;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS_S: u32 = 19;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS: u32 = 15;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS_V: u32 = 15;
pub const PMU_HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS_S: u32 = 23;
pub const PMU_HP_SLEEP_HP_REGULATOR_DBIAS: u32 = 31;
pub const PMU_HP_SLEEP_HP_REGULATOR_DBIAS_V: u32 = 31;
pub const PMU_HP_SLEEP_HP_REGULATOR_DBIAS_S: u32 = 27;
pub const PMU_HP_SLEEP_HP_REGULATOR1_REG: u32 = 1611333780;
pub const PMU_HP_SLEEP_HP_REGULATOR_DRV_B: u32 = 16777215;
pub const PMU_HP_SLEEP_HP_REGULATOR_DRV_B_V: u32 = 16777215;
pub const PMU_HP_SLEEP_HP_REGULATOR_DRV_B_S: u32 = 8;
pub const PMU_HP_SLEEP_XTAL_REG: u32 = 1611333784;
pub const PMU_HP_SLEEP_XPD_XTAL_V: u32 = 1;
pub const PMU_HP_SLEEP_XPD_XTAL_S: u32 = 31;
pub const PMU_HP_SLEEP_LP_REGULATOR0_REG: u32 = 1611333788;
pub const PMU_HP_SLEEP_LP_REGULATOR_SLP_XPD_V: u32 = 1;
pub const PMU_HP_SLEEP_LP_REGULATOR_SLP_XPD_S: u32 = 21;
pub const PMU_HP_SLEEP_LP_REGULATOR_XPD_V: u32 = 1;
pub const PMU_HP_SLEEP_LP_REGULATOR_XPD_S: u32 = 22;
pub const PMU_HP_SLEEP_LP_REGULATOR_SLP_DBIAS: u32 = 15;
pub const PMU_HP_SLEEP_LP_REGULATOR_SLP_DBIAS_V: u32 = 15;
pub const PMU_HP_SLEEP_LP_REGULATOR_SLP_DBIAS_S: u32 = 23;
pub const PMU_HP_SLEEP_LP_REGULATOR_DBIAS: u32 = 31;
pub const PMU_HP_SLEEP_LP_REGULATOR_DBIAS_V: u32 = 31;
pub const PMU_HP_SLEEP_LP_REGULATOR_DBIAS_S: u32 = 27;
pub const PMU_HP_SLEEP_LP_REGULATOR1_REG: u32 = 1611333792;
pub const PMU_HP_SLEEP_LP_REGULATOR_DRV_B: u32 = 15;
pub const PMU_HP_SLEEP_LP_REGULATOR_DRV_B_V: u32 = 15;
pub const PMU_HP_SLEEP_LP_REGULATOR_DRV_B_S: u32 = 28;
pub const PMU_HP_SLEEP_LP_DCDC_RESERVE_REG: u32 = 1611333796;
pub const PMU_HP_SLEEP_LP_DCDC_RESERVE: u32 = 4294967295;
pub const PMU_HP_SLEEP_LP_DCDC_RESERVE_V: u32 = 4294967295;
pub const PMU_HP_SLEEP_LP_DCDC_RESERVE_S: u32 = 0;
pub const PMU_HP_SLEEP_LP_DIG_POWER_REG: u32 = 1611333800;
pub const PMU_HP_SLEEP_LP_MEM_DSLP_V: u32 = 1;
pub const PMU_HP_SLEEP_LP_MEM_DSLP_S: u32 = 30;
pub const PMU_HP_SLEEP_PD_LP_PERI_PD_EN_V: u32 = 1;
pub const PMU_HP_SLEEP_PD_LP_PERI_PD_EN_S: u32 = 31;
pub const PMU_HP_SLEEP_LP_CK_POWER_REG: u32 = 1611333804;
pub const PMU_HP_SLEEP_XPD_XTAL32K_V: u32 = 1;
pub const PMU_HP_SLEEP_XPD_XTAL32K_S: u32 = 28;
pub const PMU_HP_SLEEP_XPD_RC32K_V: u32 = 1;
pub const PMU_HP_SLEEP_XPD_RC32K_S: u32 = 29;
pub const PMU_HP_SLEEP_XPD_FOSC_CLK_V: u32 = 1;
pub const PMU_HP_SLEEP_XPD_FOSC_CLK_S: u32 = 30;
pub const PMU_HP_SLEEP_PD_OSC_CLK_V: u32 = 1;
pub const PMU_HP_SLEEP_PD_OSC_CLK_S: u32 = 31;
pub const PMU_LP_SLEEP_LP_BIAS_RESERVE_REG: u32 = 1611333808;
pub const PMU_LP_SLEEP_LP_BIAS_RESERVE: u32 = 4294967295;
pub const PMU_LP_SLEEP_LP_BIAS_RESERVE_V: u32 = 4294967295;
pub const PMU_LP_SLEEP_LP_BIAS_RESERVE_S: u32 = 0;
pub const PMU_LP_SLEEP_LP_REGULATOR0_REG: u32 = 1611333812;
pub const PMU_LP_SLEEP_LP_REGULATOR_SLP_XPD_V: u32 = 1;
pub const PMU_LP_SLEEP_LP_REGULATOR_SLP_XPD_S: u32 = 21;
pub const PMU_LP_SLEEP_LP_REGULATOR_XPD_V: u32 = 1;
pub const PMU_LP_SLEEP_LP_REGULATOR_XPD_S: u32 = 22;
pub const PMU_LP_SLEEP_LP_REGULATOR_SLP_DBIAS: u32 = 15;
pub const PMU_LP_SLEEP_LP_REGULATOR_SLP_DBIAS_V: u32 = 15;
pub const PMU_LP_SLEEP_LP_REGULATOR_SLP_DBIAS_S: u32 = 23;
pub const PMU_LP_SLEEP_LP_REGULATOR_DBIAS: u32 = 31;
pub const PMU_LP_SLEEP_LP_REGULATOR_DBIAS_V: u32 = 31;
pub const PMU_LP_SLEEP_LP_REGULATOR_DBIAS_S: u32 = 27;
pub const PMU_LP_SLEEP_LP_REGULATOR1_REG: u32 = 1611333816;
pub const PMU_LP_SLEEP_LP_REGULATOR_DRV_B: u32 = 15;
pub const PMU_LP_SLEEP_LP_REGULATOR_DRV_B_V: u32 = 15;
pub const PMU_LP_SLEEP_LP_REGULATOR_DRV_B_S: u32 = 28;
pub const PMU_LP_SLEEP_XTAL_REG: u32 = 1611333820;
pub const PMU_LP_SLEEP_XPD_XTAL_V: u32 = 1;
pub const PMU_LP_SLEEP_XPD_XTAL_S: u32 = 31;
pub const PMU_LP_SLEEP_LP_DIG_POWER_REG: u32 = 1611333824;
pub const PMU_LP_SLEEP_LP_MEM_DSLP_V: u32 = 1;
pub const PMU_LP_SLEEP_LP_MEM_DSLP_S: u32 = 30;
pub const PMU_LP_SLEEP_PD_LP_PERI_PD_EN_V: u32 = 1;
pub const PMU_LP_SLEEP_PD_LP_PERI_PD_EN_S: u32 = 31;
pub const PMU_LP_SLEEP_LP_CK_POWER_REG: u32 = 1611333828;
pub const PMU_LP_SLEEP_XPD_XTAL32K_V: u32 = 1;
pub const PMU_LP_SLEEP_XPD_XTAL32K_S: u32 = 28;
pub const PMU_LP_SLEEP_XPD_RC32K_V: u32 = 1;
pub const PMU_LP_SLEEP_XPD_RC32K_S: u32 = 29;
pub const PMU_LP_SLEEP_XPD_FOSC_CLK_V: u32 = 1;
pub const PMU_LP_SLEEP_XPD_FOSC_CLK_S: u32 = 30;
pub const PMU_LP_SLEEP_PD_OSC_CLK_V: u32 = 1;
pub const PMU_LP_SLEEP_PD_OSC_CLK_S: u32 = 31;
pub const PMU_LP_SLEEP_BIAS_REG: u32 = 1611333832;
pub const PMU_LP_SLEEP_XPD_BIAS_V: u32 = 1;
pub const PMU_LP_SLEEP_XPD_BIAS_S: u32 = 25;
pub const PMU_LP_SLEEP_DBG_ATTEN: u32 = 15;
pub const PMU_LP_SLEEP_DBG_ATTEN_V: u32 = 15;
pub const PMU_LP_SLEEP_DBG_ATTEN_S: u32 = 26;
pub const PMU_LP_SLEEP_PD_CUR_V: u32 = 1;
pub const PMU_LP_SLEEP_PD_CUR_S: u32 = 30;
pub const PMU_LP_SLEEP_BIAS_SLEEP_V: u32 = 1;
pub const PMU_LP_SLEEP_BIAS_SLEEP_S: u32 = 31;
pub const PMU_IMM_HP_CK_POWER_REG: u32 = 1611333836;
pub const PMU_TIE_LOW_GLOBAL_BBPLL_ICG_V: u32 = 1;
pub const PMU_TIE_LOW_GLOBAL_BBPLL_ICG_S: u32 = 0;
pub const PMU_TIE_LOW_GLOBAL_XTAL_ICG_V: u32 = 1;
pub const PMU_TIE_LOW_GLOBAL_XTAL_ICG_S: u32 = 1;
pub const PMU_TIE_LOW_I2C_RETENTION_V: u32 = 1;
pub const PMU_TIE_LOW_I2C_RETENTION_S: u32 = 2;
pub const PMU_TIE_LOW_XPD_BB_I2C_V: u32 = 1;
pub const PMU_TIE_LOW_XPD_BB_I2C_S: u32 = 3;
pub const PMU_TIE_LOW_XPD_BBPLL_I2C_V: u32 = 1;
pub const PMU_TIE_LOW_XPD_BBPLL_I2C_S: u32 = 4;
pub const PMU_TIE_LOW_XPD_BBPLL_V: u32 = 1;
pub const PMU_TIE_LOW_XPD_BBPLL_S: u32 = 5;
pub const PMU_TIE_LOW_XPD_XTAL_V: u32 = 1;
pub const PMU_TIE_LOW_XPD_XTAL_S: u32 = 6;
pub const PMU_TIE_HIGH_GLOBAL_BBPLL_ICG_V: u32 = 1;
pub const PMU_TIE_HIGH_GLOBAL_BBPLL_ICG_S: u32 = 25;
pub const PMU_TIE_HIGH_GLOBAL_XTAL_ICG_V: u32 = 1;
pub const PMU_TIE_HIGH_GLOBAL_XTAL_ICG_S: u32 = 26;
pub const PMU_TIE_HIGH_I2C_RETENTION_V: u32 = 1;
pub const PMU_TIE_HIGH_I2C_RETENTION_S: u32 = 27;
pub const PMU_TIE_HIGH_XPD_BB_I2C_V: u32 = 1;
pub const PMU_TIE_HIGH_XPD_BB_I2C_S: u32 = 28;
pub const PMU_TIE_HIGH_XPD_BBPLL_I2C_V: u32 = 1;
pub const PMU_TIE_HIGH_XPD_BBPLL_I2C_S: u32 = 29;
pub const PMU_TIE_HIGH_XPD_BBPLL_V: u32 = 1;
pub const PMU_TIE_HIGH_XPD_BBPLL_S: u32 = 30;
pub const PMU_TIE_HIGH_XPD_XTAL_V: u32 = 1;
pub const PMU_TIE_HIGH_XPD_XTAL_S: u32 = 31;
pub const PMU_IMM_SLEEP_SYSCLK_REG: u32 = 1611333840;
pub const PMU_UPDATE_DIG_ICG_SWITCH_V: u32 = 1;
pub const PMU_UPDATE_DIG_ICG_SWITCH_S: u32 = 28;
pub const PMU_TIE_LOW_ICG_SLP_SEL_V: u32 = 1;
pub const PMU_TIE_LOW_ICG_SLP_SEL_S: u32 = 29;
pub const PMU_TIE_HIGH_ICG_SLP_SEL_V: u32 = 1;
pub const PMU_TIE_HIGH_ICG_SLP_SEL_S: u32 = 30;
pub const PMU_UPDATE_DIG_SYS_CLK_SEL_V: u32 = 1;
pub const PMU_UPDATE_DIG_SYS_CLK_SEL_S: u32 = 31;
pub const PMU_IMM_HP_FUNC_ICG_REG: u32 = 1611333844;
pub const PMU_UPDATE_DIG_ICG_FUNC_EN_V: u32 = 1;
pub const PMU_UPDATE_DIG_ICG_FUNC_EN_S: u32 = 31;
pub const PMU_IMM_HP_APB_ICG_REG: u32 = 1611333848;
pub const PMU_UPDATE_DIG_ICG_APB_EN_V: u32 = 1;
pub const PMU_UPDATE_DIG_ICG_APB_EN_S: u32 = 31;
pub const PMU_IMM_MODEM_ICG_REG: u32 = 1611333852;
pub const PMU_UPDATE_DIG_ICG_MODEM_EN_V: u32 = 1;
pub const PMU_UPDATE_DIG_ICG_MODEM_EN_S: u32 = 31;
pub const PMU_IMM_LP_ICG_REG: u32 = 1611333856;
pub const PMU_TIE_LOW_LP_ROOTCLK_SEL_V: u32 = 1;
pub const PMU_TIE_LOW_LP_ROOTCLK_SEL_S: u32 = 30;
pub const PMU_TIE_HIGH_LP_ROOTCLK_SEL_V: u32 = 1;
pub const PMU_TIE_HIGH_LP_ROOTCLK_SEL_S: u32 = 31;
pub const PMU_IMM_PAD_HOLD_ALL_REG: u32 = 1611333860;
pub const PMU_TIE_HIGH_LP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_TIE_HIGH_LP_PAD_HOLD_ALL_S: u32 = 28;
pub const PMU_TIE_LOW_LP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_TIE_LOW_LP_PAD_HOLD_ALL_S: u32 = 29;
pub const PMU_TIE_HIGH_HP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_TIE_HIGH_HP_PAD_HOLD_ALL_S: u32 = 30;
pub const PMU_TIE_LOW_HP_PAD_HOLD_ALL_V: u32 = 1;
pub const PMU_TIE_LOW_HP_PAD_HOLD_ALL_S: u32 = 31;
pub const PMU_IMM_I2C_ISO_REG: u32 = 1611333864;
pub const PMU_TIE_HIGH_I2C_ISO_EN_V: u32 = 1;
pub const PMU_TIE_HIGH_I2C_ISO_EN_S: u32 = 30;
pub const PMU_TIE_LOW_I2C_ISO_EN_V: u32 = 1;
pub const PMU_TIE_LOW_I2C_ISO_EN_S: u32 = 31;
pub const PMU_POWER_WAIT_TIMER0_REG: u32 = 1611333868;
pub const PMU_DG_HP_POWERDOWN_TIMER: u32 = 511;
pub const PMU_DG_HP_POWERDOWN_TIMER_V: u32 = 511;
pub const PMU_DG_HP_POWERDOWN_TIMER_S: u32 = 5;
pub const PMU_DG_HP_POWERUP_TIMER: u32 = 511;
pub const PMU_DG_HP_POWERUP_TIMER_V: u32 = 511;
pub const PMU_DG_HP_POWERUP_TIMER_S: u32 = 14;
pub const PMU_DG_HP_WAIT_TIMER: u32 = 511;
pub const PMU_DG_HP_WAIT_TIMER_V: u32 = 511;
pub const PMU_DG_HP_WAIT_TIMER_S: u32 = 23;
pub const PMU_POWER_WAIT_TIMER1_REG: u32 = 1611333872;
pub const PMU_DG_LP_POWERDOWN_TIMER: u32 = 127;
pub const PMU_DG_LP_POWERDOWN_TIMER_V: u32 = 127;
pub const PMU_DG_LP_POWERDOWN_TIMER_S: u32 = 9;
pub const PMU_DG_LP_POWERUP_TIMER: u32 = 127;
pub const PMU_DG_LP_POWERUP_TIMER_V: u32 = 127;
pub const PMU_DG_LP_POWERUP_TIMER_S: u32 = 16;
pub const PMU_DG_LP_WAIT_TIMER: u32 = 511;
pub const PMU_DG_LP_WAIT_TIMER_V: u32 = 511;
pub const PMU_DG_LP_WAIT_TIMER_S: u32 = 23;
pub const PMU_POWER_PD_TOP_CNTL_REG: u32 = 1611333876;
pub const PMU_FORCE_TOP_RESET_V: u32 = 1;
pub const PMU_FORCE_TOP_RESET_S: u32 = 0;
pub const PMU_FORCE_TOP_ISO_V: u32 = 1;
pub const PMU_FORCE_TOP_ISO_S: u32 = 1;
pub const PMU_FORCE_TOP_PU_V: u32 = 1;
pub const PMU_FORCE_TOP_PU_S: u32 = 2;
pub const PMU_FORCE_TOP_NO_RESET_V: u32 = 1;
pub const PMU_FORCE_TOP_NO_RESET_S: u32 = 3;
pub const PMU_FORCE_TOP_NO_ISO_V: u32 = 1;
pub const PMU_FORCE_TOP_NO_ISO_S: u32 = 4;
pub const PMU_FORCE_TOP_PD_V: u32 = 1;
pub const PMU_FORCE_TOP_PD_S: u32 = 5;
pub const PMU_PD_TOP_MASK: u32 = 31;
pub const PMU_PD_TOP_MASK_V: u32 = 31;
pub const PMU_PD_TOP_MASK_S: u32 = 6;
pub const PMU_PD_TOP_PD_MASK: u32 = 31;
pub const PMU_PD_TOP_PD_MASK_V: u32 = 31;
pub const PMU_PD_TOP_PD_MASK_S: u32 = 27;
pub const PMU_POWER_PD_HPAON_CNTL_REG: u32 = 1611333880;
pub const PMU_FORCE_HP_AON_RESET_V: u32 = 1;
pub const PMU_FORCE_HP_AON_RESET_S: u32 = 0;
pub const PMU_FORCE_HP_AON_ISO_V: u32 = 1;
pub const PMU_FORCE_HP_AON_ISO_S: u32 = 1;
pub const PMU_FORCE_HP_AON_PU_V: u32 = 1;
pub const PMU_FORCE_HP_AON_PU_S: u32 = 2;
pub const PMU_FORCE_HP_AON_NO_RESET_V: u32 = 1;
pub const PMU_FORCE_HP_AON_NO_RESET_S: u32 = 3;
pub const PMU_FORCE_HP_AON_NO_ISO_V: u32 = 1;
pub const PMU_FORCE_HP_AON_NO_ISO_S: u32 = 4;
pub const PMU_FORCE_HP_AON_PD_V: u32 = 1;
pub const PMU_FORCE_HP_AON_PD_S: u32 = 5;
pub const PMU_PD_HP_AON_MASK: u32 = 31;
pub const PMU_PD_HP_AON_MASK_V: u32 = 31;
pub const PMU_PD_HP_AON_MASK_S: u32 = 6;
pub const PMU_PD_HP_AON_PD_MASK: u32 = 31;
pub const PMU_PD_HP_AON_PD_MASK_V: u32 = 31;
pub const PMU_PD_HP_AON_PD_MASK_S: u32 = 27;
pub const PMU_POWER_PD_HPCPU_CNTL_REG: u32 = 1611333884;
pub const PMU_FORCE_HP_CPU_RESET_V: u32 = 1;
pub const PMU_FORCE_HP_CPU_RESET_S: u32 = 0;
pub const PMU_FORCE_HP_CPU_ISO_V: u32 = 1;
pub const PMU_FORCE_HP_CPU_ISO_S: u32 = 1;
pub const PMU_FORCE_HP_CPU_PU_V: u32 = 1;
pub const PMU_FORCE_HP_CPU_PU_S: u32 = 2;
pub const PMU_FORCE_HP_CPU_NO_RESET_V: u32 = 1;
pub const PMU_FORCE_HP_CPU_NO_RESET_S: u32 = 3;
pub const PMU_FORCE_HP_CPU_NO_ISO_V: u32 = 1;
pub const PMU_FORCE_HP_CPU_NO_ISO_S: u32 = 4;
pub const PMU_FORCE_HP_CPU_PD_V: u32 = 1;
pub const PMU_FORCE_HP_CPU_PD_S: u32 = 5;
pub const PMU_PD_HP_CPU_MASK: u32 = 31;
pub const PMU_PD_HP_CPU_MASK_V: u32 = 31;
pub const PMU_PD_HP_CPU_MASK_S: u32 = 6;
pub const PMU_PD_HP_CPU_PD_MASK: u32 = 31;
pub const PMU_PD_HP_CPU_PD_MASK_V: u32 = 31;
pub const PMU_PD_HP_CPU_PD_MASK_S: u32 = 27;
pub const PMU_POWER_PD_HPPERI_RESERVE_REG: u32 = 1611333888;
pub const PMU_HP_PERI_RESERVE: u32 = 4294967295;
pub const PMU_HP_PERI_RESERVE_V: u32 = 4294967295;
pub const PMU_HP_PERI_RESERVE_S: u32 = 0;
pub const PMU_POWER_PD_HPWIFI_CNTL_REG: u32 = 1611333892;
pub const PMU_FORCE_HP_WIFI_RESET_V: u32 = 1;
pub const PMU_FORCE_HP_WIFI_RESET_S: u32 = 0;
pub const PMU_FORCE_HP_WIFI_ISO_V: u32 = 1;
pub const PMU_FORCE_HP_WIFI_ISO_S: u32 = 1;
pub const PMU_FORCE_HP_WIFI_PU_V: u32 = 1;
pub const PMU_FORCE_HP_WIFI_PU_S: u32 = 2;
pub const PMU_FORCE_HP_WIFI_NO_RESET_V: u32 = 1;
pub const PMU_FORCE_HP_WIFI_NO_RESET_S: u32 = 3;
pub const PMU_FORCE_HP_WIFI_NO_ISO_V: u32 = 1;
pub const PMU_FORCE_HP_WIFI_NO_ISO_S: u32 = 4;
pub const PMU_FORCE_HP_WIFI_PD_V: u32 = 1;
pub const PMU_FORCE_HP_WIFI_PD_S: u32 = 5;
pub const PMU_PD_HP_WIFI_MASK: u32 = 31;
pub const PMU_PD_HP_WIFI_MASK_V: u32 = 31;
pub const PMU_PD_HP_WIFI_MASK_S: u32 = 6;
pub const PMU_PD_HP_WIFI_PD_MASK: u32 = 31;
pub const PMU_PD_HP_WIFI_PD_MASK_V: u32 = 31;
pub const PMU_PD_HP_WIFI_PD_MASK_S: u32 = 27;
pub const PMU_POWER_PD_LPPERI_CNTL_REG: u32 = 1611333896;
pub const PMU_FORCE_LP_PERI_RESET_V: u32 = 1;
pub const PMU_FORCE_LP_PERI_RESET_S: u32 = 0;
pub const PMU_FORCE_LP_PERI_ISO_V: u32 = 1;
pub const PMU_FORCE_LP_PERI_ISO_S: u32 = 1;
pub const PMU_FORCE_LP_PERI_PU_V: u32 = 1;
pub const PMU_FORCE_LP_PERI_PU_S: u32 = 2;
pub const PMU_FORCE_LP_PERI_NO_RESET_V: u32 = 1;
pub const PMU_FORCE_LP_PERI_NO_RESET_S: u32 = 3;
pub const PMU_FORCE_LP_PERI_NO_ISO_V: u32 = 1;
pub const PMU_FORCE_LP_PERI_NO_ISO_S: u32 = 4;
pub const PMU_FORCE_LP_PERI_PD_V: u32 = 1;
pub const PMU_FORCE_LP_PERI_PD_S: u32 = 5;
pub const PMU_POWER_PD_MEM_CNTL_REG: u32 = 1611333900;
pub const PMU_FORCE_HP_MEM_ISO: u32 = 15;
pub const PMU_FORCE_HP_MEM_ISO_V: u32 = 15;
pub const PMU_FORCE_HP_MEM_ISO_S: u32 = 0;
pub const PMU_FORCE_HP_MEM_PD: u32 = 15;
pub const PMU_FORCE_HP_MEM_PD_V: u32 = 15;
pub const PMU_FORCE_HP_MEM_PD_S: u32 = 4;
pub const PMU_FORCE_HP_MEM_NO_ISO: u32 = 15;
pub const PMU_FORCE_HP_MEM_NO_ISO_V: u32 = 15;
pub const PMU_FORCE_HP_MEM_NO_ISO_S: u32 = 24;
pub const PMU_FORCE_HP_MEM_PU: u32 = 15;
pub const PMU_FORCE_HP_MEM_PU_V: u32 = 15;
pub const PMU_FORCE_HP_MEM_PU_S: u32 = 28;
pub const PMU_POWER_PD_MEM_MASK_REG: u32 = 1611333904;
pub const PMU_PD_HP_MEM2_PD_MASK: u32 = 31;
pub const PMU_PD_HP_MEM2_PD_MASK_V: u32 = 31;
pub const PMU_PD_HP_MEM2_PD_MASK_S: u32 = 0;
pub const PMU_PD_HP_MEM1_PD_MASK: u32 = 31;
pub const PMU_PD_HP_MEM1_PD_MASK_V: u32 = 31;
pub const PMU_PD_HP_MEM1_PD_MASK_S: u32 = 5;
pub const PMU_PD_HP_MEM0_PD_MASK: u32 = 31;
pub const PMU_PD_HP_MEM0_PD_MASK_V: u32 = 31;
pub const PMU_PD_HP_MEM0_PD_MASK_S: u32 = 10;
pub const PMU_PD_HP_MEM2_MASK: u32 = 31;
pub const PMU_PD_HP_MEM2_MASK_V: u32 = 31;
pub const PMU_PD_HP_MEM2_MASK_S: u32 = 17;
pub const PMU_PD_HP_MEM1_MASK: u32 = 31;
pub const PMU_PD_HP_MEM1_MASK_V: u32 = 31;
pub const PMU_PD_HP_MEM1_MASK_S: u32 = 22;
pub const PMU_PD_HP_MEM0_MASK: u32 = 31;
pub const PMU_PD_HP_MEM0_MASK_V: u32 = 31;
pub const PMU_PD_HP_MEM0_MASK_S: u32 = 27;
pub const PMU_POWER_HP_PAD_REG: u32 = 1611333908;
pub const PMU_FORCE_HP_PAD_NO_ISO_ALL_V: u32 = 1;
pub const PMU_FORCE_HP_PAD_NO_ISO_ALL_S: u32 = 0;
pub const PMU_FORCE_HP_PAD_ISO_ALL_V: u32 = 1;
pub const PMU_FORCE_HP_PAD_ISO_ALL_S: u32 = 1;
pub const PMU_POWER_VDD_SPI_CNTL_REG: u32 = 1611333912;
pub const PMU_VDD_SPI_PWR_WAIT: u32 = 2047;
pub const PMU_VDD_SPI_PWR_WAIT_V: u32 = 2047;
pub const PMU_VDD_SPI_PWR_WAIT_S: u32 = 18;
pub const PMU_VDD_SPI_PWR_SW: u32 = 3;
pub const PMU_VDD_SPI_PWR_SW_V: u32 = 3;
pub const PMU_VDD_SPI_PWR_SW_S: u32 = 29;
pub const PMU_VDD_SPI_PWR_SEL_SW_V: u32 = 1;
pub const PMU_VDD_SPI_PWR_SEL_SW_S: u32 = 31;
pub const PMU_POWER_CK_WAIT_CNTL_REG: u32 = 1611333916;
pub const PMU_WAIT_XTL_STABLE: u32 = 65535;
pub const PMU_WAIT_XTL_STABLE_V: u32 = 65535;
pub const PMU_WAIT_XTL_STABLE_S: u32 = 0;
pub const PMU_WAIT_PLL_STABLE: u32 = 65535;
pub const PMU_WAIT_PLL_STABLE_V: u32 = 65535;
pub const PMU_WAIT_PLL_STABLE_S: u32 = 16;
pub const PMU_SLP_WAKEUP_CNTL0_REG: u32 = 1611333920;
pub const PMU_SLEEP_REQ_V: u32 = 1;
pub const PMU_SLEEP_REQ_S: u32 = 31;
pub const PMU_SLP_WAKEUP_CNTL1_REG: u32 = 1611333924;
pub const PMU_SLEEP_REJECT_ENA: u32 = 2147483647;
pub const PMU_SLEEP_REJECT_ENA_V: u32 = 2147483647;
pub const PMU_SLEEP_REJECT_ENA_S: u32 = 0;
pub const PMU_SLP_REJECT_EN_V: u32 = 1;
pub const PMU_SLP_REJECT_EN_S: u32 = 31;
pub const PMU_SLP_WAKEUP_CNTL2_REG: u32 = 1611333928;
pub const PMU_WAKEUP_ENA: u32 = 4294967295;
pub const PMU_WAKEUP_ENA_V: u32 = 4294967295;
pub const PMU_WAKEUP_ENA_S: u32 = 0;
pub const PMU_SLP_WAKEUP_CNTL3_REG: u32 = 1611333932;
pub const PMU_LP_MIN_SLP_VAL: u32 = 255;
pub const PMU_LP_MIN_SLP_VAL_V: u32 = 255;
pub const PMU_LP_MIN_SLP_VAL_S: u32 = 0;
pub const PMU_HP_MIN_SLP_VAL: u32 = 255;
pub const PMU_HP_MIN_SLP_VAL_V: u32 = 255;
pub const PMU_HP_MIN_SLP_VAL_S: u32 = 8;
pub const PMU_SLEEP_PRT_SEL: u32 = 3;
pub const PMU_SLEEP_PRT_SEL_V: u32 = 3;
pub const PMU_SLEEP_PRT_SEL_S: u32 = 16;
pub const PMU_SLP_WAKEUP_CNTL4_REG: u32 = 1611333936;
pub const PMU_SLP_REJECT_CAUSE_CLR_V: u32 = 1;
pub const PMU_SLP_REJECT_CAUSE_CLR_S: u32 = 31;
pub const PMU_SLP_WAKEUP_CNTL5_REG: u32 = 1611333940;
pub const PMU_MODEM_WAIT_TARGET: u32 = 1048575;
pub const PMU_MODEM_WAIT_TARGET_V: u32 = 1048575;
pub const PMU_MODEM_WAIT_TARGET_S: u32 = 0;
pub const PMU_LP_ANA_WAIT_TARGET: u32 = 255;
pub const PMU_LP_ANA_WAIT_TARGET_V: u32 = 255;
pub const PMU_LP_ANA_WAIT_TARGET_S: u32 = 24;
pub const PMU_SLP_WAKEUP_CNTL6_REG: u32 = 1611333944;
pub const PMU_SOC_WAKEUP_WAIT: u32 = 1048575;
pub const PMU_SOC_WAKEUP_WAIT_V: u32 = 1048575;
pub const PMU_SOC_WAKEUP_WAIT_S: u32 = 0;
pub const PMU_SOC_WAKEUP_WAIT_CFG: u32 = 3;
pub const PMU_SOC_WAKEUP_WAIT_CFG_V: u32 = 3;
pub const PMU_SOC_WAKEUP_WAIT_CFG_S: u32 = 30;
pub const PMU_SLP_WAKEUP_CNTL7_REG: u32 = 1611333948;
pub const PMU_ANA_WAIT_TARGET: u32 = 65535;
pub const PMU_ANA_WAIT_TARGET_V: u32 = 65535;
pub const PMU_ANA_WAIT_TARGET_S: u32 = 16;
pub const PMU_SLP_WAKEUP_STATUS0_REG: u32 = 1611333952;
pub const PMU_WAKEUP_CAUSE: u32 = 4294967295;
pub const PMU_WAKEUP_CAUSE_V: u32 = 4294967295;
pub const PMU_WAKEUP_CAUSE_S: u32 = 0;
pub const PMU_SLP_WAKEUP_STATUS1_REG: u32 = 1611333956;
pub const PMU_REJECT_CAUSE: u32 = 4294967295;
pub const PMU_REJECT_CAUSE_V: u32 = 4294967295;
pub const PMU_REJECT_CAUSE_S: u32 = 0;
pub const PMU_HP_CK_POWERON_REG: u32 = 1611333960;
pub const PMU_I2C_POR_WAIT_TARGET: u32 = 255;
pub const PMU_I2C_POR_WAIT_TARGET_V: u32 = 255;
pub const PMU_I2C_POR_WAIT_TARGET_S: u32 = 0;
pub const PMU_HP_CK_CNTL_REG: u32 = 1611333964;
pub const PMU_MODIFY_ICG_CNTL_WAIT: u32 = 255;
pub const PMU_MODIFY_ICG_CNTL_WAIT_V: u32 = 255;
pub const PMU_MODIFY_ICG_CNTL_WAIT_S: u32 = 0;
pub const PMU_SWITCH_ICG_CNTL_WAIT: u32 = 255;
pub const PMU_SWITCH_ICG_CNTL_WAIT_V: u32 = 255;
pub const PMU_SWITCH_ICG_CNTL_WAIT_S: u32 = 8;
pub const PMU_POR_STATUS_REG: u32 = 1611333968;
pub const PMU_POR_DONE_V: u32 = 1;
pub const PMU_POR_DONE_S: u32 = 31;
pub const PMU_RF_PWC_REG: u32 = 1611333972;
pub const PMU_PERIF_I2C_RSTB_V: u32 = 1;
pub const PMU_PERIF_I2C_RSTB_S: u32 = 26;
pub const PMU_XPD_PERIF_I2C_V: u32 = 1;
pub const PMU_XPD_PERIF_I2C_S: u32 = 27;
pub const PMU_XPD_TXRF_I2C_V: u32 = 1;
pub const PMU_XPD_TXRF_I2C_S: u32 = 28;
pub const PMU_XPD_RFRX_PBUS_V: u32 = 1;
pub const PMU_XPD_RFRX_PBUS_S: u32 = 29;
pub const PMU_XPD_CKGEN_I2C_V: u32 = 1;
pub const PMU_XPD_CKGEN_I2C_S: u32 = 30;
pub const PMU_XPD_PLL_I2C_V: u32 = 1;
pub const PMU_XPD_PLL_I2C_S: u32 = 31;
pub const PMU_BACKUP_CFG_REG: u32 = 1611333976;
pub const PMU_BACKUP_SYS_CLK_NO_DIV_V: u32 = 1;
pub const PMU_BACKUP_SYS_CLK_NO_DIV_S: u32 = 31;
pub const PMU_INT_RAW_REG: u32 = 1611333980;
pub const PMU_LP_CPU_EXC_INT_RAW_V: u32 = 1;
pub const PMU_LP_CPU_EXC_INT_RAW_S: u32 = 27;
pub const PMU_SDIO_IDLE_INT_RAW_V: u32 = 1;
pub const PMU_SDIO_IDLE_INT_RAW_S: u32 = 28;
pub const PMU_SW_INT_RAW_V: u32 = 1;
pub const PMU_SW_INT_RAW_S: u32 = 29;
pub const PMU_SOC_SLEEP_REJECT_INT_RAW_V: u32 = 1;
pub const PMU_SOC_SLEEP_REJECT_INT_RAW_S: u32 = 30;
pub const PMU_SOC_WAKEUP_INT_RAW_V: u32 = 1;
pub const PMU_SOC_WAKEUP_INT_RAW_S: u32 = 31;
pub const PMU_HP_INT_ST_REG: u32 = 1611333984;
pub const PMU_LP_CPU_EXC_INT_ST_V: u32 = 1;
pub const PMU_LP_CPU_EXC_INT_ST_S: u32 = 27;
pub const PMU_SDIO_IDLE_INT_ST_V: u32 = 1;
pub const PMU_SDIO_IDLE_INT_ST_S: u32 = 28;
pub const PMU_SW_INT_ST_V: u32 = 1;
pub const PMU_SW_INT_ST_S: u32 = 29;
pub const PMU_SOC_SLEEP_REJECT_INT_ST_V: u32 = 1;
pub const PMU_SOC_SLEEP_REJECT_INT_ST_S: u32 = 30;
pub const PMU_SOC_WAKEUP_INT_ST_V: u32 = 1;
pub const PMU_SOC_WAKEUP_INT_ST_S: u32 = 31;
pub const PMU_HP_INT_ENA_REG: u32 = 1611333988;
pub const PMU_LP_CPU_EXC_INT_ENA_V: u32 = 1;
pub const PMU_LP_CPU_EXC_INT_ENA_S: u32 = 27;
pub const PMU_SDIO_IDLE_INT_ENA_V: u32 = 1;
pub const PMU_SDIO_IDLE_INT_ENA_S: u32 = 28;
pub const PMU_SW_INT_ENA_V: u32 = 1;
pub const PMU_SW_INT_ENA_S: u32 = 29;
pub const PMU_SOC_SLEEP_REJECT_INT_ENA_V: u32 = 1;
pub const PMU_SOC_SLEEP_REJECT_INT_ENA_S: u32 = 30;
pub const PMU_SOC_WAKEUP_INT_ENA_V: u32 = 1;
pub const PMU_SOC_WAKEUP_INT_ENA_S: u32 = 31;
pub const PMU_HP_INT_CLR_REG: u32 = 1611333992;
pub const PMU_LP_CPU_EXC_INT_CLR_V: u32 = 1;
pub const PMU_LP_CPU_EXC_INT_CLR_S: u32 = 27;
pub const PMU_SDIO_IDLE_INT_CLR_V: u32 = 1;
pub const PMU_SDIO_IDLE_INT_CLR_S: u32 = 28;
pub const PMU_SW_INT_CLR_V: u32 = 1;
pub const PMU_SW_INT_CLR_S: u32 = 29;
pub const PMU_SOC_SLEEP_REJECT_INT_CLR_V: u32 = 1;
pub const PMU_SOC_SLEEP_REJECT_INT_CLR_S: u32 = 30;
pub const PMU_SOC_WAKEUP_INT_CLR_V: u32 = 1;
pub const PMU_SOC_WAKEUP_INT_CLR_S: u32 = 31;
pub const PMU_LP_INT_RAW_REG: u32 = 1611333996;
pub const PMU_LP_CPU_WAKEUP_INT_RAW_V: u32 = 1;
pub const PMU_LP_CPU_WAKEUP_INT_RAW_S: u32 = 20;
pub const PMU_MODEM_SWITCH_ACTIVE_END_INT_RAW_V: u32 = 1;
pub const PMU_MODEM_SWITCH_ACTIVE_END_INT_RAW_S: u32 = 21;
pub const PMU_SLEEP_SWITCH_ACTIVE_END_INT_RAW_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_ACTIVE_END_INT_RAW_S: u32 = 22;
pub const PMU_SLEEP_SWITCH_MODEM_END_INT_RAW_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_MODEM_END_INT_RAW_S: u32 = 23;
pub const PMU_MODEM_SWITCH_SLEEP_END_INT_RAW_V: u32 = 1;
pub const PMU_MODEM_SWITCH_SLEEP_END_INT_RAW_S: u32 = 24;
pub const PMU_ACTIVE_SWITCH_SLEEP_END_INT_RAW_V: u32 = 1;
pub const PMU_ACTIVE_SWITCH_SLEEP_END_INT_RAW_S: u32 = 25;
pub const PMU_MODEM_SWITCH_ACTIVE_START_INT_RAW_V: u32 = 1;
pub const PMU_MODEM_SWITCH_ACTIVE_START_INT_RAW_S: u32 = 26;
pub const PMU_SLEEP_SWITCH_ACTIVE_START_INT_RAW_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_ACTIVE_START_INT_RAW_S: u32 = 27;
pub const PMU_SLEEP_SWITCH_MODEM_START_INT_RAW_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_MODEM_START_INT_RAW_S: u32 = 28;
pub const PMU_MODEM_SWITCH_SLEEP_START_INT_RAW_V: u32 = 1;
pub const PMU_MODEM_SWITCH_SLEEP_START_INT_RAW_S: u32 = 29;
pub const PMU_ACTIVE_SWITCH_SLEEP_START_INT_RAW_V: u32 = 1;
pub const PMU_ACTIVE_SWITCH_SLEEP_START_INT_RAW_S: u32 = 30;
pub const PMU_HP_SW_TRIGGER_INT_RAW_V: u32 = 1;
pub const PMU_HP_SW_TRIGGER_INT_RAW_S: u32 = 31;
pub const PMU_LP_INT_ST_REG: u32 = 1611334000;
pub const PMU_LP_CPU_WAKEUP_INT_ST_V: u32 = 1;
pub const PMU_LP_CPU_WAKEUP_INT_ST_S: u32 = 20;
pub const PMU_MODEM_SWITCH_ACTIVE_END_INT_ST_V: u32 = 1;
pub const PMU_MODEM_SWITCH_ACTIVE_END_INT_ST_S: u32 = 21;
pub const PMU_SLEEP_SWITCH_ACTIVE_END_INT_ST_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_ACTIVE_END_INT_ST_S: u32 = 22;
pub const PMU_SLEEP_SWITCH_MODEM_END_INT_ST_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_MODEM_END_INT_ST_S: u32 = 23;
pub const PMU_MODEM_SWITCH_SLEEP_END_INT_ST_V: u32 = 1;
pub const PMU_MODEM_SWITCH_SLEEP_END_INT_ST_S: u32 = 24;
pub const PMU_ACTIVE_SWITCH_SLEEP_END_INT_ST_V: u32 = 1;
pub const PMU_ACTIVE_SWITCH_SLEEP_END_INT_ST_S: u32 = 25;
pub const PMU_MODEM_SWITCH_ACTIVE_START_INT_ST_V: u32 = 1;
pub const PMU_MODEM_SWITCH_ACTIVE_START_INT_ST_S: u32 = 26;
pub const PMU_SLEEP_SWITCH_ACTIVE_START_INT_ST_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_ACTIVE_START_INT_ST_S: u32 = 27;
pub const PMU_SLEEP_SWITCH_MODEM_START_INT_ST_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_MODEM_START_INT_ST_S: u32 = 28;
pub const PMU_MODEM_SWITCH_SLEEP_START_INT_ST_V: u32 = 1;
pub const PMU_MODEM_SWITCH_SLEEP_START_INT_ST_S: u32 = 29;
pub const PMU_ACTIVE_SWITCH_SLEEP_START_INT_ST_V: u32 = 1;
pub const PMU_ACTIVE_SWITCH_SLEEP_START_INT_ST_S: u32 = 30;
pub const PMU_HP_SW_TRIGGER_INT_ST_V: u32 = 1;
pub const PMU_HP_SW_TRIGGER_INT_ST_S: u32 = 31;
pub const PMU_LP_INT_ENA_REG: u32 = 1611334004;
pub const PMU_LP_CPU_WAKEUP_INT_ENA_V: u32 = 1;
pub const PMU_LP_CPU_WAKEUP_INT_ENA_S: u32 = 20;
pub const PMU_MODEM_SWITCH_ACTIVE_END_INT_ENA_V: u32 = 1;
pub const PMU_MODEM_SWITCH_ACTIVE_END_INT_ENA_S: u32 = 21;
pub const PMU_SLEEP_SWITCH_ACTIVE_END_INT_ENA_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_ACTIVE_END_INT_ENA_S: u32 = 22;
pub const PMU_SLEEP_SWITCH_MODEM_END_INT_ENA_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_MODEM_END_INT_ENA_S: u32 = 23;
pub const PMU_MODEM_SWITCH_SLEEP_END_INT_ENA_V: u32 = 1;
pub const PMU_MODEM_SWITCH_SLEEP_END_INT_ENA_S: u32 = 24;
pub const PMU_ACTIVE_SWITCH_SLEEP_END_INT_ENA_V: u32 = 1;
pub const PMU_ACTIVE_SWITCH_SLEEP_END_INT_ENA_S: u32 = 25;
pub const PMU_MODEM_SWITCH_ACTIVE_START_INT_ENA_V: u32 = 1;
pub const PMU_MODEM_SWITCH_ACTIVE_START_INT_ENA_S: u32 = 26;
pub const PMU_SLEEP_SWITCH_ACTIVE_START_INT_ENA_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_ACTIVE_START_INT_ENA_S: u32 = 27;
pub const PMU_SLEEP_SWITCH_MODEM_START_INT_ENA_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_MODEM_START_INT_ENA_S: u32 = 28;
pub const PMU_MODEM_SWITCH_SLEEP_START_INT_ENA_V: u32 = 1;
pub const PMU_MODEM_SWITCH_SLEEP_START_INT_ENA_S: u32 = 29;
pub const PMU_ACTIVE_SWITCH_SLEEP_START_INT_ENA_V: u32 = 1;
pub const PMU_ACTIVE_SWITCH_SLEEP_START_INT_ENA_S: u32 = 30;
pub const PMU_HP_SW_TRIGGER_INT_ENA_V: u32 = 1;
pub const PMU_HP_SW_TRIGGER_INT_ENA_S: u32 = 31;
pub const PMU_LP_INT_CLR_REG: u32 = 1611334008;
pub const PMU_LP_CPU_WAKEUP_INT_CLR_V: u32 = 1;
pub const PMU_LP_CPU_WAKEUP_INT_CLR_S: u32 = 20;
pub const PMU_MODEM_SWITCH_ACTIVE_END_INT_CLR_V: u32 = 1;
pub const PMU_MODEM_SWITCH_ACTIVE_END_INT_CLR_S: u32 = 21;
pub const PMU_SLEEP_SWITCH_ACTIVE_END_INT_CLR_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_ACTIVE_END_INT_CLR_S: u32 = 22;
pub const PMU_SLEEP_SWITCH_MODEM_END_INT_CLR_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_MODEM_END_INT_CLR_S: u32 = 23;
pub const PMU_MODEM_SWITCH_SLEEP_END_INT_CLR_V: u32 = 1;
pub const PMU_MODEM_SWITCH_SLEEP_END_INT_CLR_S: u32 = 24;
pub const PMU_ACTIVE_SWITCH_SLEEP_END_INT_CLR_V: u32 = 1;
pub const PMU_ACTIVE_SWITCH_SLEEP_END_INT_CLR_S: u32 = 25;
pub const PMU_MODEM_SWITCH_ACTIVE_START_INT_CLR_V: u32 = 1;
pub const PMU_MODEM_SWITCH_ACTIVE_START_INT_CLR_S: u32 = 26;
pub const PMU_SLEEP_SWITCH_ACTIVE_START_INT_CLR_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_ACTIVE_START_INT_CLR_S: u32 = 27;
pub const PMU_SLEEP_SWITCH_MODEM_START_INT_CLR_V: u32 = 1;
pub const PMU_SLEEP_SWITCH_MODEM_START_INT_CLR_S: u32 = 28;
pub const PMU_MODEM_SWITCH_SLEEP_START_INT_CLR_V: u32 = 1;
pub const PMU_MODEM_SWITCH_SLEEP_START_INT_CLR_S: u32 = 29;
pub const PMU_ACTIVE_SWITCH_SLEEP_START_INT_CLR_V: u32 = 1;
pub const PMU_ACTIVE_SWITCH_SLEEP_START_INT_CLR_S: u32 = 30;
pub const PMU_HP_SW_TRIGGER_INT_CLR_V: u32 = 1;
pub const PMU_HP_SW_TRIGGER_INT_CLR_S: u32 = 31;
pub const PMU_LP_CPU_PWR0_REG: u32 = 1611334012;
pub const PMU_LP_CPU_WAITI_RDY_V: u32 = 1;
pub const PMU_LP_CPU_WAITI_RDY_S: u32 = 0;
pub const PMU_LP_CPU_STALL_RDY_V: u32 = 1;
pub const PMU_LP_CPU_STALL_RDY_S: u32 = 1;
pub const PMU_LP_CPU_FORCE_STALL_V: u32 = 1;
pub const PMU_LP_CPU_FORCE_STALL_S: u32 = 18;
pub const PMU_LP_CPU_SLP_WAITI_FLAG_EN_V: u32 = 1;
pub const PMU_LP_CPU_SLP_WAITI_FLAG_EN_S: u32 = 19;
pub const PMU_LP_CPU_SLP_STALL_FLAG_EN_V: u32 = 1;
pub const PMU_LP_CPU_SLP_STALL_FLAG_EN_S: u32 = 20;
pub const PMU_LP_CPU_SLP_STALL_WAIT: u32 = 255;
pub const PMU_LP_CPU_SLP_STALL_WAIT_V: u32 = 255;
pub const PMU_LP_CPU_SLP_STALL_WAIT_S: u32 = 21;
pub const PMU_LP_CPU_SLP_STALL_EN_V: u32 = 1;
pub const PMU_LP_CPU_SLP_STALL_EN_S: u32 = 29;
pub const PMU_LP_CPU_SLP_RESET_EN_V: u32 = 1;
pub const PMU_LP_CPU_SLP_RESET_EN_S: u32 = 30;
pub const PMU_LP_CPU_SLP_BYPASS_INTR_EN_V: u32 = 1;
pub const PMU_LP_CPU_SLP_BYPASS_INTR_EN_S: u32 = 31;
pub const PMU_LP_CPU_PWR1_REG: u32 = 1611334016;
pub const PMU_LP_CPU_WAKEUP_EN: u32 = 65535;
pub const PMU_LP_CPU_WAKEUP_EN_V: u32 = 65535;
pub const PMU_LP_CPU_WAKEUP_EN_S: u32 = 0;
pub const PMU_LP_CPU_SLEEP_REQ_V: u32 = 1;
pub const PMU_LP_CPU_SLEEP_REQ_S: u32 = 31;
pub const PMU_HP_LP_CPU_COMM_REG: u32 = 1611334020;
pub const PMU_LP_TRIGGER_HP_V: u32 = 1;
pub const PMU_LP_TRIGGER_HP_S: u32 = 30;
pub const PMU_HP_TRIGGER_LP_V: u32 = 1;
pub const PMU_HP_TRIGGER_LP_S: u32 = 31;
pub const PMU_HP_REGULATOR_CFG_REG: u32 = 1611334024;
pub const PMU_DIG_REGULATOR_EN_CAL_V: u32 = 1;
pub const PMU_DIG_REGULATOR_EN_CAL_S: u32 = 31;
pub const PMU_MAIN_STATE_REG: u32 = 1611334028;
pub const PMU_MAIN_LAST_ST_STATE: u32 = 127;
pub const PMU_MAIN_LAST_ST_STATE_V: u32 = 127;
pub const PMU_MAIN_LAST_ST_STATE_S: u32 = 11;
pub const PMU_MAIN_TAR_ST_STATE: u32 = 127;
pub const PMU_MAIN_TAR_ST_STATE_V: u32 = 127;
pub const PMU_MAIN_TAR_ST_STATE_S: u32 = 18;
pub const PMU_MAIN_CUR_ST_STATE: u32 = 127;
pub const PMU_MAIN_CUR_ST_STATE_V: u32 = 127;
pub const PMU_MAIN_CUR_ST_STATE_S: u32 = 25;
pub const PMU_PWR_STATE_REG: u32 = 1611334032;
pub const PMU_BACKUP_ST_STATE: u32 = 31;
pub const PMU_BACKUP_ST_STATE_V: u32 = 31;
pub const PMU_BACKUP_ST_STATE_S: u32 = 13;
pub const PMU_LP_PWR_ST_STATE: u32 = 31;
pub const PMU_LP_PWR_ST_STATE_V: u32 = 31;
pub const PMU_LP_PWR_ST_STATE_S: u32 = 18;
pub const PMU_HP_PWR_ST_STATE: u32 = 511;
pub const PMU_HP_PWR_ST_STATE_V: u32 = 511;
pub const PMU_HP_PWR_ST_STATE_S: u32 = 23;
pub const PMU_CLK_STATE0_REG: u32 = 1611334036;
pub const PMU_STABLE_XPD_BBPLL_STATE_V: u32 = 1;
pub const PMU_STABLE_XPD_BBPLL_STATE_S: u32 = 0;
pub const PMU_STABLE_XPD_XTAL_STATE_V: u32 = 1;
pub const PMU_STABLE_XPD_XTAL_STATE_S: u32 = 1;
pub const PMU_SYS_CLK_SLP_SEL_STATE_V: u32 = 1;
pub const PMU_SYS_CLK_SLP_SEL_STATE_S: u32 = 15;
pub const PMU_SYS_CLK_SEL_STATE: u32 = 3;
pub const PMU_SYS_CLK_SEL_STATE_V: u32 = 3;
pub const PMU_SYS_CLK_SEL_STATE_S: u32 = 16;
pub const PMU_SYS_CLK_NO_DIV_STATE_V: u32 = 1;
pub const PMU_SYS_CLK_NO_DIV_STATE_S: u32 = 18;
pub const PMU_ICG_SYS_CLK_EN_STATE_V: u32 = 1;
pub const PMU_ICG_SYS_CLK_EN_STATE_S: u32 = 19;
pub const PMU_ICG_MODEM_SWITCH_STATE_V: u32 = 1;
pub const PMU_ICG_MODEM_SWITCH_STATE_S: u32 = 20;
pub const PMU_ICG_MODEM_CODE_STATE: u32 = 3;
pub const PMU_ICG_MODEM_CODE_STATE_V: u32 = 3;
pub const PMU_ICG_MODEM_CODE_STATE_S: u32 = 21;
pub const PMU_ICG_SLP_SEL_STATE_V: u32 = 1;
pub const PMU_ICG_SLP_SEL_STATE_S: u32 = 23;
pub const PMU_ICG_GLOBAL_XTAL_STATE_V: u32 = 1;
pub const PMU_ICG_GLOBAL_XTAL_STATE_S: u32 = 24;
pub const PMU_ICG_GLOBAL_PLL_STATE_V: u32 = 1;
pub const PMU_ICG_GLOBAL_PLL_STATE_S: u32 = 25;
pub const PMU_ANA_I2C_ISO_EN_STATE_V: u32 = 1;
pub const PMU_ANA_I2C_ISO_EN_STATE_S: u32 = 26;
pub const PMU_ANA_I2C_RETENTION_STATE_V: u32 = 1;
pub const PMU_ANA_I2C_RETENTION_STATE_S: u32 = 27;
pub const PMU_ANA_XPD_BB_I2C_STATE_V: u32 = 1;
pub const PMU_ANA_XPD_BB_I2C_STATE_S: u32 = 28;
pub const PMU_ANA_XPD_BBPLL_I2C_STATE_V: u32 = 1;
pub const PMU_ANA_XPD_BBPLL_I2C_STATE_S: u32 = 29;
pub const PMU_ANA_XPD_BBPLL_STATE_V: u32 = 1;
pub const PMU_ANA_XPD_BBPLL_STATE_S: u32 = 30;
pub const PMU_ANA_XPD_XTAL_STATE_V: u32 = 1;
pub const PMU_ANA_XPD_XTAL_STATE_S: u32 = 31;
pub const PMU_CLK_STATE1_REG: u32 = 1611334040;
pub const PMU_ICG_FUNC_EN_STATE: u32 = 4294967295;
pub const PMU_ICG_FUNC_EN_STATE_V: u32 = 4294967295;
pub const PMU_ICG_FUNC_EN_STATE_S: u32 = 0;
pub const PMU_CLK_STATE2_REG: u32 = 1611334044;
pub const PMU_ICG_APB_EN_STATE: u32 = 4294967295;
pub const PMU_ICG_APB_EN_STATE_V: u32 = 4294967295;
pub const PMU_ICG_APB_EN_STATE_S: u32 = 0;
pub const PMU_VDD_SPI_STATUS_REG: u32 = 1611334048;
pub const PMU_STABLE_VDD_SPI_PWR_DRV_V: u32 = 1;
pub const PMU_STABLE_VDD_SPI_PWR_DRV_S: u32 = 31;
pub const PMU_DATE_REG: u32 = 1611334652;
pub const PMU_PMU_DATE: u32 = 2147483647;
pub const PMU_PMU_DATE_V: u32 = 2147483647;
pub const PMU_PMU_DATE_S: u32 = 0;
pub const PMU_CLK_EN_V: u32 = 1;
pub const PMU_CLK_EN_S: u32 = 31;
pub const HP_CALI_DBIAS_DEFAULT: u32 = 25;
pub const LP_CALI_DBIAS_DEFAULT: u32 = 26;
pub const PMU_PD_CUR_SLEEP_ON: u32 = 0;
pub const PMU_BIASSLP_SLEEP_ON: u32 = 0;
pub const PMU_PD_CUR_SLEEP_DEFAULT: u32 = 1;
pub const PMU_BIASSLP_SLEEP_DEFAULT: u32 = 1;
pub const PMU_LP_XPD_SLEEP_DEFAULT: u32 = 1;
pub const PMU_LP_SLP_XPD_SLEEP_DEFAULT: u32 = 0;
pub const PMU_LP_SLP_DBIAS_SLEEP_DEFAULT: u32 = 0;
pub const PMU_HP_DRVB_LIGHTSLEEP: u32 = 0;
pub const PMU_LP_DRVB_LIGHTSLEEP: u32 = 0;
pub const PMU_HP_XPD_LIGHTSLEEP: u32 = 1;
pub const PMU_DBG_ATTEN_LIGHTSLEEP_NODROP: u32 = 0;
pub const PMU_DBG_ATTEN_LIGHTSLEEP_DEFAULT: u32 = 0;
pub const PMU_HP_DBIAS_LIGHTSLEEP_0V6_DEFAULT: u32 = 1;
pub const PMU_LP_DBIAS_LIGHTSLEEP_0V7_DEFAULT: u32 = 12;
pub const PMU_DBG_ATTEN_ACTIVE_DEFAULT: u32 = 0;
pub const PMU_DBG_HP_DEEPSLEEP: u32 = 0;
pub const PMU_HP_XPD_DEEPSLEEP: u32 = 0;
pub const PMU_LP_DRVB_DEEPSLEEP: u32 = 0;
pub const PMU_REGDMA_S2A_WORK_TIME_US: u32 = 480;
pub const PMU_DBG_ATTEN_DEEPSLEEP_DEFAULT: u32 = 12;
pub const PMU_LP_DBIAS_DEEPSLEEP_0V7_DEFAULT: u32 = 23;
pub const EFUSE_BURN_OFFSET_DSLP_DBG: u32 = 8;
pub const EFUSE_BURN_OFFSET_DSLP_LP_DBIAS: u32 = 23;
pub const PMU_HP_SLEEP_MIN_SLOW_CLK_CYCLES: u32 = 10;
pub const PMU_LP_SLEEP_MIN_SLOW_CLK_CYCLES: u32 = 10;
pub const PMU_HP_WAKEUP_DELAY_CYCLES: u32 = 0;
pub const PMU_HP_XTAL_STABLE_WAIT_CYCLES: u32 = 3155;
pub const PMU_HP_PLL_STABLE_WAIT_CYCLES: u32 = 2;
pub const PMU_HP_ANALOG_WAIT_TARGET_CYCLES: u32 = 2419;
pub const PMU_HP_DIGITAL_POWER_SUPPLY_WAIT_CYCLES: u32 = 32;
pub const PMU_HP_DIGITAL_POWER_UP_WAIT_CYCLES: u32 = 32;
pub const PMU_HP_MODEM_WAKEUP_WAIT_CYCLES: u32 = 20700;
pub const PMU_LP_WAKEUP_DELAY_CYCLES: u32 = 0;
pub const PMU_LP_XTAL_STABLE_WAIT_SLOW_CLK_CYCLES: u32 = 30;
pub const PMU_LP_ANALOG_WAIT_TARGET_CYCLES: u32 = 23;
pub const PMU_LP_DIGITAL_POWER_SUPPLY_WAIT_CYCLES: u32 = 32;
pub const PMU_LP_DIGITAL_POWER_UP_WAIT_CYCLES: u32 = 32;
pub const PMU_LP_ANALOG_WAIT_TARGET_TIME_DSLP_US: u32 = 500;
pub const RTC_EXT0_TRIG_EN: u32 = 0;
pub const RTC_UART2_TRIG_EN: u32 = 0;
pub const RTC_TOUCH_TRIG_EN: u32 = 0;
pub const RTC_LP_VAD_TRIG_EN: u32 = 0;
pub const RTC_VBAT_UNDER_VOLT_TRIG_EN: u32 = 0;
pub const RTC_XTAL32K_DEAD_TRIG_EN: u32 = 0;
pub const RTC_BROWNOUT_DET_TRIG_EN: u32 = 0;
pub const CONFIG_VERSION: u32 = 539297286;
pub const CONFIG_MAGIC: u32 = 1515890085;
pub const EXTERNAL_COEXIST_WIRE_1: u32 = 0;
pub const EXTERNAL_COEXIST_WIRE_2: u32 = 1;
pub const EXTERNAL_COEXIST_WIRE_3: u32 = 2;
pub const EXTERNAL_COEXIST_WIRE_4: u32 = 3;
pub const ESP_COEX_BLE_ST_MESH_CONFIG: u32 = 8;
pub const ESP_COEX_BLE_ST_MESH_TRAFFIC: u32 = 16;
pub const ESP_COEX_BLE_ST_MESH_STANDBY: u32 = 32;
pub const ESP_COEX_BT_ST_A2DP_STREAMING: u32 = 16;
pub const ESP_COEX_BT_ST_A2DP_PAUSED: u32 = 32;
pub const COEX_ADAPTER_VERSION: u32 = 2;
pub const COEX_ADAPTER_MAGIC: u32 = 3735928495;
pub const COEX_ADAPTER_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const ESP_ERR_ESPNOW_BASE: u32 = 12388;
pub const ESP_ERR_ESPNOW_NOT_INIT: u32 = 12389;
pub const ESP_ERR_ESPNOW_ARG: u32 = 12390;
pub const ESP_ERR_ESPNOW_NO_MEM: u32 = 12391;
pub const ESP_ERR_ESPNOW_FULL: u32 = 12392;
pub const ESP_ERR_ESPNOW_NOT_FOUND: u32 = 12393;
pub const ESP_ERR_ESPNOW_INTERNAL: u32 = 12394;
pub const ESP_ERR_ESPNOW_EXIST: u32 = 12395;
pub const ESP_ERR_ESPNOW_IF: u32 = 12396;
pub const ESP_ERR_ESPNOW_CHAN: u32 = 12397;
pub const ESP_NOW_ETH_ALEN: u32 = 6;
pub const ESP_NOW_KEY_LEN: u32 = 16;
pub const ESP_NOW_MAX_TOTAL_PEER_NUM: u32 = 20;
pub const ESP_NOW_MAX_ENCRYPT_PEER_NUM: u32 = 6;
pub const ESP_NOW_MAX_IE_DATA_LEN: u32 = 250;
pub const ESP_NOW_MAX_DATA_LEN: u32 = 250;
pub const ESP_NOW_MAX_DATA_LEN_V2: u32 = 1470;
pub type __int8_t = crate::c_types::c_schar;
pub type __uint8_t = crate::c_types::c_uchar;
pub type __int16_t = crate::c_types::c_short;
pub type __uint16_t = crate::c_types::c_ushort;
pub type __int32_t = crate::c_types::c_int;
pub type __uint32_t = crate::c_types::c_uint;
pub type __int64_t = crate::c_types::c_longlong;
pub type __uint64_t = crate::c_types::c_ulonglong;
pub type __int_least8_t = crate::c_types::c_schar;
pub type __uint_least8_t = crate::c_types::c_uchar;
pub type __int_least16_t = crate::c_types::c_short;
pub type __uint_least16_t = crate::c_types::c_ushort;
pub type __int_least32_t = crate::c_types::c_int;
pub type __uint_least32_t = crate::c_types::c_uint;
pub type __int_least64_t = crate::c_types::c_longlong;
pub type __uint_least64_t = crate::c_types::c_ulonglong;
pub type __intmax_t = crate::c_types::c_longlong;
pub type __uintmax_t = crate::c_types::c_ulonglong;
pub type __intptr_t = crate::c_types::c_int;
pub type __uintptr_t = crate::c_types::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::c_types::c_schar;
pub type uint_fast8_t = crate::c_types::c_uchar;
pub type int_fast16_t = crate::c_types::c_short;
pub type uint_fast16_t = crate::c_types::c_ushort;
pub type int_fast32_t = crate::c_types::c_int;
pub type uint_fast32_t = crate::c_types::c_uint;
pub type int_fast64_t = crate::c_types::c_longlong;
pub type uint_fast64_t = crate::c_types::c_ulonglong;
pub type _lock_t = crate::c_types::c_int;
pub type TickType_t = u32;
pub type UBaseType_t = u32;
pub type BaseType_t = i32;
pub type QueueHandle_t = *mut crate::c_types::c_void;
pub type esp_netif_t = *mut crate::c_types::c_void;
pub type esp_netif_inherent_config_t = *mut crate::c_types::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ets_timer {
    pub next: *mut timer_adpt,
    pub expire: u32,
    pub period: u32,
    pub func: ::core::option::Option<unsafe extern "C" fn(priv_: *mut crate::c_types::c_void)>,
    pub priv_: *mut crate::c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: u64,
    pub tv_usec: u32,
}
pub type wchar_t = crate::c_types::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::c_types::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type wint_t = crate::c_types::c_uint;
pub type __blkcnt_t = crate::c_types::c_long;
pub type __blksize_t = crate::c_types::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = crate::c_types::c_long;
pub type __pid_t = crate::c_types::c_int;
pub type __dev_t = crate::c_types::c_short;
pub type __uid_t = crate::c_types::c_ushort;
pub type __gid_t = crate::c_types::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = crate::c_types::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = crate::c_types::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = crate::c_types::c_long;
pub type _fpos_t = crate::c_types::c_long;
pub type __size_t = crate::c_types::c_uint;
pub type _ssize_t = crate::c_types::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: crate::c_types::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [crate::c_types::c_uchar; 4usize],
}
pub type _iconv_t = *mut crate::c_types::c_void;
pub type __clock_t = crate::c_types::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = crate::c_types::c_ulong;
pub type __daddr_t = crate::c_types::c_long;
pub type __timer_t = crate::c_types::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = crate::c_types::c_int;
pub type __nlink_t = crate::c_types::c_ushort;
pub type __suseconds_t = crate::c_types::c_long;
pub type __useconds_t = crate::c_types::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = crate::c_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: crate::c_types::c_int,
    pub _maxwds: crate::c_types::c_int,
    pub _sign: crate::c_types::c_int,
    pub _wds: crate::c_types::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __tm {
    pub __tm_sec: crate::c_types::c_int,
    pub __tm_min: crate::c_types::c_int,
    pub __tm_hour: crate::c_types::c_int,
    pub __tm_mday: crate::c_types::c_int,
    pub __tm_mon: crate::c_types::c_int,
    pub __tm_year: crate::c_types::c_int,
    pub __tm_wday: crate::c_types::c_int,
    pub __tm_yday: crate::c_types::c_int,
    pub __tm_isdst: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut crate::c_types::c_void; 32usize],
    pub _dso_handle: [*mut crate::c_types::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: crate::c_types::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut crate::c_types::c_uchar,
    pub _size: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut crate::c_types::c_uchar,
    pub _r: crate::c_types::c_int,
    pub _w: crate::c_types::c_int,
    pub _flags: crate::c_types::c_short,
    pub _file: crate::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::c_types::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut crate::c_types::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *mut crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> _ssize_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *const crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> _ssize_t,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: _fpos_t,
            arg4: crate::c_types::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut crate::c_types::c_uchar,
    pub _ur: crate::c_types::c_int,
    pub _ubuf: [crate::c_types::c_uchar; 3usize],
    pub _nbuf: [crate::c_types::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: crate::c_types::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: crate::c_types::c_int,
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: crate::c_types::c_int,
    pub _iobs: *mut __FILE,
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rand48 {
    pub _seed: [crate::c_types::c_ushort; 3usize],
    pub _mult: [crate::c_types::c_ushort; 3usize],
    pub _add: crate::c_types::c_ushort,
    pub _rand_next: crate::c_types::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: crate::c_types::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut crate::c_types::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [crate::c_types::c_char; 8usize],
    pub _getdate_err: crate::c_types::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: crate::c_types::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: crate::c_types::c_int,
    pub _emergency: *mut crate::c_types::c_char,
    pub _reserved_0: crate::c_types::c_int,
    pub _reserved_1: crate::c_types::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: crate::c_types::c_int,
    pub _cvtlen: crate::c_types::c_int,
    pub _cvtbuf: *mut crate::c_types::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut crate::c_types::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: crate::c_types::c_int)>,
    pub _reserved_6: *mut _atexit,
    pub _reserved_7: _atexit,
    pub _reserved_8: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut crate::c_types::c_char,
}
extern "C" {
    pub fn __assert(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: *const crate::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> crate::c_types::c_int,
        >,
        arg3: *mut _glue,
    ) -> crate::c_types::c_int;
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub type off_t = __off_t;
extern "C" {
    pub fn ctermid(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut crate::c_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn printf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const crate::c_types::c_char,
        arg2: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn fputc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const crate::c_types::c_char, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getchar() -> crate::c_types::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn putc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putchar(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn puts(arg1: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ungetc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut crate::c_types::c_void,
        _size: crate::c_types::c_uint,
        _n: crate::c_types::c_uint,
        arg2: *mut FILE,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const crate::c_types::c_void,
        _size: crate::c_types::c_uint,
        _n: crate::c_types::c_uint,
        arg2: *mut FILE,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: crate::c_types::c_long,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> crate::c_types::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn perror(arg1: *const crate::c_types::c_char);
}
extern "C" {
    pub fn fopen(
        _name: *const crate::c_types::c_char,
        _type: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn remove(arg1: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_uint,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_uint,
        arg3: *const crate::c_types::c_char,
        arg4: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const crate::c_types::c_char,
        arg2: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fiprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fiscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: usize,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn viprintf(
        arg1: *const crate::c_types::c_char,
        arg2: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn viscanf(
        arg1: *const crate::c_types::c_char,
        arg2: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: usize,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fdopen(arg1: crate::c_types::c_int, arg2: *const crate::c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putw(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> crate::c_types::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut crate::c_types::c_void,
        arg2: usize,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut crate::c_types::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _fgetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *mut fpos_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: crate::c_types::c_long,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _gets_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const crate::c_types::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const crate::c_types::c_char)
        -> crate::c_types::c_int;
}
extern "C" {
    pub fn _remove_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const crate::c_types::c_char,
        _new: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const crate::c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *mut crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *const crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __off: fpos_t,
                __whence: crate::c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut crate::c_types::c_void) -> crate::c_types::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const crate::c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *mut crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *const crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __off: fpos_t,
                __whence: crate::c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut crate::c_types::c_void) -> crate::c_types::c_int,
        >,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: crate::c_types::c_int,
    pub rem: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: crate::c_types::c_long,
    pub rem: crate::c_types::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: crate::c_types::c_longlong,
    pub rem: crate::c_types::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> crate::c_types::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut crate::c_types::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const crate::c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const crate::c_types::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const crate::c_types::c_void,
        __base: *const crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: crate::c_types::c_uint,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn div(__numer: crate::c_types::c_int, __denom: crate::c_types::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: crate::c_types::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn getenv(__string: *const crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const crate::c_types::c_char,
        arg2: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut crate::c_types::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const *mut crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn labs(arg1: crate::c_types::c_long) -> crate::c_types::c_long;
}
extern "C" {
    pub fn ldiv(__numer: crate::c_types::c_long, __denom: crate::c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: crate::c_types::c_uint) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const crate::c_types::c_char, arg2: usize) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut crate::c_types::c_char, arg2: wchar_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const crate::c_types::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut crate::c_types::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> crate::c_types::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut crate::c_types::c_void,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut crate::c_types::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut crate::c_types::c_void, arg2: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const crate::c_types::c_char,
        resolved_path: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: crate::c_types::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn system(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn a64l(__input: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn l64a(__input: crate::c_types::c_long) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: crate::c_types::c_long,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: crate::c_types::c_int, arg2: *mut crate::c_types::c_void),
        >,
        __arg: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _Exit(__status: crate::c_types::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut crate::c_types::c_uint) -> crate::c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn lrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut crate::c_types::c_ushort) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: crate::c_types::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: crate::c_types::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn random() -> crate::c_types::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn srandom(arg1: crate::c_types::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: crate::c_types::c_longlong) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: crate::c_types::c_longlong,
        __denom: crate::c_types::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut crate::c_types::c_void,
        arg2: usize,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
        arg5: *mut crate::c_types::c_int,
        arg6: *mut crate::c_types::c_int,
        arg7: *mut *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
        arg4: *const crate::c_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut crate::c_types::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *const crate::c_types::c_void,
                arg3: *const crate::c_types::c_void,
            ) -> crate::c_types::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(
        arg1: *const crate::c_types::c_char,
        arg2: *mut *mut crate::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn aligned_alloc(
        arg1: crate::c_types::c_uint,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: crate::c_types::c_int);
}
pub type esp_err_t = crate::c_types::c_int;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes\n\n This function finds the error code in a pre-generated lookup-table and\n returns its string representation.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes\n\n This function finds the error code in a pre-generated lookup-table of\n esp_err_t errors and returns its string representation. If the error code\n is not found then it is attempted to be found among system errors.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @param[out] buf buffer where the error message should be written\n @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte).\n @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut crate::c_types::c_char,
        buflen: usize,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        function: *const crate::c_types::c_char,
        expression: *const crate::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        function: *const crate::c_types::c_char,
        expression: *const crate::c_types::c_char,
    );
}
pub type esp_event_base_t = *const crate::c_types::c_char;
pub type esp_event_loop_handle_t = *mut crate::c_types::c_void;
pub type esp_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        event_handler_arg: *mut crate::c_types::c_void,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut crate::c_types::c_void,
    ),
>;
pub type esp_event_handler_instance_t = *mut crate::c_types::c_void;
#[doc = "< Station interface"]
pub const esp_interface_t_ESP_IF_WIFI_STA: esp_interface_t = 0;
#[doc = "< Soft-AP interface"]
pub const esp_interface_t_ESP_IF_WIFI_AP: esp_interface_t = 1;
#[doc = "< NAN interface"]
pub const esp_interface_t_ESP_IF_WIFI_NAN: esp_interface_t = 2;
#[doc = "< Ethernet interface"]
pub const esp_interface_t_ESP_IF_ETH: esp_interface_t = 3;
pub const esp_interface_t_ESP_IF_MAX: esp_interface_t = 4;
pub type esp_interface_t = crate::c_types::c_uint;
#[doc = "< Null mode"]
pub const wifi_mode_t_WIFI_MODE_NULL: wifi_mode_t = 0;
#[doc = "< Wi-Fi station mode"]
pub const wifi_mode_t_WIFI_MODE_STA: wifi_mode_t = 1;
#[doc = "< Wi-Fi soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_AP: wifi_mode_t = 2;
#[doc = "< Wi-Fi station + soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_APSTA: wifi_mode_t = 3;
#[doc = "< Wi-Fi NAN mode"]
pub const wifi_mode_t_WIFI_MODE_NAN: wifi_mode_t = 4;
pub const wifi_mode_t_WIFI_MODE_MAX: wifi_mode_t = 5;
#[doc = " @brief Wi-Fi mode type"]
pub type wifi_mode_t = crate::c_types::c_uint;
#[doc = "< Station interface"]
pub const wifi_interface_t_WIFI_IF_STA: wifi_interface_t = 0;
#[doc = "< Soft-AP interface"]
pub const wifi_interface_t_WIFI_IF_AP: wifi_interface_t = 1;
#[doc = "< NAN interface"]
pub const wifi_interface_t_WIFI_IF_NAN: wifi_interface_t = 2;
#[doc = "< Maximum number of interfaces"]
pub const wifi_interface_t_WIFI_IF_MAX: wifi_interface_t = 3;
#[doc = " @brief Wi-Fi interface type"]
pub type wifi_interface_t = crate::c_types::c_uint;
#[doc = "< Cancel off-channel transmission"]
pub const wifi_action_tx_t_WIFI_OFFCHAN_TX_CANCEL: wifi_action_tx_t = 0;
#[doc = "< Request off-channel transmission"]
pub const wifi_action_tx_t_WIFI_OFFCHAN_TX_REQ: wifi_action_tx_t = 1;
pub type wifi_action_tx_t = crate::c_types::c_uint;
#[doc = "< Cancel remain on channel"]
pub const wifi_roc_t_WIFI_ROC_CANCEL: wifi_roc_t = 0;
#[doc = "< Request remain on channel"]
pub const wifi_roc_t_WIFI_ROC_REQ: wifi_roc_t = 1;
pub type wifi_roc_t = crate::c_types::c_uint;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_AUTO: wifi_country_policy_t = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_MANUAL: wifi_country_policy_t = 1;
#[doc = " @brief Wi-Fi country policy"]
pub type wifi_country_policy_t = crate::c_types::c_uint;
#[doc = " @brief Structure describing Wi-Fi country-based regional restrictions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< Country code string"]
    pub cc: [crate::c_types::c_char; 3usize],
    #[doc = "< Start channel of the allowed 2.4GHz Wi-Fi channels"]
    pub schan: u8,
    #[doc = "< Total channel number of the allowed 2.4GHz Wi-Fi channels"]
    pub nchan: u8,
    #[doc = "< This field is used for getting Wi-Fi maximum transmitting power, call esp_wifi_set_max_tx_power to set the maximum transmitting power."]
    pub max_tx_power: i8,
    #[doc = "< Country policy"]
    pub policy: wifi_country_policy_t,
}
#[doc = "< Authenticate mode : open"]
pub const wifi_auth_mode_t_WIFI_AUTH_OPEN: wifi_auth_mode_t = 0;
#[doc = "< Authenticate mode : WEP"]
pub const wifi_auth_mode_t_WIFI_AUTH_WEP: wifi_auth_mode_t = 1;
#[doc = "< Authenticate mode : WPA_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_PSK: wifi_auth_mode_t = 2;
#[doc = "< Authenticate mode : WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_PSK: wifi_auth_mode_t = 3;
#[doc = "< Authenticate mode : WPA_WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_WPA2_PSK: wifi_auth_mode_t = 4;
#[doc = "< Authenticate mode : Wi-Fi EAP security, treated the same as WIFI_AUTH_WPA2_ENTERPRISE"]
pub const wifi_auth_mode_t_WIFI_AUTH_ENTERPRISE: wifi_auth_mode_t = 5;
#[doc = "< Authenticate mode : WPA2-Enterprise security"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_ENTERPRISE: wifi_auth_mode_t = 5;
#[doc = "< Authenticate mode : WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_PSK: wifi_auth_mode_t = 6;
#[doc = "< Authenticate mode : WPA2_WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_WPA3_PSK: wifi_auth_mode_t = 7;
#[doc = "< Authenticate mode : WAPI_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WAPI_PSK: wifi_auth_mode_t = 8;
#[doc = "< Authenticate mode : OWE"]
pub const wifi_auth_mode_t_WIFI_AUTH_OWE: wifi_auth_mode_t = 9;
#[doc = "< Authenticate mode : WPA3_ENT_SUITE_B_192_BIT"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_ENT_192: wifi_auth_mode_t = 10;
#[doc = "< This authentication mode will yield same result as WIFI_AUTH_WPA3_PSK and not recommended to be used. It will be deprecated in future, please use WIFI_AUTH_WPA3_PSK instead."]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_EXT_PSK: wifi_auth_mode_t = 11;
#[doc = "< This authentication mode will yield same result as WIFI_AUTH_WPA3_PSK and not recommended to be used. It will be deprecated in future, please use WIFI_AUTH_WPA3_PSK instead."]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_EXT_PSK_MIXED_MODE: wifi_auth_mode_t = 12;
#[doc = "< Authenticate mode : DPP"]
pub const wifi_auth_mode_t_WIFI_AUTH_DPP: wifi_auth_mode_t = 13;
#[doc = "< Authenticate mode : WPA3-Enterprise Only Mode"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_ENTERPRISE: wifi_auth_mode_t = 14;
#[doc = "< Authenticate mode : WPA3-Enterprise Transition Mode"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_WPA3_ENTERPRISE: wifi_auth_mode_t = 15;
#[doc = "< Authenticate mode : WPA-Enterprise security"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_ENTERPRISE: wifi_auth_mode_t = 16;
pub const wifi_auth_mode_t_WIFI_AUTH_MAX: wifi_auth_mode_t = 17;
#[doc = " @brief Wi-Fi authmode type\n Strength of authmodes\n Personal Networks   : OPEN < WEP < WPA_PSK < OWE < WPA2_PSK = WPA_WPA2_PSK < WAPI_PSK < WPA3_PSK = WPA2_WPA3_PSK = DPP\n Enterprise Networks : WIFI_AUTH_WPA_ENTERPRISE < WIFI_AUTH_WPA2_ENTERPRISE < WIFI_AUTH_WPA3_ENTERPRISE = WIFI_AUTH_WPA2_WPA3_ENTERPRISE < WIFI_AUTH_WPA3_ENT_192"]
pub type wifi_auth_mode_t = crate::c_types::c_uint;
#[doc = "< Unspecified reason"]
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED: wifi_err_reason_t = 1;
#[doc = "< Authentication expired"]
pub const wifi_err_reason_t_WIFI_REASON_AUTH_EXPIRE: wifi_err_reason_t = 2;
#[doc = "< Deauthentication due to leaving"]
pub const wifi_err_reason_t_WIFI_REASON_AUTH_LEAVE: wifi_err_reason_t = 3;
#[doc = "< Deprecated, will be removed in next IDF major release"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_EXPIRE: wifi_err_reason_t = 4;
#[doc = "< Disassociated due to inactivity"]
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_DUE_TO_INACTIVITY: wifi_err_reason_t = 4;
#[doc = "< Too many associated stations"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_TOOMANY: wifi_err_reason_t = 5;
#[doc = "< Deprecated, will be removed in next IDF major release"]
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHED: wifi_err_reason_t = 6;
#[doc = "< Class 2 frame received from nonauthenticated STA"]
pub const wifi_err_reason_t_WIFI_REASON_CLASS2_FRAME_FROM_NONAUTH_STA: wifi_err_reason_t = 6;
#[doc = "< Deprecated, will be removed in next IDF major release"]
pub const wifi_err_reason_t_WIFI_REASON_NOT_ASSOCED: wifi_err_reason_t = 7;
#[doc = "< Class 3 frame received from nonassociated STA"]
pub const wifi_err_reason_t_WIFI_REASON_CLASS3_FRAME_FROM_NONASSOC_STA: wifi_err_reason_t = 7;
#[doc = "< Deassociated due to leaving"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_LEAVE: wifi_err_reason_t = 8;
#[doc = "< Association but not authenticated"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_NOT_AUTHED: wifi_err_reason_t = 9;
#[doc = "< Disassociated due to poor power capability"]
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_PWRCAP_BAD: wifi_err_reason_t = 10;
#[doc = "< Disassociated due to unsupported channel"]
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_SUPCHAN_BAD: wifi_err_reason_t = 11;
#[doc = "< Disassociated due to BSS transition"]
pub const wifi_err_reason_t_WIFI_REASON_BSS_TRANSITION_DISASSOC: wifi_err_reason_t = 12;
#[doc = "< Invalid Information Element (IE)"]
pub const wifi_err_reason_t_WIFI_REASON_IE_INVALID: wifi_err_reason_t = 13;
#[doc = "< MIC failure"]
pub const wifi_err_reason_t_WIFI_REASON_MIC_FAILURE: wifi_err_reason_t = 14;
#[doc = "< 4-way handshake timeout"]
pub const wifi_err_reason_t_WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 15;
#[doc = "< Group key update timeout"]
pub const wifi_err_reason_t_WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT: wifi_err_reason_t = 16;
#[doc = "< IE differs in 4-way handshake"]
pub const wifi_err_reason_t_WIFI_REASON_IE_IN_4WAY_DIFFERS: wifi_err_reason_t = 17;
#[doc = "< Invalid group cipher"]
pub const wifi_err_reason_t_WIFI_REASON_GROUP_CIPHER_INVALID: wifi_err_reason_t = 18;
#[doc = "< Invalid pairwise cipher"]
pub const wifi_err_reason_t_WIFI_REASON_PAIRWISE_CIPHER_INVALID: wifi_err_reason_t = 19;
#[doc = "< Invalid AKMP"]
pub const wifi_err_reason_t_WIFI_REASON_AKMP_INVALID: wifi_err_reason_t = 20;
#[doc = "< Unsupported RSN IE version"]
pub const wifi_err_reason_t_WIFI_REASON_UNSUPP_RSN_IE_VERSION: wifi_err_reason_t = 21;
#[doc = "< Invalid RSN IE capabilities"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_RSN_IE_CAP: wifi_err_reason_t = 22;
#[doc = "< 802.1X authentication failed"]
pub const wifi_err_reason_t_WIFI_REASON_802_1X_AUTH_FAILED: wifi_err_reason_t = 23;
#[doc = "< Cipher suite rejected"]
pub const wifi_err_reason_t_WIFI_REASON_CIPHER_SUITE_REJECTED: wifi_err_reason_t = 24;
#[doc = "< TDLS peer unreachable"]
pub const wifi_err_reason_t_WIFI_REASON_TDLS_PEER_UNREACHABLE: wifi_err_reason_t = 25;
#[doc = "< TDLS unspecified"]
pub const wifi_err_reason_t_WIFI_REASON_TDLS_UNSPECIFIED: wifi_err_reason_t = 26;
#[doc = "< SSP requested disassociation"]
pub const wifi_err_reason_t_WIFI_REASON_SSP_REQUESTED_DISASSOC: wifi_err_reason_t = 27;
#[doc = "< No SSP roaming agreement"]
pub const wifi_err_reason_t_WIFI_REASON_NO_SSP_ROAMING_AGREEMENT: wifi_err_reason_t = 28;
#[doc = "< Bad cipher or AKM"]
pub const wifi_err_reason_t_WIFI_REASON_BAD_CIPHER_OR_AKM: wifi_err_reason_t = 29;
#[doc = "< Not authorized in this location"]
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHORIZED_THIS_LOCATION: wifi_err_reason_t = 30;
#[doc = "< Service change precludes TS"]
pub const wifi_err_reason_t_WIFI_REASON_SERVICE_CHANGE_PERCLUDES_TS: wifi_err_reason_t = 31;
#[doc = "< Unspecified QoS reason"]
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED_QOS: wifi_err_reason_t = 32;
#[doc = "< Not enough bandwidth"]
pub const wifi_err_reason_t_WIFI_REASON_NOT_ENOUGH_BANDWIDTH: wifi_err_reason_t = 33;
#[doc = "< Missing ACKs"]
pub const wifi_err_reason_t_WIFI_REASON_MISSING_ACKS: wifi_err_reason_t = 34;
#[doc = "< Exceeded TXOP"]
pub const wifi_err_reason_t_WIFI_REASON_EXCEEDED_TXOP: wifi_err_reason_t = 35;
#[doc = "< Station leaving"]
pub const wifi_err_reason_t_WIFI_REASON_STA_LEAVING: wifi_err_reason_t = 36;
#[doc = "< End of Block Ack (BA)"]
pub const wifi_err_reason_t_WIFI_REASON_END_BA: wifi_err_reason_t = 37;
#[doc = "< Unknown Block Ack (BA)"]
pub const wifi_err_reason_t_WIFI_REASON_UNKNOWN_BA: wifi_err_reason_t = 38;
#[doc = "< Timeout"]
pub const wifi_err_reason_t_WIFI_REASON_TIMEOUT: wifi_err_reason_t = 39;
#[doc = "< Peer initiated disassociation"]
pub const wifi_err_reason_t_WIFI_REASON_PEER_INITIATED: wifi_err_reason_t = 46;
#[doc = "< AP initiated disassociation"]
pub const wifi_err_reason_t_WIFI_REASON_AP_INITIATED: wifi_err_reason_t = 47;
#[doc = "< Invalid FT action frame count"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_FT_ACTION_FRAME_COUNT: wifi_err_reason_t = 48;
#[doc = "< Invalid PMKID"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_PMKID: wifi_err_reason_t = 49;
#[doc = "< Invalid MDE"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_MDE: wifi_err_reason_t = 50;
#[doc = "< Invalid FTE"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_FTE: wifi_err_reason_t = 51;
#[doc = "< Transmission link establishment failed"]
pub const wifi_err_reason_t_WIFI_REASON_TRANSMISSION_LINK_ESTABLISH_FAILED: wifi_err_reason_t = 67;
#[doc = "< Alternative channel occupied"]
pub const wifi_err_reason_t_WIFI_REASON_ALTERATIVE_CHANNEL_OCCUPIED: wifi_err_reason_t = 68;
#[doc = "< Beacon timeout"]
pub const wifi_err_reason_t_WIFI_REASON_BEACON_TIMEOUT: wifi_err_reason_t = 200;
#[doc = "< No AP found"]
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND: wifi_err_reason_t = 201;
#[doc = "< Authentication failed"]
pub const wifi_err_reason_t_WIFI_REASON_AUTH_FAIL: wifi_err_reason_t = 202;
#[doc = "< Association failed"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_FAIL: wifi_err_reason_t = 203;
#[doc = "< Handshake timeout"]
pub const wifi_err_reason_t_WIFI_REASON_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 204;
#[doc = "< Connection failed"]
pub const wifi_err_reason_t_WIFI_REASON_CONNECTION_FAIL: wifi_err_reason_t = 205;
#[doc = "< AP TSF reset"]
pub const wifi_err_reason_t_WIFI_REASON_AP_TSF_RESET: wifi_err_reason_t = 206;
#[doc = "< Roaming"]
pub const wifi_err_reason_t_WIFI_REASON_ROAMING: wifi_err_reason_t = 207;
#[doc = "< Association comeback time too long"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_COMEBACK_TIME_TOO_LONG: wifi_err_reason_t = 208;
#[doc = "< SA query timeout"]
pub const wifi_err_reason_t_WIFI_REASON_SA_QUERY_TIMEOUT: wifi_err_reason_t = 209;
#[doc = "< No AP found with compatible security"]
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND_W_COMPATIBLE_SECURITY: wifi_err_reason_t = 210;
#[doc = "< No AP found in auth mode threshold"]
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND_IN_AUTHMODE_THRESHOLD: wifi_err_reason_t = 211;
#[doc = "< No AP found in RSSI threshold"]
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND_IN_RSSI_THRESHOLD: wifi_err_reason_t = 212;
#[doc = " @brief Wi-Fi disconnection reason codes\n\n These reason codes are used to indicate the cause of disconnection."]
pub type wifi_err_reason_t = crate::c_types::c_uint;
#[doc = "< The channel width is HT20"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_NONE: wifi_second_chan_t = 0;
#[doc = "< The channel width is HT40 and the secondary channel is above the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_ABOVE: wifi_second_chan_t = 1;
#[doc = "< The channel width is HT40 and the secondary channel is below the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_BELOW: wifi_second_chan_t = 2;
#[doc = " @brief Wi-Fi second channel type"]
pub type wifi_second_chan_t = crate::c_types::c_uint;
#[doc = "< Active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< Passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
#[doc = " @brief Wi-Fi scan type"]
pub type wifi_scan_type_t = crate::c_types::c_uint;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< Minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< Maximum active scan time per channel, units: millisecond, values above 1500 ms may\ncause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_time_t {
    #[doc = "< Active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< Passive scan time per channel, units: millisecond, values above 1500 ms may\ncause station to disconnect from AP and are not recommended."]
    pub passive: u32,
}
#[doc = " @brief Channel bitmap for setting specific channels to be scanned"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_channel_bitmap_t {
    #[doc = "< Represents 2.4 GHz channels, that bits can be set as wifi_2g_channel_bit_t shown."]
    pub ghz_2_channels: u16,
    #[doc = "< Represents 5 GHz channels, that bits can be set as wifi_5g_channel_bit_t shown."]
    pub ghz_5_channels: u32,
}
#[doc = " @brief Parameters for an SSID scan"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_config_t {
    #[doc = "< SSID of AP"]
    pub ssid: *mut u8,
    #[doc = "< MAC address of AP"]
    pub bssid: *mut u8,
    #[doc = "< Channel, scan the specific channel"]
    pub channel: u8,
    #[doc = "< Enable it to scan AP whose SSID is hidden"]
    pub show_hidden: bool,
    #[doc = "< Scan type, active or passive"]
    pub scan_type: wifi_scan_type_t,
    #[doc = "< Scan time per channel"]
    pub scan_time: wifi_scan_time_t,
    #[doc = "< Time spent at home channel between scanning consecutive channels."]
    pub home_chan_dwell_time: u8,
    #[doc = "< Channel bitmap for setting specific channels to be scanned.\nPlease note that the 'channel' parameter above needs to be set to 0 to allow scanning by bitmap.\nAlso, note that only allowed channels configured by wifi_country_t can be scanned."]
    pub channel_bitmap: wifi_scan_channel_bitmap_t,
    #[doc = "< Enable it to scan return home channel under coexist"]
    pub coex_background_scan: bool,
}
#[doc = " @brief Parameters default scan configurations"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_default_params_t {
    #[doc = "< Scan time per channel"]
    pub scan_time: wifi_scan_time_t,
    #[doc = "< Time spent at home channel between scanning consecutive channels."]
    pub home_chan_dwell_time: u8,
}
#[doc = "< The cipher type is none"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_NONE: wifi_cipher_type_t = 0;
#[doc = "< The cipher type is WEP40"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP40: wifi_cipher_type_t = 1;
#[doc = "< The cipher type is WEP104"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP104: wifi_cipher_type_t = 2;
#[doc = "< The cipher type is TKIP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP: wifi_cipher_type_t = 3;
#[doc = "< The cipher type is CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_CCMP: wifi_cipher_type_t = 4;
#[doc = "< The cipher type is TKIP and CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP_CCMP: wifi_cipher_type_t = 5;
#[doc = "< The cipher type is AES-CMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_CMAC128: wifi_cipher_type_t = 6;
#[doc = "< The cipher type is SMS4"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_SMS4: wifi_cipher_type_t = 7;
#[doc = "< The cipher type is GCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_GCMP: wifi_cipher_type_t = 8;
#[doc = "< The cipher type is GCMP-256"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_GCMP256: wifi_cipher_type_t = 9;
#[doc = "< The cipher type is AES-GMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_GMAC128: wifi_cipher_type_t = 10;
#[doc = "< The cipher type is AES-GMAC-256"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_GMAC256: wifi_cipher_type_t = 11;
#[doc = "< The cipher type is unknown"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_UNKNOWN: wifi_cipher_type_t = 12;
#[doc = " @brief Wi-Fi cipher type"]
pub type wifi_cipher_type_t = crate::c_types::c_uint;
#[doc = "< Bandwidth is HT20"]
pub const wifi_bandwidth_t_WIFI_BW_HT20: wifi_bandwidth_t = 1;
#[doc = "< Bandwidth is 20 MHz"]
pub const wifi_bandwidth_t_WIFI_BW20: wifi_bandwidth_t = 1;
#[doc = "< Bandwidth is HT40"]
pub const wifi_bandwidth_t_WIFI_BW_HT40: wifi_bandwidth_t = 2;
#[doc = "< Bandwidth is 40 MHz"]
pub const wifi_bandwidth_t_WIFI_BW40: wifi_bandwidth_t = 2;
#[doc = "< Bandwidth is 80 MHz"]
pub const wifi_bandwidth_t_WIFI_BW80: wifi_bandwidth_t = 3;
#[doc = "< Bandwidth is 160 MHz"]
pub const wifi_bandwidth_t_WIFI_BW160: wifi_bandwidth_t = 4;
#[doc = "< Bandwidth is 80 + 80 MHz"]
pub const wifi_bandwidth_t_WIFI_BW80_BW80: wifi_bandwidth_t = 5;
#[doc = " @brief Wi-Fi bandwidth type"]
pub type wifi_bandwidth_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi antenna 0"]
pub const wifi_ant_t_WIFI_ANT_ANT0: wifi_ant_t = 0;
#[doc = "< Wi-Fi antenna 1"]
pub const wifi_ant_t_WIFI_ANT_ANT1: wifi_ant_t = 1;
#[doc = "< Invalid Wi-Fi antenna"]
pub const wifi_ant_t_WIFI_ANT_MAX: wifi_ant_t = 2;
#[doc = " @brief Wi-Fi antenna"]
pub type wifi_ant_t = crate::c_types::c_uint;
#[doc = " @brief Description of a Wi-Fi AP HE Info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_he_ap_info_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< In a M-BSSID set, identifies the non-transmitted BSSID"]
    pub bssid_index: u8,
}
impl wifi_he_ap_info_t {
    #[inline]
    pub fn bss_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_bss_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn partial_bss_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_partial_bss_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bss_color_disabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bss_color_disabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bss_color: u8,
        partial_bss_color: u8,
        bss_color_disabled: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let bss_color: u8 = unsafe { ::core::mem::transmute(bss_color) };
            bss_color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let partial_bss_color: u8 = unsafe { ::core::mem::transmute(partial_bss_color) };
            partial_bss_color as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bss_color_disabled: u8 = unsafe { ::core::mem::transmute(bss_color_disabled) };
            bss_color_disabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Description of a Wi-Fi AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_record_t {
    #[doc = "< MAC address of AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 33usize],
    #[doc = "< Channel of AP"]
    pub primary: u8,
    #[doc = "< Secondary channel of AP"]
    pub second: wifi_second_chan_t,
    #[doc = "< Signal strength of AP. Note that in some rare cases where signal strength is very strong, RSSI values can be slightly positive"]
    pub rssi: i8,
    #[doc = "< Auth mode of AP"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Pairwise cipher of AP"]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< Group cipher of AP"]
    pub group_cipher: wifi_cipher_type_t,
    #[doc = "< Antenna used to receive beacon from AP"]
    pub ant: wifi_ant_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Country information of AP"]
    pub country: wifi_country_t,
    #[doc = "< HE AP info"]
    pub he_ap: wifi_he_ap_info_t,
    #[doc = "< Bandwidth of AP"]
    pub bandwidth: wifi_bandwidth_t,
    #[doc = "< This fields are used only AP bandwidth is 80 and 160 MHz, to transmit the center channel\nfrequency of the BSS. For AP bandwidth is 80 + 80 MHz, it is the center channel frequency\nof the lower frequency segment."]
    pub vht_ch_freq1: u8,
    #[doc = "< this fields are used only AP bandwidth is 80 + 80 MHz, and is used to transmit the center\nchannel frequency of the second segment."]
    pub vht_ch_freq2: u8,
}
impl wifi_ap_record_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11a(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11a(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ax(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ax(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ftm_responder(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ftm_responder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ftm_initiator(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ftm_initiator(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        phy_11a: u32,
        phy_11ac: u32,
        phy_11ax: u32,
        wps: u32,
        ftm_responder: u32,
        ftm_initiator: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let phy_11a: u32 = unsafe { ::core::mem::transmute(phy_11a) };
            phy_11a as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let phy_11ac: u32 = unsafe { ::core::mem::transmute(phy_11ac) };
            phy_11ac as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let phy_11ax: u32 = unsafe { ::core::mem::transmute(phy_11ax) };
            phy_11ax as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ftm_responder: u32 = unsafe { ::core::mem::transmute(ftm_responder) };
            ftm_responder as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ftm_initiator: u32 = unsafe { ::core::mem::transmute(ftm_initiator) };
            ftm_initiator as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Do fast scan, scan will end after find SSID match AP"]
pub const wifi_scan_method_t_WIFI_FAST_SCAN: wifi_scan_method_t = 0;
#[doc = "< All channel scan, scan will end after scan all the channel"]
pub const wifi_scan_method_t_WIFI_ALL_CHANNEL_SCAN: wifi_scan_method_t = 1;
#[doc = " @brief Wi-Fi scan method"]
pub type wifi_scan_method_t = crate::c_types::c_uint;
#[doc = "< Sort match AP in scan list by RSSI"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SIGNAL: wifi_sort_method_t = 0;
#[doc = "< Sort match AP in scan list by security mode"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SECURITY: wifi_sort_method_t = 1;
#[doc = " @brief Wi-Fi sort AP method"]
pub type wifi_sort_method_t = crate::c_types::c_uint;
#[doc = " @brief Structure describing parameters for a Wi-Fi fast scan"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_threshold_t {
    #[doc = "< The minimum rssi to accept in the fast scan mode. Defaults to -127 if set to >= 0"]
    pub rssi: i8,
    #[doc = "< The weakest auth mode to accept in the fast scan mode\nNote: In case this value is not set and password is set as per WPA2 standards(password len >= 8), it will be defaulted to WPA2 and device won't connect to deprecated WEP/WPA networks. Please set auth mode threshold as WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK to connect to WEP/WPA networks"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< The RSSI value of the 5G AP is within the rssi_5g_adjustment range compared to the 2G AP, the 5G AP will be given priority for connection."]
    pub rssi_5g_adjustment: u8,
}
#[doc = "< No power save"]
pub const wifi_ps_type_t_WIFI_PS_NONE: wifi_ps_type_t = 0;
#[doc = "< Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period"]
pub const wifi_ps_type_t_WIFI_PS_MIN_MODEM: wifi_ps_type_t = 1;
#[doc = "< Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t"]
pub const wifi_ps_type_t_WIFI_PS_MAX_MODEM: wifi_ps_type_t = 2;
#[doc = " @brief Wi-Fi power save type"]
pub type wifi_ps_type_t = crate::c_types::c_uint;
#[doc = "< Band is 2.4 GHz"]
pub const wifi_band_t_WIFI_BAND_2G: wifi_band_t = 1;
#[doc = "< Band is 5 GHz"]
pub const wifi_band_t_WIFI_BAND_5G: wifi_band_t = 2;
#[doc = " @brief Argument structure for Wi-Fi band"]
pub type wifi_band_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi band mode is 2.4 GHz only"]
pub const wifi_band_mode_t_WIFI_BAND_MODE_2G_ONLY: wifi_band_mode_t = 1;
#[doc = "< Wi-Fi band mode is 5 GHz only"]
pub const wifi_band_mode_t_WIFI_BAND_MODE_5G_ONLY: wifi_band_mode_t = 2;
#[doc = "< Wi-Fi band mode is 2.4 GHz + 5 GHz"]
pub const wifi_band_mode_t_WIFI_BAND_MODE_AUTO: wifi_band_mode_t = 3;
#[doc = " @brief Argument structure for Wi-Fi band mode"]
pub type wifi_band_mode_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi channel 1"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_1: wifi_2g_channel_bit_t = 2;
#[doc = "< Wi-Fi channel 2"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_2: wifi_2g_channel_bit_t = 4;
#[doc = "< Wi-Fi channel 3"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_3: wifi_2g_channel_bit_t = 8;
#[doc = "< Wi-Fi channel 4"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_4: wifi_2g_channel_bit_t = 16;
#[doc = "< Wi-Fi channel 5"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_5: wifi_2g_channel_bit_t = 32;
#[doc = "< Wi-Fi channel 6"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_6: wifi_2g_channel_bit_t = 64;
#[doc = "< Wi-Fi channel 7"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_7: wifi_2g_channel_bit_t = 128;
#[doc = "< Wi-Fi channel 8"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_8: wifi_2g_channel_bit_t = 256;
#[doc = "< Wi-Fi channel 9"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_9: wifi_2g_channel_bit_t = 512;
#[doc = "< Wi-Fi channel 10"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_10: wifi_2g_channel_bit_t = 1024;
#[doc = "< Wi-Fi channel 11"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_11: wifi_2g_channel_bit_t = 2048;
#[doc = "< Wi-Fi channel 12"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_12: wifi_2g_channel_bit_t = 4096;
#[doc = "< Wi-Fi channel 13"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_13: wifi_2g_channel_bit_t = 8192;
#[doc = "< Wi-Fi channel 14"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_14: wifi_2g_channel_bit_t = 16384;
#[doc = " Argument structure for 2.4G channels"]
pub type wifi_2g_channel_bit_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi channel 36"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_36: wifi_5g_channel_bit_t = 2;
#[doc = "< Wi-Fi channel 40"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_40: wifi_5g_channel_bit_t = 4;
#[doc = "< Wi-Fi channel 44"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_44: wifi_5g_channel_bit_t = 8;
#[doc = "< Wi-Fi channel 48"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_48: wifi_5g_channel_bit_t = 16;
#[doc = "< Wi-Fi channel 52"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_52: wifi_5g_channel_bit_t = 32;
#[doc = "< Wi-Fi channel 56"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_56: wifi_5g_channel_bit_t = 64;
#[doc = "< Wi-Fi channel 60"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_60: wifi_5g_channel_bit_t = 128;
#[doc = "< Wi-Fi channel 64"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_64: wifi_5g_channel_bit_t = 256;
#[doc = "< Wi-Fi channel 100"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_100: wifi_5g_channel_bit_t = 512;
#[doc = "< Wi-Fi channel 104"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_104: wifi_5g_channel_bit_t = 1024;
#[doc = "< Wi-Fi channel 108"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_108: wifi_5g_channel_bit_t = 2048;
#[doc = "< Wi-Fi channel 112"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_112: wifi_5g_channel_bit_t = 4096;
#[doc = "< Wi-Fi channel 116"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_116: wifi_5g_channel_bit_t = 8192;
#[doc = "< Wi-Fi channel 120"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_120: wifi_5g_channel_bit_t = 16384;
#[doc = "< Wi-Fi channel 124"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_124: wifi_5g_channel_bit_t = 32768;
#[doc = "< Wi-Fi channel 128"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_128: wifi_5g_channel_bit_t = 65536;
#[doc = "< Wi-Fi channel 132"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_132: wifi_5g_channel_bit_t = 131072;
#[doc = "< Wi-Fi channel 136"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_136: wifi_5g_channel_bit_t = 262144;
#[doc = "< Wi-Fi channel 140"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_140: wifi_5g_channel_bit_t = 524288;
#[doc = "< Wi-Fi channel 144"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_144: wifi_5g_channel_bit_t = 1048576;
#[doc = "< Wi-Fi channel 149"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_149: wifi_5g_channel_bit_t = 2097152;
#[doc = "< Wi-Fi channel 153"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_153: wifi_5g_channel_bit_t = 4194304;
#[doc = "< Wi-Fi channel 157"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_157: wifi_5g_channel_bit_t = 8388608;
#[doc = "< Wi-Fi channel 161"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_161: wifi_5g_channel_bit_t = 16777216;
#[doc = "< Wi-Fi channel 165"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_165: wifi_5g_channel_bit_t = 33554432;
#[doc = "< Wi-Fi channel 169"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_169: wifi_5g_channel_bit_t = 67108864;
#[doc = "< Wi-Fi channel 173"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_173: wifi_5g_channel_bit_t = 134217728;
#[doc = "< Wi-Fi channel 177"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_177: wifi_5g_channel_bit_t = 268435456;
#[doc = " Argument structure for 5G channels"]
pub type wifi_5g_channel_bit_t = crate::c_types::c_uint;
#[doc = " @brief Description of a Wi-Fi protocols"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_protocols_t {
    #[doc = "< Represents 2.4 GHz protocol, support 802.11b or 802.11g or 802.11n or 802.11ax or LR mode"]
    pub ghz_2g: u16,
    #[doc = "< Represents 5 GHz protocol, support 802.11a or 802.11n or 802.11ac or 802.11ax"]
    pub ghz_5g: u16,
}
#[doc = " @brief Description of a Wi-Fi band bandwidths"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_bandwidths_t {
    #[doc = "< Represents 2.4 GHz bandwidth"]
    pub ghz_2g: wifi_bandwidth_t,
    #[doc = "< Represents 5 GHz bandwidth"]
    pub ghz_5g: wifi_bandwidth_t,
}
#[doc = " @brief Configuration structure for Protected Management Frame"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_pmf_config_t {
    #[doc = "< Deprecated variable. Device will always connect in PMF mode if other device also advertises PMF capability."]
    pub capable: bool,
    #[doc = "< Advertises that Protected Management Frame is required. Device will not associate to non-PMF capable devices."]
    pub required: bool,
}
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_UNSPECIFIED: wifi_sae_pwe_method_t = 0;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_HUNT_AND_PECK: wifi_sae_pwe_method_t = 1;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_HASH_TO_ELEMENT: wifi_sae_pwe_method_t = 2;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_BOTH: wifi_sae_pwe_method_t = 3;
#[doc = " @brief Configuration for SAE PWE derivation"]
pub type wifi_sae_pwe_method_t = crate::c_types::c_uint;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_AUTOMATIC: wifi_sae_pk_mode_t = 0;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_ONLY: wifi_sae_pk_mode_t = 1;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_DISABLED: wifi_sae_pk_mode_t = 2;
#[doc = " @brief Configuration for SAE-PK"]
pub type wifi_sae_pk_mode_t = crate::c_types::c_uint;
#[doc = " @brief Configuration structure for BSS max idle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_bss_max_idle_config_t {
    #[doc = "< Sets BSS Max idle period (1 Unit = 1000TUs OR 1.024 Seconds). If there are no frames for this period from a STA, SoftAP will disassociate due to inactivity. Setting it to 0 disables the feature"]
    pub period: u16,
    #[doc = "< Requires clients to use protected keep alive frames for BSS Max Idle period"]
    pub protected_keep_alive: bool,
}
#[doc = " @brief Soft-AP configuration settings for the device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_config_t {
    #[doc = "< SSID of soft-AP. If ssid_len field is 0, this must be a Null terminated string. Otherwise, length is set according to ssid_len."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of soft-AP."]
    pub password: [u8; 64usize],
    #[doc = "< Optional length of SSID field."]
    pub ssid_len: u8,
    #[doc = "< Channel of soft-AP"]
    pub channel: u8,
    #[doc = "< Auth mode of soft-AP. Do not support AUTH_WEP, AUTH_WAPI_PSK and AUTH_OWE in soft-AP mode. When the auth mode is set to WPA2_PSK, WPA2_WPA3_PSK or WPA3_PSK, the pairwise cipher will be overwritten with WIFI_CIPHER_TYPE_CCMP by default, unless explicitly set."]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Broadcast SSID or not, default 0, broadcast the SSID"]
    pub ssid_hidden: u8,
    #[doc = "< Max number of stations allowed to connect in"]
    pub max_connection: u8,
    #[doc = "< Beacon interval which should be multiples of 100. Unit: TU(time unit, 1 TU = 1024 us). Range: 100 ~ 60000. Default value: 100"]
    pub beacon_interval: u16,
    #[doc = "< Channel Switch Announcement Count. Notify the station that the channel will switch after the csa_count beacon intervals. Default value: 3"]
    pub csa_count: u8,
    #[doc = "< Dtim period of soft-AP. Range: 1 ~ 10. Default value: 1"]
    pub dtim_period: u8,
    #[doc = "< Pairwise cipher of SoftAP, group cipher will be derived using this. Cipher values are valid starting from WIFI_CIPHER_TYPE_TKIP, enum values before that will be considered as invalid and default cipher suites(TKIP+CCMP) will be used. Valid cipher suites in softAP mode are WIFI_CIPHER_TYPE_TKIP, WIFI_CIPHER_TYPE_CCMP, WIFI_CIPHER_TYPE_TKIP_CCMP, WIFI_CIPHER_TYPE_GCMP and WIFI_CIPHER_TYPE_GCMP256."]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< Enable FTM Responder mode"]
    pub ftm_responder: bool,
    #[doc = "< Configuration for Protected Management Frame"]
    pub pmf_cfg: wifi_pmf_config_t,
    #[doc = "< Configuration for SAE PWE derivation method"]
    pub sae_pwe_h2e: wifi_sae_pwe_method_t,
    #[doc = "< Whether to enable transition disable feature"]
    pub transition_disable: u8,
    #[doc = "< Enable SAE EXT feature. SOC_GCMP_SUPPORT is required for this feature."]
    pub sae_ext: u8,
    #[doc = "< Configuration for bss max idle, effective if CONFIG_WIFI_BSS_MAX_IDLE_SUPPORT is enabled"]
    pub bss_max_idle_cfg: wifi_bss_max_idle_config_t,
    #[doc = "< GTK rekeying interval in seconds. If set to 0, GTK rekeying is disabled. Range: 60 ~ 65535 including 0."]
    pub gtk_rekey_interval: u16,
}
#[doc = " @brief STA configuration settings for the device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_config_t {
    #[doc = "< SSID of target AP."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of target AP."]
    pub password: [u8; 64usize],
    #[doc = "< Do all channel scan or fast scan"]
    pub scan_method: wifi_scan_method_t,
    #[doc = "< Whether set MAC address of target AP or not. Generally, station_config.bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< Channel hint for target AP. For 2.4G AP, set to 1~13 to scan starting from the specified channel before connecting to AP. For 5G AP, set to 36~177 (36, 40, 44 ... 177) to scan starting from the specified channel before connecting to AP. Set to 0 for no preference"]
    pub channel: u8,
    #[doc = "< Listen interval for ESP32 station to receive beacon when WIFI_PS_MAX_MODEM is set. Units: AP beacon intervals. Defaults to 3 if set to 0."]
    pub listen_interval: u16,
    #[doc = "< Sort the connect AP in the list by rssi or security mode"]
    pub sort_method: wifi_sort_method_t,
    #[doc = "< When scan_threshold is set, only APs which have an auth mode that is more secure than the selected auth mode and a signal stronger than the minimum RSSI will be used."]
    pub threshold: wifi_scan_threshold_t,
    #[doc = "< Configuration for Protected Management Frame. Will be advertised in RSN Capabilities in RSN IE."]
    pub pmf_cfg: wifi_pmf_config_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Configuration for SAE PWE derivation method"]
    pub sae_pwe_h2e: wifi_sae_pwe_method_t,
    #[doc = "< Configuration for SAE-PK (Public Key) Authentication method"]
    pub sae_pk_mode: wifi_sae_pk_mode_t,
    #[doc = "< Number of connection retries station will do before moving to next AP. scan_method should be set as WIFI_ALL_CHANNEL_SCAN to use this config.\nNote: Enabling this may cause connection time to increase in case best AP doesn't behave properly."]
    pub failure_retry_cnt: u8,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Password identifier for H2E. this needs to be null terminated string"]
    pub sae_h2e_identifier: [u8; 32usize],
}
impl wifi_sta_config_t {
    #[inline]
    pub fn rm_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rm_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btm_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_btm_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbo_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mbo_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ft_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ft_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn owe_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_owe_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transition_disable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transition_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rm_enabled: u32,
        btm_enabled: u32,
        mbo_enabled: u32,
        ft_enabled: u32,
        owe_enabled: u32,
        transition_disable: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rm_enabled: u32 = unsafe { ::core::mem::transmute(rm_enabled) };
            rm_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let btm_enabled: u32 = unsafe { ::core::mem::transmute(btm_enabled) };
            btm_enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mbo_enabled: u32 = unsafe { ::core::mem::transmute(mbo_enabled) };
            mbo_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ft_enabled: u32 = unsafe { ::core::mem::transmute(ft_enabled) };
            ft_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let owe_enabled: u32 = unsafe { ::core::mem::transmute(owe_enabled) };
            owe_enabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let transition_disable: u32 = unsafe { ::core::mem::transmute(transition_disable) };
            transition_disable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn he_dcm_set(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_dcm_max_constellation_tx(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_max_constellation_tx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn he_dcm_max_constellation_rx(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_max_constellation_rx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn he_mcs9_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_mcs9_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_su_beamformee_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_su_beamformee_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_su_bmforming_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_su_bmforming_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_mu_bmforming_partial_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_mu_bmforming_partial_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_cqi_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_cqi_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vht_su_beamformee_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vht_su_beamformee_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vht_mu_beamformee_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vht_mu_beamformee_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vht_mcs8_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vht_mcs8_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        he_dcm_set: u32,
        he_dcm_max_constellation_tx: u32,
        he_dcm_max_constellation_rx: u32,
        he_mcs9_enabled: u32,
        he_su_beamformee_disabled: u32,
        he_trig_su_bmforming_feedback_disabled: u32,
        he_trig_mu_bmforming_partial_feedback_disabled: u32,
        he_trig_cqi_feedback_disabled: u32,
        vht_su_beamformee_disabled: u32,
        vht_mu_beamformee_disabled: u32,
        vht_mcs8_enabled: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let he_dcm_set: u32 = unsafe { ::core::mem::transmute(he_dcm_set) };
            he_dcm_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let he_dcm_max_constellation_tx: u32 =
                unsafe { ::core::mem::transmute(he_dcm_max_constellation_tx) };
            he_dcm_max_constellation_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let he_dcm_max_constellation_rx: u32 =
                unsafe { ::core::mem::transmute(he_dcm_max_constellation_rx) };
            he_dcm_max_constellation_rx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let he_mcs9_enabled: u32 = unsafe { ::core::mem::transmute(he_mcs9_enabled) };
            he_mcs9_enabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let he_su_beamformee_disabled: u32 =
                unsafe { ::core::mem::transmute(he_su_beamformee_disabled) };
            he_su_beamformee_disabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let he_trig_su_bmforming_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_su_bmforming_feedback_disabled) };
            he_trig_su_bmforming_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let he_trig_mu_bmforming_partial_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_mu_bmforming_partial_feedback_disabled) };
            he_trig_mu_bmforming_partial_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let he_trig_cqi_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_cqi_feedback_disabled) };
            he_trig_cqi_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let vht_su_beamformee_disabled: u32 =
                unsafe { ::core::mem::transmute(vht_su_beamformee_disabled) };
            vht_su_beamformee_disabled as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let vht_mu_beamformee_disabled: u32 =
                unsafe { ::core::mem::transmute(vht_mu_beamformee_disabled) };
            vht_mu_beamformee_disabled as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let vht_mcs8_enabled: u32 = unsafe { ::core::mem::transmute(vht_mcs8_enabled) };
            vht_mcs8_enabled as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Discovery start configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_config_t {
    #[doc = "< NAN Discovery operating channel"]
    pub op_channel: u8,
    #[doc = "< Device's preference value to serve as NAN Master"]
    pub master_pref: u8,
    #[doc = "< Scan time in seconds while searching for a NAN cluster"]
    pub scan_time: u8,
    #[doc = "< Warm up time before assuming NAN Anchor Master role"]
    pub warm_up_sec: u16,
}
#[doc = " @brief Configuration data for device's AP or STA or NAN.\n\n The usage of this union (for ap, sta or nan configuration) is determined by the accompanying\n interface argument passed to esp_wifi_set_config() or esp_wifi_get_config()\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_config_t {
    #[doc = "< Configuration of AP"]
    pub ap: wifi_ap_config_t,
    #[doc = "< Configuration of STA"]
    pub sta: wifi_sta_config_t,
    #[doc = "< Configuration of NAN"]
    pub nan: wifi_nan_config_t,
}
#[doc = " @brief Description of STA associated with AP"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wifi_sta_info_t {
    #[doc = "< MAC address"]
    pub mac: [u8; 6usize],
    #[doc = "< Current average rssi of sta connected"]
    pub rssi: i8,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wifi_sta_info_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11a(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11a(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ax(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ax(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mesh_child(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mesh_child(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        phy_11a: u32,
        phy_11ac: u32,
        phy_11ax: u32,
        is_mesh_child: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let phy_11a: u32 = unsafe { ::core::mem::transmute(phy_11a) };
            phy_11a as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let phy_11ac: u32 = unsafe { ::core::mem::transmute(phy_11ac) };
            phy_11ac as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let phy_11ax: u32 = unsafe { ::core::mem::transmute(phy_11ax) };
            phy_11ax as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_mesh_child: u32 = unsafe { ::core::mem::transmute(is_mesh_child) };
            is_mesh_child as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< All configuration will store in both memory and flash"]
pub const wifi_storage_t_WIFI_STORAGE_FLASH: wifi_storage_t = 0;
#[doc = "< All configuration will only store in the memory"]
pub const wifi_storage_t_WIFI_STORAGE_RAM: wifi_storage_t = 1;
#[doc = " @brief Wi-Fi storage type"]
pub type wifi_storage_t = crate::c_types::c_uint;
#[doc = "< Beacon frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_BEACON: wifi_vendor_ie_type_t = 0;
#[doc = "< Probe request frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_REQ: wifi_vendor_ie_type_t = 1;
#[doc = "< Probe response frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_RESP: wifi_vendor_ie_type_t = 2;
#[doc = "< Association request frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_REQ: wifi_vendor_ie_type_t = 3;
#[doc = "< Association response frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_RESP: wifi_vendor_ie_type_t = 4;
#[doc = " @brief     Vendor Information Element type\n\n Determines the frame type that the IE will be associated with."]
pub type wifi_vendor_ie_type_t = crate::c_types::c_uint;
#[doc = "< Vendor ID element 0"]
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_0: wifi_vendor_ie_id_t = 0;
#[doc = "< Vendor ID element 1"]
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_1: wifi_vendor_ie_id_t = 1;
#[doc = " @brief     Vendor Information Element index\n\n Each IE type can have up to two associated vendor ID elements."]
pub type wifi_vendor_ie_id_t = crate::c_types::c_uint;
#[doc = "< PHY mode for Low Rate"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_LR: wifi_phy_mode_t = 0;
#[doc = "< PHY mode for 11b"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_11B: wifi_phy_mode_t = 1;
#[doc = "< PHY mode for 11g"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_11G: wifi_phy_mode_t = 2;
#[doc = "< PHY mode for 11a"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_11A: wifi_phy_mode_t = 3;
#[doc = "< PHY mode for Bandwidth HT20"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HT20: wifi_phy_mode_t = 4;
#[doc = "< PHY mode for Bandwidth HT40"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HT40: wifi_phy_mode_t = 5;
#[doc = "< PHY mode for Bandwidth HE20"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HE20: wifi_phy_mode_t = 6;
#[doc = "< PHY mode for Bandwidth VHT20"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_VHT20: wifi_phy_mode_t = 7;
#[doc = " @brief     Operation PHY mode"]
pub type wifi_phy_mode_t = crate::c_types::c_uint;
#[doc = " @brief Vendor Information Element header\n\n The first bytes of the Information Element will match this header. Payload follows."]
#[repr(C)]
pub struct vendor_ie_data_t {
    #[doc = "< Should be set to WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    pub element_id: u8,
    #[doc = "< Length of all bytes in the element data following this field. Minimum 4."]
    pub length: u8,
    #[doc = "< Vendor identifier (OUI)."]
    pub vendor_oui: [u8; 3usize],
    #[doc = "< Vendor-specific OUI type."]
    pub vendor_oui_type: u8,
    #[doc = "< Payload. Length is equal to value in 'length' field, minus 4."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = "< Management frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MGMT: wifi_promiscuous_pkt_type_t = 0;
#[doc = "< Control frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_CTRL: wifi_promiscuous_pkt_type_t = 1;
#[doc = "< Data frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_DATA: wifi_promiscuous_pkt_type_t = 2;
#[doc = "< Other type, such as MIMO etc. 'buf' argument is wifi_promiscuous_pkt_t but the payload is zero length."]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MISC: wifi_promiscuous_pkt_type_t = 3;
#[doc = " @brief Promiscuous frame type\n\n Passed to promiscuous mode RX callback to indicate the type of parameter in the buffer.\n"]
pub type wifi_promiscuous_pkt_type_t = crate::c_types::c_uint;
#[doc = " @brief Mask for filtering different packet types in promiscuous mode"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_promiscuous_filter_t {
    #[doc = "< OR of one or more filter values WIFI_PROMIS_FILTER_*"]
    pub filter_mask: u32,
}
#[doc = " @brief Wi-Fi GPIO configuration for antenna selection\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_ant_gpio_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl wifi_ant_gpio_t {
    #[inline]
    pub fn gpio_select(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_select(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_num(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_num(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gpio_select: u8, gpio_num: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpio_select: u8 = unsafe { ::core::mem::transmute(gpio_select) };
            gpio_select as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let gpio_num: u8 = unsafe { ::core::mem::transmute(gpio_num) };
            gpio_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Wi-Fi GPIOs configuration for antenna selection\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ant_gpio_config_t {
    #[doc = "< The configurations of GPIOs that connect to external antenna switch"]
    pub gpio_cfg: [wifi_ant_gpio_t; 4usize],
}
#[doc = "< Enable Wi-Fi antenna 0 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT0: wifi_ant_mode_t = 0;
#[doc = "< Enable Wi-Fi antenna 1 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT1: wifi_ant_mode_t = 1;
#[doc = "< Enable Wi-Fi antenna 0 and 1, automatically select an antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_AUTO: wifi_ant_mode_t = 2;
#[doc = "< Invalid Wi-Fi enabled antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_MAX: wifi_ant_mode_t = 3;
#[doc = " @brief Wi-Fi antenna mode\n"]
pub type wifi_ant_mode_t = crate::c_types::c_uint;
#[doc = " @brief Wi-Fi antenna configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ant_config_t {
    #[doc = "< Wi-Fi antenna mode for receiving"]
    pub rx_ant_mode: wifi_ant_mode_t,
    #[doc = "< Default antenna mode for receiving, it's ignored if rx_ant_mode is not WIFI_ANT_MODE_AUTO"]
    pub rx_ant_default: wifi_ant_t,
    #[doc = "< Wi-Fi antenna mode for transmission, it can be set to WIFI_ANT_MODE_AUTO only if rx_ant_mode is set to WIFI_ANT_MODE_AUTO"]
    pub tx_ant_mode: wifi_ant_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl wifi_ant_config_t {
    #[inline]
    pub fn enabled_ant0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled_ant1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled_ant0: u8,
        enabled_ant1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let enabled_ant0: u8 = unsafe { ::core::mem::transmute(enabled_ant0) };
            enabled_ant0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let enabled_ant1: u8 = unsafe { ::core::mem::transmute(enabled_ant1) };
            enabled_ant1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief     The Rx callback function of Action Tx operations\n\n @param     hdr Pointer to the IEEE 802.11 Header structure\n @param     payload Pointer to the Payload following 802.11 Header\n @param     len Length of the Payload\n @param     channel Channel number the frame is received on\n"]
pub type wifi_action_rx_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        hdr: *mut u8,
        payload: *mut u8,
        len: usize,
        channel: u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Action Frame Tx Request"]
#[repr(C)]
pub struct wifi_action_tx_req_t {
    #[doc = "< Wi-Fi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< Destination MAC address"]
    pub dest_mac: [u8; 6usize],
    #[doc = "< ACTION TX operation type"]
    pub type_: wifi_action_tx_t,
    #[doc = "< Channel on which to perform ACTION TX Operation"]
    pub channel: u8,
    #[doc = "< Duration to wait for on target channel"]
    pub wait_time_ms: u32,
    #[doc = "< Indicates no ack required"]
    pub no_ack: bool,
    #[doc = "< Rx Callback to receive action frames"]
    pub rx_cb: wifi_action_rx_cb_t,
    #[doc = "< Unique Identifier for operation provided by wifi driver"]
    pub op_id: u8,
    #[doc = "< Length of the appended Data"]
    pub data_len: u32,
    #[doc = "< Appended Data payload"]
    pub data: __IncompleteArrayField<u8>,
}
#[doc = "< ROC operation was completed successfully"]
pub const wifi_roc_done_status_t_WIFI_ROC_DONE: wifi_roc_done_status_t = 0;
#[doc = "< ROC operation was cancelled"]
pub const wifi_roc_done_status_t_WIFI_ROC_FAIL: wifi_roc_done_status_t = 1;
#[doc = " Status codes for WIFI_EVENT_ROC_DONE evt"]
pub type wifi_roc_done_status_t = crate::c_types::c_uint;
#[doc = " @brief     The callback function executed when ROC operation has ended\n\n @param     context rxcb registered for the corresponding ROC operation\n @param     op_id  ID of the corresponding ROC operation\n @param     status status code of the ROC operation denoted\n"]
pub type wifi_action_roc_done_cb_t = ::core::option::Option<
    unsafe extern "C" fn(context: u32, op_id: u8, status: wifi_roc_done_status_t),
>;
#[doc = " @brief Remain on Channel request\n\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_roc_req_t {
    #[doc = "< WiFi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< ROC operation type"]
    pub type_: wifi_roc_t,
    #[doc = "< Channel on which to perform ROC Operation"]
    pub channel: u8,
    #[doc = "< Secondary channel"]
    pub sec_channel: wifi_second_chan_t,
    #[doc = "< Duration to wait for on target channel"]
    pub wait_time_ms: u32,
    #[doc = "< Rx Callback to receive any response"]
    pub rx_cb: wifi_action_rx_cb_t,
    #[doc = "< ID of this specific ROC operation provided by wifi driver"]
    pub op_id: u8,
    #[doc = "< Callback to function that will be called upon ROC done. If assigned, WIFI_EVENT_ROC_DONE event will not be posted"]
    pub done_cb: wifi_action_roc_done_cb_t,
}
#[doc = " @brief FTM Initiator configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ftm_initiator_cfg_t {
    #[doc = "< MAC address of the FTM Responder"]
    pub resp_mac: [u8; 6usize],
    #[doc = "< Primary channel of the FTM Responder"]
    pub channel: u8,
    #[doc = "< No. of FTM frames requested in terms of 4 or 8 bursts (allowed values - 0(No pref), 16, 24, 32, 64)"]
    pub frm_count: u8,
    #[doc = "< Requested period between FTM bursts in 100's of milliseconds (allowed values 0(No pref) - 100)"]
    pub burst_period: u16,
    #[doc = "< True - Using esp_wifi_ftm_get_report to get FTM report, False - Using ftm_report_data from\nWIFI_EVENT_FTM_REPORT to get FTM report"]
    pub use_get_report_api: bool,
}
#[doc = "< Value 0 Reserved"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_RESERVED: wifi_nan_svc_proto_t = 0;
#[doc = "< Bonjour Protocol"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_BONJOUR: wifi_nan_svc_proto_t = 1;
#[doc = "< Generic Service Protocol"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_GENERIC: wifi_nan_svc_proto_t = 2;
#[doc = "< CSA Matter specific protocol"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_CSA_MATTER: wifi_nan_svc_proto_t = 3;
#[doc = "< Values 4-255 Reserved"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_MAX: wifi_nan_svc_proto_t = 4;
#[doc = " @brief Protocol types in NAN service specific info attribute\n"]
pub type wifi_nan_svc_proto_t = crate::c_types::c_uint;
#[doc = " @brief WFA defined Protocol types in NAN service specific info attribute\n"]
#[repr(C)]
pub struct wifi_nan_wfa_ssi_t {
    #[doc = "< WFA OUI - 0x50, 0x6F, 0x9A"]
    pub wfa_oui: [u8; 3usize],
    #[doc = "< WFA defined protocol types"]
    pub proto: wifi_nan_svc_proto_t,
    #[doc = "< Service Info payload"]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = "< Send unicast Publish frame to Subscribers that match the requirement"]
pub const wifi_nan_service_type_t_NAN_PUBLISH_SOLICITED: wifi_nan_service_type_t = 0;
#[doc = "< Send broadcast Publish frames in every Discovery Window(DW)"]
pub const wifi_nan_service_type_t_NAN_PUBLISH_UNSOLICITED: wifi_nan_service_type_t = 1;
#[doc = "< Send broadcast Subscribe frames in every DW"]
pub const wifi_nan_service_type_t_NAN_SUBSCRIBE_ACTIVE: wifi_nan_service_type_t = 2;
#[doc = "< Passively listens to Publish frames"]
pub const wifi_nan_service_type_t_NAN_SUBSCRIBE_PASSIVE: wifi_nan_service_type_t = 3;
#[doc = " @brief NAN Services types\n"]
pub type wifi_nan_service_type_t = crate::c_types::c_uint;
#[doc = " @brief NAN Publish service configuration parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_publish_cfg_t {
    #[doc = "< Service name identifier"]
    pub service_name: [crate::c_types::c_char; 256usize],
    #[doc = "< Service type"]
    pub type_: wifi_nan_service_type_t,
    #[doc = "< Comma separated filters for filtering services"]
    pub matching_filter: [crate::c_types::c_char; 256usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [crate::c_types::c_char; 64usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Length of service specific info, maximum allowed length - ESP_WIFI_MAX_SVC_SSI_LEN"]
    pub ssi_len: u16,
    #[doc = "< Service Specific Info of type wifi_nan_wfa_ssi_t for WFA defined protocols, otherwise proprietary and defined by Applications"]
    pub ssi: *mut u8,
}
impl wifi_nan_publish_cfg_t {
    #[inline]
    pub fn single_replied_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_replied_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn datapath_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_datapath_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_gas(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_gas(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single_replied_event: u8,
        datapath_reqd: u8,
        fsd_reqd: u8,
        fsd_gas: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single_replied_event: u8 = unsafe { ::core::mem::transmute(single_replied_event) };
            single_replied_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let datapath_reqd: u8 = unsafe { ::core::mem::transmute(datapath_reqd) };
            datapath_reqd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fsd_reqd: u8 = unsafe { ::core::mem::transmute(fsd_reqd) };
            fsd_reqd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fsd_gas: u8 = unsafe { ::core::mem::transmute(fsd_gas) };
            fsd_gas as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Subscribe service configuration parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_subscribe_cfg_t {
    #[doc = "< Service name identifier"]
    pub service_name: [crate::c_types::c_char; 256usize],
    #[doc = "< Service type"]
    pub type_: wifi_nan_service_type_t,
    #[doc = "< Comma separated filters for filtering services"]
    pub matching_filter: [crate::c_types::c_char; 256usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [crate::c_types::c_char; 64usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Length of service specific info, maximum allowed length - ESP_WIFI_MAX_SVC_SSI_LEN"]
    pub ssi_len: u16,
    #[doc = "< Service Specific Info of type wifi_nan_wfa_ssi_t for WFA defined protocols, otherwise proprietary and defined by Applications"]
    pub ssi: *mut u8,
}
impl wifi_nan_subscribe_cfg_t {
    #[inline]
    pub fn single_match_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_match_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn datapath_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_datapath_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_gas(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_gas(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single_match_event: u8,
        datapath_reqd: u8,
        fsd_reqd: u8,
        fsd_gas: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single_match_event: u8 = unsafe { ::core::mem::transmute(single_match_event) };
            single_match_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let datapath_reqd: u8 = unsafe { ::core::mem::transmute(datapath_reqd) };
            datapath_reqd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fsd_reqd: u8 = unsafe { ::core::mem::transmute(fsd_reqd) };
            fsd_reqd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fsd_gas: u8 = unsafe { ::core::mem::transmute(fsd_gas) };
            fsd_gas as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Follow-up parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_followup_params_t {
    #[doc = "< Own service instance id"]
    pub inst_id: u8,
    #[doc = "< Peer's service instance id"]
    pub peer_inst_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [crate::c_types::c_char; 64usize],
    #[doc = "< Length of service specific info, maximum allowed length - ESP_WIFI_MAX_FUP_SSI_LEN"]
    pub ssi_len: u16,
    #[doc = "< Service Specific Info of type wifi_nan_wfa_ssi_t for WFA defined protocols, otherwise proprietary and defined by Applications"]
    pub ssi: *mut u8,
}
#[doc = " @brief NAN Datapath Request parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_req_t {
    #[doc = "< Publisher's service instance id"]
    pub pub_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< NDP Confirm frame required"]
    pub confirm_required: bool,
}
#[doc = " @brief NAN Datapath Response parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_resp_t {
    #[doc = "< True - Accept incoming NDP, False - Reject it"]
    pub accept: bool,
    #[doc = "< NAN Datapath Identifier"]
    pub ndp_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
}
#[doc = " @brief NAN Datapath End parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_end_req_t {
    #[doc = "< NAN Datapath Identifier"]
    pub ndp_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
}
#[doc = "< 1 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_1M_L: wifi_phy_rate_t = 0;
#[doc = "< 2 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_L: wifi_phy_rate_t = 1;
#[doc = "< 5.5 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_L: wifi_phy_rate_t = 2;
#[doc = "< 11 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_L: wifi_phy_rate_t = 3;
#[doc = "< 2 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_S: wifi_phy_rate_t = 5;
#[doc = "< 5.5 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_S: wifi_phy_rate_t = 6;
#[doc = "< 11 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_S: wifi_phy_rate_t = 7;
#[doc = "< 48 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_48M: wifi_phy_rate_t = 8;
#[doc = "< 24 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_24M: wifi_phy_rate_t = 9;
#[doc = "< 12 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_12M: wifi_phy_rate_t = 10;
#[doc = "< 6 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_6M: wifi_phy_rate_t = 11;
#[doc = "< 54 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_54M: wifi_phy_rate_t = 12;
#[doc = "< 36 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_36M: wifi_phy_rate_t = 13;
#[doc = "< 18 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_18M: wifi_phy_rate_t = 14;
#[doc = "< 9 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_9M: wifi_phy_rate_t = 15;
#[doc = "< MCS0 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_LGI: wifi_phy_rate_t = 16;
#[doc = "< MCS1 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_LGI: wifi_phy_rate_t = 17;
#[doc = "< MCS2 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_LGI: wifi_phy_rate_t = 18;
#[doc = "< MCS3 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_LGI: wifi_phy_rate_t = 19;
#[doc = "< MCS4 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_LGI: wifi_phy_rate_t = 20;
#[doc = "< MCS5 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_LGI: wifi_phy_rate_t = 21;
#[doc = "< MCS6 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_LGI: wifi_phy_rate_t = 22;
#[doc = "< MCS7 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_LGI: wifi_phy_rate_t = 23;
#[doc = "< MCS8 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS8_LGI: wifi_phy_rate_t = 24;
#[doc = "< MCS9 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS9_LGI: wifi_phy_rate_t = 25;
#[doc = "< MCS0 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_SGI: wifi_phy_rate_t = 26;
#[doc = "< MCS1 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_SGI: wifi_phy_rate_t = 27;
#[doc = "< MCS2 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_SGI: wifi_phy_rate_t = 28;
#[doc = "< MCS3 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_SGI: wifi_phy_rate_t = 29;
#[doc = "< MCS4 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_SGI: wifi_phy_rate_t = 30;
#[doc = "< MCS5 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_SGI: wifi_phy_rate_t = 31;
#[doc = "< MCS6 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_SGI: wifi_phy_rate_t = 32;
#[doc = "< MCS7 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_SGI: wifi_phy_rate_t = 33;
#[doc = "< MCS8 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS8_SGI: wifi_phy_rate_t = 34;
#[doc = "< MCS9 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS9_SGI: wifi_phy_rate_t = 35;
#[doc = "< Espressif-specific Long Range mode rate, 250 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_250K: wifi_phy_rate_t = 41;
#[doc = "< Espressif-specific Long Range mode rate, 500 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_500K: wifi_phy_rate_t = 42;
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MAX: wifi_phy_rate_t = 43;
#[doc = " @brief Wi-Fi PHY rate encodings\n\n @note Rate Table: MCS Rate and Guard Interval Information\n |       MCS RATE              |          HT20           |          HT40           |          HE20           |         VHT20           |\n |-----------------------------|-------------------------|-------------------------|-------------------------|-------------------------|\n | WIFI_PHY_RATE_MCS0_LGI      |     6.5 Mbps (800 ns)   |    13.5 Mbps (800 ns)   |     8.1 Mbps (1600 ns)  |     6.5 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS1_LGI      |      13 Mbps (800 ns)   |      27 Mbps (800 ns)   |    16.3 Mbps (1600 ns)  |      13 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS2_LGI      |    19.5 Mbps (800 ns)   |    40.5 Mbps (800 ns)   |    24.4 Mbps (1600 ns)  |    19.5 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS3_LGI      |      26 Mbps (800 ns)   |      54 Mbps (800 ns)   |    32.5 Mbps (1600 ns)  |      26 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS4_LGI      |      39 Mbps (800 ns)   |      81 Mbps (800 ns)   |    48.8 Mbps (1600 ns)  |      39 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS5_LGI      |      52 Mbps (800 ns)   |     108 Mbps (800 ns)   |      65 Mbps (1600 ns)  |      52 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS6_LGI      |    58.5 Mbps (800 ns)   |   121.5 Mbps (800 ns)   |    73.1 Mbps (1600 ns)  |    58.5 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS7_LGI      |      65 Mbps (800 ns)   |     135 Mbps (800 ns)   |    81.3 Mbps (1600 ns)  |      65 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS8_LGI      |                         |                         |    97.5 Mbps (1600 ns)  |                         |\n | WIFI_PHY_RATE_MCS9_LGI      |                         |                         |   108.3 Mbps (1600 ns)  |                         |\n\n @note\n |       MCS RATE              |          HT20           |          HT40           |          HE20           |         VHT20           |\n |-----------------------------|-------------------------|-------------------------|-------------------------|-------------------------|\n | WIFI_PHY_RATE_MCS0_SGI      |     7.2 Mbps (400 ns)   |      15 Mbps (400 ns)   |      8.6 Mbps (800 ns)  |     7.2 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS1_SGI      |    14.4 Mbps (400 ns)   |      30 Mbps (400 ns)   |     17.2 Mbps (800 ns)  |    14.4 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS2_SGI      |    21.7 Mbps (400 ns)   |      45 Mbps (400 ns)   |     25.8 Mbps (800 ns)  |    21.7 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS3_SGI      |    28.9 Mbps (400 ns)   |      60 Mbps (400 ns)   |     34.4 Mbps (800 ns)  |    28.9 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS4_SGI      |    43.3 Mbps (400 ns)   |      90 Mbps (400 ns)   |     51.6 Mbps (800 ns)  |    43.3 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS5_SGI      |    57.8 Mbps (400 ns)   |     120 Mbps (400 ns)   |     68.8 Mbps (800 ns)  |    57.8 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS6_SGI      |      65 Mbps (400 ns)   |     135 Mbps (400 ns)   |     77.4 Mbps (800 ns)  |      65 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS7_SGI      |    72.2 Mbps (400 ns)   |     150 Mbps (400 ns)   |       86 Mbps (800 ns)  |    72.2 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS8_SGI      |                         |                         |    103.2 Mbps (800 ns)  |                         |\n | WIFI_PHY_RATE_MCS9_SGI      |                         |                         |    114.7 Mbps (800 ns)  |                         |\n"]
pub type wifi_phy_rate_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi ready"]
pub const wifi_event_t_WIFI_EVENT_WIFI_READY: wifi_event_t = 0;
#[doc = "< Finished scanning AP"]
pub const wifi_event_t_WIFI_EVENT_SCAN_DONE: wifi_event_t = 1;
#[doc = "< Station start"]
pub const wifi_event_t_WIFI_EVENT_STA_START: wifi_event_t = 2;
#[doc = "< Station stop"]
pub const wifi_event_t_WIFI_EVENT_STA_STOP: wifi_event_t = 3;
#[doc = "< Station connected to AP"]
pub const wifi_event_t_WIFI_EVENT_STA_CONNECTED: wifi_event_t = 4;
#[doc = "< Station disconnected from AP"]
pub const wifi_event_t_WIFI_EVENT_STA_DISCONNECTED: wifi_event_t = 5;
#[doc = "< The auth mode of AP connected by device's station changed"]
pub const wifi_event_t_WIFI_EVENT_STA_AUTHMODE_CHANGE: wifi_event_t = 6;
#[doc = "< Station WPS succeeds in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_SUCCESS: wifi_event_t = 7;
#[doc = "< Station WPS fails in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_FAILED: wifi_event_t = 8;
#[doc = "< Station WPS timeout in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_TIMEOUT: wifi_event_t = 9;
#[doc = "< Station WPS pin code in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PIN: wifi_event_t = 10;
#[doc = "< Station WPS overlap in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP: wifi_event_t = 11;
#[doc = "< Soft-AP start"]
pub const wifi_event_t_WIFI_EVENT_AP_START: wifi_event_t = 12;
#[doc = "< Soft-AP stop"]
pub const wifi_event_t_WIFI_EVENT_AP_STOP: wifi_event_t = 13;
#[doc = "< A station connected to Soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STACONNECTED: wifi_event_t = 14;
#[doc = "< A station disconnected from Soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STADISCONNECTED: wifi_event_t = 15;
#[doc = "< Receive probe request packet in soft-AP interface"]
pub const wifi_event_t_WIFI_EVENT_AP_PROBEREQRECVED: wifi_event_t = 16;
#[doc = "< Receive report of FTM procedure"]
pub const wifi_event_t_WIFI_EVENT_FTM_REPORT: wifi_event_t = 17;
#[doc = "< AP's RSSI crossed configured threshold"]
pub const wifi_event_t_WIFI_EVENT_STA_BSS_RSSI_LOW: wifi_event_t = 18;
#[doc = "< Status indication of Action Tx operation"]
pub const wifi_event_t_WIFI_EVENT_ACTION_TX_STATUS: wifi_event_t = 19;
#[doc = "< Remain-on-Channel operation complete"]
pub const wifi_event_t_WIFI_EVENT_ROC_DONE: wifi_event_t = 20;
#[doc = "< Station beacon timeout"]
pub const wifi_event_t_WIFI_EVENT_STA_BEACON_TIMEOUT: wifi_event_t = 21;
#[doc = "< Connectionless module wake interval start"]
pub const wifi_event_t_WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START: wifi_event_t = 22;
#[doc = "< Soft-AP wps succeeds in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_SUCCESS: wifi_event_t = 23;
#[doc = "< Soft-AP wps fails in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_FAILED: wifi_event_t = 24;
#[doc = "< Soft-AP wps timeout in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_TIMEOUT: wifi_event_t = 25;
#[doc = "< Soft-AP wps pin code in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_PIN: wifi_event_t = 26;
#[doc = "< Soft-AP wps overlap in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_PBC_OVERLAP: wifi_event_t = 27;
#[doc = "< iTWT setup"]
pub const wifi_event_t_WIFI_EVENT_ITWT_SETUP: wifi_event_t = 28;
#[doc = "< iTWT teardown"]
pub const wifi_event_t_WIFI_EVENT_ITWT_TEARDOWN: wifi_event_t = 29;
#[doc = "< iTWT probe"]
pub const wifi_event_t_WIFI_EVENT_ITWT_PROBE: wifi_event_t = 30;
#[doc = "< iTWT suspend"]
pub const wifi_event_t_WIFI_EVENT_ITWT_SUSPEND: wifi_event_t = 31;
#[doc = "< TWT wakeup"]
pub const wifi_event_t_WIFI_EVENT_TWT_WAKEUP: wifi_event_t = 32;
#[doc = "< bTWT setup"]
pub const wifi_event_t_WIFI_EVENT_BTWT_SETUP: wifi_event_t = 33;
#[doc = "< bTWT teardown"]
pub const wifi_event_t_WIFI_EVENT_BTWT_TEARDOWN: wifi_event_t = 34;
#[doc = "< NAN Discovery has started"]
pub const wifi_event_t_WIFI_EVENT_NAN_STARTED: wifi_event_t = 35;
#[doc = "< NAN Discovery has stopped"]
pub const wifi_event_t_WIFI_EVENT_NAN_STOPPED: wifi_event_t = 36;
#[doc = "< NAN Service Discovery match found"]
pub const wifi_event_t_WIFI_EVENT_NAN_SVC_MATCH: wifi_event_t = 37;
#[doc = "< Replied to a NAN peer with Service Discovery match"]
pub const wifi_event_t_WIFI_EVENT_NAN_REPLIED: wifi_event_t = 38;
#[doc = "< Received a Follow-up message"]
pub const wifi_event_t_WIFI_EVENT_NAN_RECEIVE: wifi_event_t = 39;
#[doc = "< Received NDP Request from a NAN Peer"]
pub const wifi_event_t_WIFI_EVENT_NDP_INDICATION: wifi_event_t = 40;
#[doc = "< NDP Confirm Indication"]
pub const wifi_event_t_WIFI_EVENT_NDP_CONFIRM: wifi_event_t = 41;
#[doc = "< NAN Datapath terminated indication"]
pub const wifi_event_t_WIFI_EVENT_NDP_TERMINATED: wifi_event_t = 42;
#[doc = "< Wi-Fi home channel change，doesn't occur when scanning"]
pub const wifi_event_t_WIFI_EVENT_HOME_CHANNEL_CHANGE: wifi_event_t = 43;
#[doc = "< Received Neighbor Report response"]
pub const wifi_event_t_WIFI_EVENT_STA_NEIGHBOR_REP: wifi_event_t = 44;
#[doc = "< a station tried to connect with wrong password"]
pub const wifi_event_t_WIFI_EVENT_AP_WRONG_PASSWORD: wifi_event_t = 45;
#[doc = "< Station sampled beacon offset unstable"]
pub const wifi_event_t_WIFI_EVENT_STA_BEACON_OFFSET_UNSTABLE: wifi_event_t = 46;
#[doc = "< DPP URI is ready through Bootstrapping"]
pub const wifi_event_t_WIFI_EVENT_DPP_URI_READY: wifi_event_t = 47;
#[doc = "< Config received via DPP Authentication"]
pub const wifi_event_t_WIFI_EVENT_DPP_CFG_RECVD: wifi_event_t = 48;
#[doc = "< DPP failed"]
pub const wifi_event_t_WIFI_EVENT_DPP_FAILED: wifi_event_t = 49;
#[doc = "< Invalid Wi-Fi event ID"]
pub const wifi_event_t_WIFI_EVENT_MAX: wifi_event_t = 50;
#[doc = " @brief Wi-Fi event declarations"]
pub type wifi_event_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @cond **/\n/** @brief Wi-Fi event base declaration"]
    pub static WIFI_EVENT: esp_event_base_t;
}
#[doc = " @brief Argument structure for WIFI_EVENT_SCAN_DONE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_scan_done_t {
    #[doc = "< Status of scanning APs: 0 — success, 1 - failure"]
    pub status: u32,
    #[doc = "< Number of scan results"]
    pub number: u8,
    #[doc = "< Scan sequence number, used for block scan"]
    pub scan_id: u8,
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_CONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_connected_t {
    #[doc = "< SSID of connected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of connected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of connected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< Channel of connected AP"]
    pub channel: u8,
    #[doc = "< Authentication mode used by the connection"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Authentication id assigned by the connected AP"]
    pub aid: u16,
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_DISCONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_disconnected_t {
    #[doc = "< SSID of disconnected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of disconnected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of disconnected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< Disconnection reason"]
    pub reason: u8,
    #[doc = "< Disconnection RSSI"]
    pub rssi: i8,
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_AUTHMODE_CHANGE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_authmode_change_t {
    #[doc = "< Old auth mode of AP"]
    pub old_mode: wifi_auth_mode_t,
    #[doc = "< New auth mode of AP"]
    pub new_mode: wifi_auth_mode_t,
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_WPS_ER_PIN event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< WPS normal fail reason"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_NORMAL:
    wifi_event_sta_wps_fail_reason_t = 0;
#[doc = "< WPS receive M2D frame"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_RECV_M2D:
    wifi_event_sta_wps_fail_reason_t = 1;
#[doc = "< Recv deauth from AP while wps handshake"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_RECV_DEAUTH:
    wifi_event_sta_wps_fail_reason_t = 2;
#[doc = "< Max WPS fail reason"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_MAX: wifi_event_sta_wps_fail_reason_t =
    3;
#[doc = " @brief Argument structure for WIFI_EVENT_STA_WPS_ER_FAILED event"]
pub type wifi_event_sta_wps_fail_reason_t = crate::c_types::c_uint;
#[doc = " @brief Argument structure for WIFI_EVENT_STA_WPS_ER_SUCCESS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_success_t {
    #[doc = "< Number of AP credentials received"]
    pub ap_cred_cnt: u8,
    #[doc = "< All AP credentials received from WPS handshake"]
    pub ap_cred: [wifi_event_sta_wps_er_success_t__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_success_t__bindgen_ty_1 {
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< Passphrase for the AP"]
    pub passphrase: [u8; 64usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_STACONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_staconnected_t {
    #[doc = "< MAC address of the station connected to Soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< AID assigned by the Soft-AP to the connected station"]
    pub aid: u8,
    #[doc = "< Flag indicating whether the connected station is a mesh child"]
    pub is_mesh_child: bool,
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_STADISCONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_stadisconnected_t {
    #[doc = "< MAC address of the station disconnects from the soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< AID that the Soft-AP assigned to the disconnected station"]
    pub aid: u8,
    #[doc = "< Flag indicating whether the disconnected station is a mesh child"]
    pub is_mesh_child: bool,
    #[doc = "< Disconnection reason"]
    pub reason: u16,
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_PROBEREQRECVED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_probe_req_rx_t {
    #[doc = "< Received probe request signal strength"]
    pub rssi: crate::c_types::c_int,
    #[doc = "< MAC address of the station which send probe request"]
    pub mac: [u8; 6usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_BSS_RSSI_LOW event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_bss_rssi_low_t {
    #[doc = "< RSSI value of bss"]
    pub rssi: i32,
}
#[doc = " @brief Argument structure for WIFI_EVENT_HOME_CHANNEL_CHANGE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_home_channel_change_t {
    #[doc = "< Old home channel of the device"]
    pub old_chan: u8,
    #[doc = "< Old second channel of the device"]
    pub old_snd: wifi_second_chan_t,
    #[doc = "< New home channel of the device"]
    pub new_chan: u8,
    #[doc = "< New second channel of the device"]
    pub new_snd: wifi_second_chan_t,
}
#[doc = "< FTM exchange is successful"]
pub const wifi_ftm_status_t_FTM_STATUS_SUCCESS: wifi_ftm_status_t = 0;
#[doc = "< Peer does not support FTM"]
pub const wifi_ftm_status_t_FTM_STATUS_UNSUPPORTED: wifi_ftm_status_t = 1;
#[doc = "< Peer rejected FTM configuration in FTM Request"]
pub const wifi_ftm_status_t_FTM_STATUS_CONF_REJECTED: wifi_ftm_status_t = 2;
#[doc = "< Peer did not respond to FTM Requests"]
pub const wifi_ftm_status_t_FTM_STATUS_NO_RESPONSE: wifi_ftm_status_t = 3;
#[doc = "< Unknown error during FTM exchange"]
pub const wifi_ftm_status_t_FTM_STATUS_FAIL: wifi_ftm_status_t = 4;
#[doc = "< FTM session did not result in any valid measurements"]
pub const wifi_ftm_status_t_FTM_STATUS_NO_VALID_MSMT: wifi_ftm_status_t = 5;
#[doc = "< User triggered termination"]
pub const wifi_ftm_status_t_FTM_STATUS_USER_TERM: wifi_ftm_status_t = 6;
#[doc = " @brief FTM operation status types\n"]
pub type wifi_ftm_status_t = crate::c_types::c_uint;
#[doc = " @brief Structure representing a report entry for Fine Timing Measurement (FTM) in Wi-Fi.\n\n This structure holds the information related to the FTM process between a Wi-Fi FTM Initiator\n and a Wi-Fi FTM Responder. FTM is used for precise distance measurement by timing the exchange\n of frames between devices."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ftm_report_entry_t {
    #[doc = "< Dialog Token of the FTM frame"]
    pub dlog_token: u8,
    #[doc = "< RSSI of the FTM frame received"]
    pub rssi: i8,
    #[doc = "< Round Trip Time in pSec with a peer"]
    pub rtt: u32,
    #[doc = "< Time of departure of FTM frame from FTM Responder in pSec"]
    pub t1: u64,
    #[doc = "< Time of arrival of FTM frame at FTM Initiator in pSec"]
    pub t2: u64,
    #[doc = "< Time of departure of ACK from FTM Initiator in pSec"]
    pub t3: u64,
    #[doc = "< Time of arrival of ACK at FTM Responder in pSec"]
    pub t4: u64,
}
#[doc = " @brief Argument structure for WIFI_EVENT_FTM_REPORT event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ftm_report_t {
    #[doc = "< MAC address of the FTM Peer"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< Status of the FTM operation"]
    pub status: wifi_ftm_status_t,
    #[doc = "< Raw average Round-Trip-Time with peer in Nano-Seconds"]
    pub rtt_raw: u32,
    #[doc = "< Estimated Round-Trip-Time with peer in Nano-Seconds"]
    pub rtt_est: u32,
    #[doc = "< Estimated one-way distance in Centi-Meters"]
    pub dist_est: u32,
    #[doc = "< Pointer to FTM Report, should be freed after use. Note: Highly recommended\nto use API esp_wifi_ftm_get_report to get the report instead of using this"]
    pub ftm_report_data: *mut wifi_ftm_report_entry_t,
    #[doc = "< Number of entries in the FTM Report data"]
    pub ftm_report_num_entries: u8,
}
#[doc = "< ACTION_TX operation was completed successfully"]
pub const wifi_action_tx_status_type_t_WIFI_ACTION_TX_DONE: wifi_action_tx_status_type_t = 0;
#[doc = "< ACTION_TX operation failed during tx"]
pub const wifi_action_tx_status_type_t_WIFI_ACTION_TX_FAILED: wifi_action_tx_status_type_t = 1;
#[doc = "< ACTION_TX operation completed it's wait duration"]
pub const wifi_action_tx_status_type_t_WIFI_ACTION_TX_DURATION_COMPLETED:
    wifi_action_tx_status_type_t = 2;
#[doc = "< ACTION_TX operation was cancelled by application or higher priority operation"]
pub const wifi_action_tx_status_type_t_WIFI_ACTION_TX_OP_CANCELLED: wifi_action_tx_status_type_t =
    3;
#[doc = " Status codes for WIFI_EVENT_ACTION_TX_STATUS evt */\n/** There will be back to back events in success case TX_DONE and TX_DURATION_COMPLETED"]
pub type wifi_action_tx_status_type_t = crate::c_types::c_uint;
#[doc = " Argument structure for WIFI_EVENT_ACTION_TX_STATUS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_action_tx_status_t {
    #[doc = "< WiFi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< Context to identify the request"]
    pub context: u32,
    #[doc = "< Status of the operation"]
    pub status: wifi_action_tx_status_type_t,
    #[doc = "< ID of the corresponding operation that was provided during action tx request"]
    pub op_id: u8,
    #[doc = "< Channel provided in tx request"]
    pub channel: u8,
}
#[doc = " @brief Argument structure for WIFI_EVENT_ROC_DONE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_roc_done_t {
    #[doc = "< Context to identify the initiator of the request"]
    pub context: u32,
    #[doc = "< ROC status"]
    pub status: wifi_roc_done_status_t,
    #[doc = "< ID of the corresponding ROC operation"]
    pub op_id: u8,
    #[doc = "< Channel provided in tx request"]
    pub channel: u8,
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_WPS_RG_PIN event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< WPS normal fail reason"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_NORMAL: wps_fail_reason_t = 0;
#[doc = "< WPS failed due to incorrect config"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_CONFIG: wps_fail_reason_t = 1;
#[doc = "< WPS failed during auth"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_AUTH: wps_fail_reason_t = 2;
#[doc = "< Max WPS fail reason"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_MAX: wps_fail_reason_t = 3;
#[doc = " @brief WPS fail reason"]
pub type wps_fail_reason_t = crate::c_types::c_uint;
#[doc = " @brief Argument structure for WIFI_EVENT_AP_WPS_RG_FAILED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_fail_reason_t {
    #[doc = "< WPS failure reason wps_fail_reason_t"]
    pub reason: wps_fail_reason_t,
    #[doc = "< Enrollee mac address"]
    pub peer_macaddr: [u8; 6usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_WPS_RG_SUCCESS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_success_t {
    #[doc = "< Enrollee mac address"]
    pub peer_macaddr: [u8; 6usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_NAN_SVC_MATCH event"]
#[repr(C)]
pub struct wifi_event_nan_svc_match_t {
    #[doc = "< Subscribe Service Identifier"]
    pub subscribe_id: u8,
    #[doc = "< Publish Service Identifier"]
    pub publish_id: u8,
    #[doc = "< NAN Interface MAC of the Publisher"]
    pub pub_if_mac: [u8; 6usize],
    #[doc = "< Indicates whether publisher's service ID needs to be updated"]
    pub update_pub_id: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Indicates version of SSI in Publish instance, 0 if not available"]
    pub ssi_version: u8,
    #[doc = "< Length of service specific info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info of Publisher"]
    pub ssi: __IncompleteArrayField<u8>,
}
impl wifi_event_nan_svc_match_t {
    #[inline]
    pub fn datapath_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_datapath_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_gas(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_gas(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        datapath_reqd: u8,
        fsd_reqd: u8,
        fsd_gas: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let datapath_reqd: u8 = unsafe { ::core::mem::transmute(datapath_reqd) };
            datapath_reqd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fsd_reqd: u8 = unsafe { ::core::mem::transmute(fsd_reqd) };
            fsd_reqd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fsd_gas: u8 = unsafe { ::core::mem::transmute(fsd_gas) };
            fsd_gas as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Argument structure for WIFI_EVENT_NAN_REPLIED event"]
#[repr(C)]
pub struct wifi_event_nan_replied_t {
    #[doc = "< Publish Service Identifier"]
    pub publish_id: u8,
    #[doc = "< Subscribe Service Identifier"]
    pub subscribe_id: u8,
    #[doc = "< NAN Interface MAC of the Subscriber"]
    pub sub_if_mac: [u8; 6usize],
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Length of service specific info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info of Subscriber"]
    pub ssi: __IncompleteArrayField<u8>,
}
#[doc = " @brief Argument structure for WIFI_EVENT_NAN_RECEIVE event"]
#[repr(C)]
pub struct wifi_event_nan_receive_t {
    #[doc = "< Our Service Identifier"]
    pub inst_id: u8,
    #[doc = "< Peer's Service Identifier"]
    pub peer_inst_id: u8,
    #[doc = "< Peer's NAN Interface MAC"]
    pub peer_if_mac: [u8; 6usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub peer_svc_info: [u8; 64usize],
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Length of service specific info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info from Follow-up"]
    pub ssi: __IncompleteArrayField<u8>,
}
#[doc = " @brief Argument structure for WIFI_EVENT_NDP_INDICATION event"]
#[repr(C)]
pub struct wifi_event_ndp_indication_t {
    #[doc = "< Publish Id for NAN Service"]
    pub publish_id: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Peer's NAN Management Interface MAC"]
    pub peer_nmi: [u8; 6usize],
    #[doc = "< Peer's NAN Data Interface MAC"]
    pub peer_ndi: [u8; 6usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [u8; 64usize],
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Length of service specific info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info from NDP/NDPE Attribute"]
    pub ssi: __IncompleteArrayField<u8>,
}
#[doc = " @brief Argument structure for WIFI_EVENT_NDP_CONFIRM event"]
#[repr(C)]
pub struct wifi_event_ndp_confirm_t {
    #[doc = "< NDP status code"]
    pub status: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Peer's NAN Management Interface MAC"]
    pub peer_nmi: [u8; 6usize],
    #[doc = "< Peer's NAN Data Interface MAC"]
    pub peer_ndi: [u8; 6usize],
    #[doc = "< Own NAN Data Interface MAC"]
    pub own_ndi: [u8; 6usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [u8; 64usize],
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Length of Service Specific Info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info from NDP/NDPE Attribute"]
    pub ssi: __IncompleteArrayField<u8>,
}
#[doc = " @brief Argument structure for WIFI_EVENT_NDP_TERMINATED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ndp_terminated_t {
    #[doc = "< Termination reason code"]
    pub reason: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Initiator's NAN Data Interface MAC"]
    pub init_ndi: [u8; 6usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_NEIGHBOR_REP event"]
#[repr(C)]
pub struct wifi_event_neighbor_report_t {
    #[doc = "< Neighbor Report received from the AP (will be deprecated in next major release, use n_report instead)"]
    pub report: [u8; 64usize],
    #[doc = "< Length of the report"]
    pub report_len: u16,
    #[doc = "< Neighbor Report received from the AP"]
    pub n_report: __IncompleteArrayField<u8>,
}
#[doc = " Argument structure for WIFI_EVENT_AP_WRONG_PASSWORD event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wrong_password_t {
    #[doc = "< MAC address of the station trying to connect to Soft-AP"]
    pub mac: [u8; 6usize],
}
#[doc = " @brief Argument structure for wifi_tx_rate_config"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_tx_rate_config_t {
    #[doc = "< Phymode of specified interface"]
    pub phymode: wifi_phy_mode_t,
    #[doc = "< Rate of specified interface"]
    pub rate: wifi_phy_rate_t,
    #[doc = "< Using ERSU to send frame, ERSU is a transmission mode related to 802.11 ax.\nERSU is always used in long distance transmission, and its frame has lower rate compared with SU mode"]
    pub ersu: bool,
    #[doc = "< Using dcm rate to send frame"]
    pub dcm: bool,
}
#[doc = " Argument structure for regulatory rule"]
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub struct wifi_reg_rule_t {
    #[doc = "< start channel of regulatory rule"]
    pub start_channel: u8,
    #[doc = "< end channel of regulatory rule"]
    pub end_channel: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl wifi_reg_rule_t {
    #[inline]
    pub fn max_bandwidth(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_max_bandwidth(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn max_eirp(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_max_eirp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn is_dfs(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_dfs(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        max_bandwidth: u16,
        max_eirp: u16,
        is_dfs: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let max_bandwidth: u16 = unsafe { ::core::mem::transmute(max_bandwidth) };
            max_bandwidth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 6u8, {
            let max_eirp: u16 = unsafe { ::core::mem::transmute(max_eirp) };
            max_eirp as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_dfs: u16 = unsafe { ::core::mem::transmute(is_dfs) };
            is_dfs as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Argument structure for regdomain"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_regulatory_t {
    #[doc = "< number of regulatory rules"]
    pub n_reg_rules: u8,
    #[doc = "< array of regulatory rules"]
    pub reg_rules: [wifi_reg_rule_t; 2usize],
}
#[doc = " Argument structure for regdomain"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_regdomain_t {
    #[doc = "< country code string"]
    pub cn: [crate::c_types::c_char; 2usize],
    #[doc = "< regulatory type of country"]
    pub regulatory_type: u8,
}
#[doc = "< Sending Wi-Fi data successfully"]
pub const wifi_tx_status_t_WIFI_SEND_SUCCESS: wifi_tx_status_t = 0;
#[doc = "< Sending Wi-Fi data fail"]
pub const wifi_tx_status_t_WIFI_SEND_FAIL: wifi_tx_status_t = 1;
#[doc = " @brief Status of wifi sending data"]
pub type wifi_tx_status_t = crate::c_types::c_uint;
#[doc = " @brief Information of wifi sending data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_tx_info_t {
    #[doc = "< The address of the receive device"]
    pub des_addr: *mut u8,
    #[doc = "< The address of the sending device"]
    pub src_addr: *mut u8,
    #[doc = "< Interface of sending 80211 tx data"]
    pub ifidx: wifi_interface_t,
    #[doc = "< The data for 80211 tx, start from the MAC header"]
    pub data: *mut u8,
    #[doc = "< The frame body length for 80211 tx, excluding the MAC header"]
    pub data_len: u8,
    #[doc = "< Data rate"]
    pub rate: wifi_phy_rate_t,
    #[doc = "< Status of sending 80211 tx data"]
    pub tx_status: wifi_tx_status_t,
}
#[doc = " @brief Information of wifi sending data"]
pub type esp_80211_tx_info_t = wifi_tx_info_t;
#[doc = " Argument structure for WIFI_EVENT_STA_BEACON_OFFSET_UNSTABLE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_beacon_offset_unstable_t {
    #[doc = "< Received beacon success rate"]
    pub beacon_success_rate: f32,
}
#[doc = " Argument structure for WIFI_EVENT_DPP_URI_READY event"]
#[repr(C)]
pub struct wifi_event_dpp_uri_ready_t {
    #[doc = "< URI data length including null termination"]
    pub uri_data_len: u32,
    #[doc = "< URI data"]
    pub uri: __IncompleteArrayField<crate::c_types::c_char>,
}
#[doc = " Argument structure for WIFI_EVENT_DPP_CFG_RECVD event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_dpp_config_received_t {
    #[doc = "< Received WIFI config in DPP"]
    pub wifi_cfg: wifi_config_t,
}
#[doc = " Argument structure for WIFI_EVENT_DPP_FAIL event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_dpp_failed_t {
    #[doc = "< Failure reason"]
    pub failure_reason: crate::c_types::c_int,
}
#[doc = " @brief List of stations associated with the Soft-AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_list_t {
    #[doc = "< station list"]
    pub sta: [wifi_sta_info_t; 10usize],
    #[doc = "< number of stations in the list (other entries are invalid)"]
    pub num: crate::c_types::c_int,
}
#[doc = " @brief Received packet radio metadata header, this is the common header at the beginning of all promiscuous mode RX callback buffers"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wifi_pkt_rx_ctrl_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 28usize]>,
}
impl wifi_pkt_rx_ctrl_t {
    #[inline]
    pub fn rssi(&self) -> crate::c_types::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rssi(&mut self, val: crate::c_types::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rate(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rate(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_mode(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sig_mode(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn cwb(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cwb(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smoothing(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_smoothing(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_sounding(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_sounding(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aggregation(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fec_coding(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec_coding(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgi(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgi(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ampdu_cnt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ampdu_cnt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary_channel(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(76usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secondary_channel(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(76usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ant(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(191usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ant(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(191usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_len(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(192usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sig_len(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(192usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_state(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(216usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rx_state(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(216usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rssi: crate::c_types::c_int,
        rate: crate::c_types::c_uint,
        sig_mode: crate::c_types::c_uint,
        mcs: crate::c_types::c_uint,
        cwb: crate::c_types::c_uint,
        smoothing: crate::c_types::c_uint,
        not_sounding: crate::c_types::c_uint,
        aggregation: crate::c_types::c_uint,
        stbc: crate::c_types::c_uint,
        fec_coding: crate::c_types::c_uint,
        sgi: crate::c_types::c_uint,
        ampdu_cnt: crate::c_types::c_uint,
        channel: crate::c_types::c_uint,
        secondary_channel: crate::c_types::c_uint,
        timestamp: crate::c_types::c_uint,
        ant: crate::c_types::c_uint,
        sig_len: crate::c_types::c_uint,
        rx_state: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 28usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 28usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rssi: u32 = unsafe { ::core::mem::transmute(rssi) };
            rssi as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let rate: u32 = unsafe { ::core::mem::transmute(rate) };
            rate as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let sig_mode: u32 = unsafe { ::core::mem::transmute(sig_mode) };
            sig_mode as u64
        });
        __bindgen_bitfield_unit.set(32usize, 7u8, {
            let mcs: u32 = unsafe { ::core::mem::transmute(mcs) };
            mcs as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let cwb: u32 = unsafe { ::core::mem::transmute(cwb) };
            cwb as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let smoothing: u32 = unsafe { ::core::mem::transmute(smoothing) };
            smoothing as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let not_sounding: u32 = unsafe { ::core::mem::transmute(not_sounding) };
            not_sounding as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let aggregation: u32 = unsafe { ::core::mem::transmute(aggregation) };
            aggregation as u64
        });
        __bindgen_bitfield_unit.set(60usize, 2u8, {
            let stbc: u32 = unsafe { ::core::mem::transmute(stbc) };
            stbc as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let fec_coding: u32 = unsafe { ::core::mem::transmute(fec_coding) };
            fec_coding as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sgi: u32 = unsafe { ::core::mem::transmute(sgi) };
            sgi as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let ampdu_cnt: u32 = unsafe { ::core::mem::transmute(ampdu_cnt) };
            ampdu_cnt as u64
        });
        __bindgen_bitfield_unit.set(72usize, 4u8, {
            let channel: u32 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(76usize, 4u8, {
            let secondary_channel: u32 = unsafe { ::core::mem::transmute(secondary_channel) };
            secondary_channel as u64
        });
        __bindgen_bitfield_unit.set(96usize, 32u8, {
            let timestamp: u32 = unsafe { ::core::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit.set(191usize, 1u8, {
            let ant: u32 = unsafe { ::core::mem::transmute(ant) };
            ant as u64
        });
        __bindgen_bitfield_unit.set(192usize, 12u8, {
            let sig_len: u32 = unsafe { ::core::mem::transmute(sig_len) };
            sig_len as u64
        });
        __bindgen_bitfield_unit.set(216usize, 8u8, {
            let rx_state: u32 = unsafe { ::core::mem::transmute(rx_state) };
            rx_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_csi_config_t {
    #[doc = "< enable to receive legacy long training field(lltf) data. Default enabled"]
    pub lltf_en: bool,
    #[doc = "< enable to receive HT long training field(htltf) data. Default enabled"]
    pub htltf_en: bool,
    #[doc = "< enable to receive space time block code HT long training field(stbc-htltf2) data. Default enabled"]
    pub stbc_htltf2_en: bool,
    #[doc = "< enable to generate htlft data by averaging lltf and ht_ltf data when receiving HT packet. Otherwise, use ht_ltf data directly. Default enabled"]
    pub ltf_merge_en: bool,
    #[doc = "< enable to turn on channel filter to smooth adjacent sub-carrier. Disable it to keep independence of adjacent sub-carrier. Default enabled"]
    pub channel_filter_en: bool,
    #[doc = "< manually scale the CSI data by left shifting or automatically scale the CSI data. If set true, please set the shift bits. false: automatically. true: manually. Default false"]
    pub manu_scale: bool,
    #[doc = "< manually left shift bits of the scale of the CSI data. The range of the left shift bits is 0~15"]
    pub shift: u8,
    #[doc = "< enable to dump 802.11 ACK frame, default disabled"]
    pub dump_ack_en: bool,
}
#[doc = " @brief Payload passed to 'buf' parameter of promiscuous mode RX callback."]
#[repr(C)]
pub struct wifi_promiscuous_pkt_t {
    #[doc = "< metadata header"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< Data or management payload. Length of payload is described by rx_ctrl.sig_len. Type of content determined by packet type argument of callback."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = " @brief CSI data type\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_csi_info_t {
    #[doc = "< received packet radio metadata header of the CSI data"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< source MAC address of the CSI data"]
    pub mac: [u8; 6usize],
    #[doc = "< destination MAC address of the CSI data"]
    pub dmac: [u8; 6usize],
    #[doc = "< first four bytes of the CSI data is invalid or not, true indicates the first four bytes is invalid due to hardware limitation"]
    pub first_word_invalid: bool,
    #[doc = "< valid buffer of CSI data"]
    pub buf: *mut i8,
    #[doc = "< valid length of CSI data"]
    pub len: u16,
    #[doc = "< header of the wifi packet"]
    pub hdr: *mut u8,
    #[doc = "< payload of the wifi packet"]
    pub payload: *mut u8,
    #[doc = "< payload len of the wifi packet"]
    pub payload_len: u16,
    #[doc = "< rx sequence number of the wifi packet"]
    pub rx_seq: u16,
}
#[doc = " Configuration for creating event loops"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_event_loop_args_t {
    #[doc = "< size of the event loop queue"]
    pub queue_size: i32,
    #[doc = "< name of the event loop task; if NULL,\na dedicated task is not created for event loop"]
    pub task_name: *const crate::c_types::c_char,
    #[doc = "< priority of the event loop task, ignored if task name is NULL"]
    pub task_priority: UBaseType_t,
    #[doc = "< stack size of the event loop task, ignored if task name is NULL"]
    pub task_stack_size: u32,
    #[doc = "< core to which the event loop task is pinned to,\nignored if task name is NULL"]
    pub task_core_id: BaseType_t,
}
extern "C" {
    #[doc = " @brief Create a new event loop.\n\n @param[in] event_loop_args configuration structure for the event loop to create\n @param[out] event_loop handle to the created event loop\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: event_loop_args or event_loop was NULL\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - ESP_FAIL: Failed to create task loop\n  - Others: Fail"]
    pub fn esp_event_loop_create(
        event_loop_args: *const esp_event_loop_args_t,
        event_loop: *mut esp_event_loop_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an existing event loop.\n\n @param[in] event_loop event loop to delete, must not be NULL\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_delete(event_loop: esp_event_loop_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create default event loop\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - ESP_ERR_INVALID_STATE: Default event loop has already been created\n  - ESP_FAIL: Failed to create task loop\n  - Others: Fail"]
    pub fn esp_event_loop_create_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the default event loop\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_delete_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dispatch events posted to an event loop.\n\n This function is used to dispatch events posted to a loop with no dedicated task, i.e. task name was set to NULL\n in event_loop_args argument during loop creation. This function includes an argument to limit the amount of time\n it runs, returning control to the caller when that time expires (or some time afterwards). There is no guarantee\n that a call to this function will exit at exactly the time of expiry. There is also no guarantee that events have\n been dispatched during the call, as the function might have spent all the allotted time waiting on the event queue.\n Once an event has been dequeued, however, it is guaranteed to be dispatched. This guarantee contributes to not being\n able to exit exactly at time of expiry as (1) blocking on internal mutexes is necessary for dispatching the dequeued\n event, and (2) during  dispatch of the dequeued event there is no way to control the time occupied by handler code\n execution. The guaranteed time of exit is therefore the allotted time + amount of time required to dispatch\n the last dequeued event.\n\n In cases where waiting on the queue times out, ESP_OK is returned and not ESP_ERR_TIMEOUT, since it is\n normal behavior.\n\n @param[in] event_loop event loop to dispatch posted events from, must not be NULL\n @param[in] ticks_to_run number of ticks to run the loop\n\n @note encountering an unknown event that has been posted to the loop will only generate a warning, not an error.\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_run(
        event_loop: esp_event_loop_handle_t,
        ticks_to_run: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to the system event loop (legacy).\n\n This function can be used to register a handler for either: (1) specific events,\n (2) all events of a certain event base, or (3) all events known by the system event loop.\n\n  - specific events: specify exact event_base and event_id\n  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id\n  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id\n\n Registering multiple handlers to events is possible. Registering a single handler to multiple events is\n also possible. However, registering the same handler to the same event multiple times would cause the\n previous registrations to be overwritten.\n\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to a specific loop (legacy).\n\n This function behaves in the same manner as esp_event_handler_register, except the additional\n specification of the event loop to register the handler to.\n\n @param[in] event_loop the event loop to register this handler function to, must not be NULL\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an instance of event handler to a specific loop.\n\n This function can be used to register a handler for either: (1) specific events,\n (2) all events of a certain event base, or (3) all events known by the system event loop.\n\n  - specific events: specify exact event_base and event_id\n  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id\n  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id\n\n Besides the error, the function returns an instance object as output parameter to identify each registration.\n This is necessary to remove (unregister) the registration before the event loop is deleted.\n\n Registering multiple handlers to events, registering a single handler to multiple events as well as registering\n the same handler to the same event multiple times is possible.\n Each registration yields a distinct instance object which identifies it over the registration\n lifetime.\n\n @param[in] event_loop the event loop to register this handler function to, must not be NULL\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n @param[out] instance An event handler instance object related to the registered event handler and data, can be NULL.\n             This needs to be kept if the specific callback instance should be unregistered before deleting the whole\n             event loop. Registering the same event handler multiple times is possible and yields distinct instance\n             objects. The data can be the same for all registrations.\n             If no unregistration is needed, but the handler should be deleted when the event loop is deleted,\n             instance can be NULL.\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @note Calling this function with instance set to NULL is equivalent to calling esp_event_handler_register_with.\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID or instance is NULL\n  - Others: Fail"]
    pub fn esp_event_handler_instance_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
        instance: *mut esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an instance of event handler to the default loop.\n\n This function does the same as esp_event_handler_instance_register_with, except that it registers the\n handler to the default event loop.\n\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n @param[out] instance An event handler instance object related to the registered event handler and data, can be NULL.\n             This needs to be kept if the specific callback instance should be unregistered before deleting the whole\n             event loop. Registering the same event handler multiple times is possible and yields distinct instance\n             objects. The data can be the same for all registrations.\n             If no unregistration is needed, but the handler should be deleted when the event loop is deleted,\n             instance can be NULL.\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @note Calling this function with instance set to NULL is equivalent to calling esp_event_handler_register.\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID or instance is NULL\n  - Others: Fail"]
    pub fn esp_event_handler_instance_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
        instance: *mut esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler with the system event loop (legacy).\n\n Unregisters a handler, so it will no longer be called during dispatch.\n Handlers can be unregistered for any combination of event_base and event_id which were previously registered.\n To unregister a handler, the event_base and event_id arguments must match exactly the arguments passed to\n esp_event_handler_register() when that handler was registered. Passing ESP_EVENT_ANY_BASE and/or ESP_EVENT_ANY_ID\n will only unregister handlers that were registered with the same wildcard arguments.\n\n @note When using ESP_EVENT_ANY_ID, handlers registered to specific event IDs using the same base will not be\n       unregistered. When using ESP_EVENT_ANY_BASE, events registered to specific bases will also not be\n       unregistered. This avoids accidental unregistration of handlers registered by other users or components.\n\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] event_handler the handler to unregister\n\n @return ESP_OK success\n @return ESP_ERR_INVALID_ARG invalid combination of event base and event ID\n @return others fail"]
    pub fn esp_event_handler_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler from a specific event loop (legacy).\n\n This function behaves in the same manner as esp_event_handler_unregister, except the additional specification of\n the event loop to unregister the handler with.\n\n @param[in] event_loop the event loop with which to unregister this handler function, must not be NULL\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] event_handler the handler to unregister\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler instance from a specific event loop.\n\n Unregisters a handler instance, so it will no longer be called during dispatch.\n Handler instances can be unregistered for any combination of event_base and event_id which were previously\n registered. To unregister a handler instance, the event_base and event_id arguments must match exactly the\n arguments passed to esp_event_handler_instance_register() when that handler instance was registered.\n Passing ESP_EVENT_ANY_BASE and/or ESP_EVENT_ANY_ID will only unregister handler instances that were registered\n with the same wildcard arguments.\n\n @note When using ESP_EVENT_ANY_ID, handlers registered to specific event IDs using the same base will not be\n       unregistered. When using ESP_EVENT_ANY_BASE, events registered to specific bases will also not be\n       unregistered. This avoids accidental unregistration of handlers registered by other users or components.\n\n @param[in] event_loop the event loop with which to unregister this handler function, must not be NULL\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] instance the instance object of the registration to be unregistered\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_instance_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        instance: esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler from the system event loop.\n\n This function does the same as esp_event_handler_instance_unregister_with, except that it unregisters the\n handler instance from the default event loop.\n\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] instance the instance object of the registration to be unregistered\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_instance_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        instance: esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the system default event loop. The event loop library keeps a copy of event_data and manages\n the copy's lifetime automatically (allocation + deletion); this ensures that the data the\n handler receives is always valid.\n\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data\n @param[in] ticks_to_wait number of ticks to block on a full event queue\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,\n                      queue full when posting from ISR\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the specified event loop. The event loop library keeps a copy of event_data and manages\n the copy's lifetime automatically (allocation + deletion); this ensures that the data the\n handler receives is always valid.\n\n This function behaves in the same manner as esp_event_post, except the additional specification of the event loop\n to post the event to.\n\n @param[in] event_loop the event loop to post to, must not be NULL\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data\n @param[in] ticks_to_wait number of ticks to block on a full event queue\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,\n                      queue full when posting from ISR\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dumps statistics of all event loops.\n\n Dumps event loop info in the format:\n\n@verbatim\nevent loop\nhandler\nhandler\n...\nevent loop\nhandler\nhandler\n...\n\nwhere:\n\nevent loop\nformat: address,name rx:total_received dr:total_dropped\nwhere:\naddress - memory address of the event loop\nname - name of the event loop, 'none' if no dedicated task\ntotal_received - number of successfully posted events\ntotal_dropped - number of events unsuccessfully posted due to queue being full\n\nhandler\nformat: address ev:base,id inv:total_invoked run:total_runtime\nwhere:\naddress - address of the handler function\nbase,id - the event specified by event base and ID this handler executes\ntotal_invoked - number of times this handler has been invoked\ntotal_runtime - total amount of time used for invoking this handler\n\n@endverbatim\n\n @param[in] file the file stream to output to\n\n @note this function is a noop when CONFIG_ESP_EVENT_LOOP_PROFILING is disabled\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - Others: Fail"]
    pub fn esp_event_dump(file: *mut FILE) -> esp_err_t;
}
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_MD5: esp_crypto_hash_alg_t = 0;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA1: esp_crypto_hash_alg_t = 1;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_MD5: esp_crypto_hash_alg_t = 2;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA1: esp_crypto_hash_alg_t = 3;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA256: esp_crypto_hash_alg_t = 4;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA256: esp_crypto_hash_alg_t = 5;
pub type esp_crypto_hash_alg_t = crate::c_types::c_uint;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_NULL: esp_crypto_cipher_alg_t = 0;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_AES: esp_crypto_cipher_alg_t = 1;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_3DES: esp_crypto_cipher_alg_t = 2;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_DES: esp_crypto_cipher_alg_t = 3;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC2: esp_crypto_cipher_alg_t = 4;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC4: esp_crypto_cipher_alg_t = 5;
pub type esp_crypto_cipher_alg_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_hash {
    _unused: [u8; 0],
}
pub type esp_crypto_hash_t = crypto_hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_cipher {
    _unused: [u8; 0],
}
pub type esp_crypto_cipher_t = crypto_cipher;
#[doc = " @brief The AES 128 encrypt callback function used by esp_wifi.\n\n @param key  Encryption key.\n @param iv  Encryption IV for CBC mode (16 bytes).\n @param data  Data to encrypt in-place.\n @param data_len  Length of data in bytes (must be divisible by 16)"]
pub type esp_aes_128_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        iv: *const crate::c_types::c_uchar,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES 128 decrypt callback function used by esp_wifi.\n\n @param key  Decryption key.\n @param iv  Decryption IV for CBC mode (16 bytes).\n @param data  Data to decrypt in-place.\n @param data_len  Length of data in bytes (must be divisible by 16)\n"]
pub type esp_aes_128_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        iv: *const crate::c_types::c_uchar,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES wrap callback function used by esp_wifi.\n\n @param kek  16-octet Key encryption key (KEK).\n @param n  Length of the plaintext key in 64-bit units;\n @param plain  Plaintext key to be wrapped, n * 64 bits\n @param cipher  Wrapped key, (n + 1) * 64 bits\n"]
pub type esp_aes_wrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const crate::c_types::c_uchar,
        n: crate::c_types::c_int,
        plain: *const crate::c_types::c_uchar,
        cipher: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES unwrap callback function used by esp_wifi.\n\n @param kek  16-octet Key decryption key (KEK).\n @param n  Length of the plaintext key in 64-bit units;\n @param cipher  Wrapped key to be unwrapped, (n + 1) * 64 bits\n @param plain  Plaintext key, n * 64 bits\n"]
pub type esp_aes_unwrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const crate::c_types::c_uchar,
        n: crate::c_types::c_int,
        cipher: *const crate::c_types::c_uchar,
        plain: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The SHA256 callback function used by esp_wifi.\n\n @param key  Key for HMAC operations.\n @param key_len  Length of the key in bytes.\n @param num_elem  Number of elements in the data vector.\n @param addr  Pointers to the data areas.\n @param len  Lengths of the data blocks.\n @param mac  Buffer for the hash (32 bytes).\n"]
pub type esp_hmac_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_int,
        num_elem: crate::c_types::c_int,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_int,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The SHA256 PRF callback function used by esp_wifi.\n\n @param key  Key for PRF.\n @param key_len  Length of the key in bytes.\n @param label  A unique label for each purpose of the PRF.\n @param data  Extra data to bind into the key.\n @param data_len  Length of the data.\n @param buf  Buffer for the generated pseudo-random key.\n @param buf_len  Number of bytes of key to generate.\n"]
pub type esp_sha256_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_int,
        label: *const crate::c_types::c_char,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
        buf: *mut crate::c_types::c_uchar,
        buf_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-MD5 callback function over data buffer (RFC 2104)'\n\n @param key Key for HMAC operations\n @param key_len Length of the key in bytes\n @param data Pointers to the data area\n @param data_len Length of the data area\n @param mac Buffer for the hash (16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-MD5 callback function over data vector (RFC 2104)\n\n @param key Key for HMAC operations\n @param key_len Length of the key in bytes\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param mac Buffer for the hash (16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-SHA1 callback function over data buffer (RFC 2104)\n\n @param key Key for HMAC operations\n @param key_len Length of the key in bytes\n @param data Pointers to the data area\n @param data_len Length of the data area\n @param mac Buffer for the hash (20 bytes)\n Returns: 0 on success, -1 of failure"]
pub type esp_hmac_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-SHA1 callback function over data vector (RFC 2104)\n\n @param key Key for HMAC operations\n @param key_len Length of the key in bytes\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param mac Buffer for the hash (20 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA1-based Pseudo-Random Function (PRF) (IEEE 802.11i, 8.5.1.1) callback function\n\n @param key Key for PRF\n @param key_len Length of the key in bytes\n @param label A unique label for each purpose of the PRF\n @param data Extra data to bind into the key\n @param data_len Length of the data\n @param buf Buffer for the generated pseudo-random key\n @param buf_len Number of bytes of key to generate\n Returns: 0 on success, -1 of failure\n\n This function is used to derive new, cryptographically separate keys from a\n given key (e.g., PMK in IEEE 802.11i)."]
pub type esp_sha1_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        label: *const crate::c_types::c_char,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        buf: *mut crate::c_types::c_uchar,
        buf_len: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA-1 hash callback function for data vector\n\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param mac Buffer for the hash\n Returns: 0 on success, -1 on failure"]
pub type esp_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA1-based key derivation function (PBKDF2) callback function for IEEE 802.11i\n\n @param passphrase ASCII passphrase\n @param ssid SSID\n @param ssid_len SSID length in bytes\n @param iterations Number of iterations to run\n @param buf Buffer for the generated key\n @param buflen Length of the buffer in bytes\n Returns: 0 on success, -1 of failure\n\n This function is used to derive PSK for WPA-PSK. For this protocol,\n iterations is set to 4096 and buflen to 32. This function is described in\n IEEE Std 802.11-2004, Clause H.4. The main construction is from PKCS#5 v2.0."]
pub type esp_pbkdf2_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        passphrase: *const crate::c_types::c_char,
        ssid: *const crate::c_types::c_char,
        ssid_len: crate::c_types::c_uint,
        iterations: crate::c_types::c_int,
        buf: *mut crate::c_types::c_uchar,
        buflen: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief XOR RC4 stream callback function to given data with skip-stream-start\n\n @param key RC4 key\n @param keylen RC4 key length\n @param skip number of bytes to skip from the beginning of the RC4 stream\n @param data data to be XOR'ed with RC4 stream\n @param data_len buf length\n Returns: 0 on success, -1 on failure\n\n Generate RC4 pseudo random stream for the given key, skip beginning of the\n stream, and XOR the end result with the data buffer to perform RC4\n encryption/decryption."]
pub type esp_rc4_skip_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        keylen: crate::c_types::c_uint,
        skip: crate::c_types::c_uint,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief MD5 hash callback function for data vector\n\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param mac Buffer for the hash\n Returns: 0 on success, -1 on failure"]
pub type esp_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Encrypt one AES block callback function\n\n @param ctx Context pointer from aes_encrypt_init()\n @param plain Plaintext data to be encrypted (16 bytes)\n @param crypt Buffer for the encrypted data (16 bytes)"]
pub type esp_aes_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        plain: *const crate::c_types::c_uchar,
        crypt: *mut crate::c_types::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES callback function for encryption\n\n @param key Encryption key\n @param len Key length in bytes (usually 16, i.e., 128 bits)\n Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_encrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        len: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void,
>;
#[doc = " @brief Deinitialize AES encryption callback function\n\n @param ctx Context pointer from aes_encrypt_init()"]
pub type esp_aes_encrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void)>;
#[doc = " @brief Decrypt one AES block callback function\n\n @param ctx Context pointer from aes_encrypt_init()\n @param crypt Encrypted data (16 bytes)\n @param plain Buffer for the decrypted data (16 bytes)"]
pub type esp_aes_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        crypt: *const crate::c_types::c_uchar,
        plain: *mut crate::c_types::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES callback function for decryption\n\n @param key Decryption key\n @param len Key length in bytes (usually 16, i.e., 128 bits)\n Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_decrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        len: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void,
>;
#[doc = " @brief Deinitialize AES decryption callback function\n\n @param ctx Context pointer from aes_encrypt_init()"]
pub type esp_aes_decrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void)>;
#[doc = " @brief One-Key CBC MAC (OMAC1) hash with AES-128 callback function for MIC computation\n\n @param key 128-bit key for the hash operation\n @param data Data buffer for which a MIC is computed\n @param data_len Length of data buffer in bytes\n @param mic Buffer for MIC (128 bits, i.e., 16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_omac1_aes_128_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        data: *const u8,
        data_len: usize,
        mic: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Decrypt data callback function using CCMP (Counter Mode CBC-MAC Protocol OR\n        Counter Mode Cipher Block Chaining Message Authentication\n        Code Protocol) which is used in IEEE 802.11i RSN standard.\n @param tk 128-bit Temporal Key for obtained during 4-way handshake\n @param ieee80211_hdr Pointer to IEEE802.11 frame headeri needed for AAD\n @param data Pointer to encrypted data buffer\n @param data_len Encrypted data length in bytes\n @param decrypted_len Length of decrypted data\n @param espnow_pkt Indicates if it's an ESPNOW packet\n Returns: Pointer to decrypted data on success, NULL on failure"]
pub type esp_ccmp_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        ieee80211_hdr: *const u8,
        data: *const u8,
        data_len: usize,
        decrypted_len: *mut usize,
        espnow_pkt: bool,
    ) -> *mut u8,
>;
#[doc = " @brief Encrypt data callback function using CCMP (Counter Mode CBC-MAC Protocol OR\n        Counter Mode Cipher Block Chaining Message Authentication\n        Code Protocol) which is used in IEEE 802.11i RSN standard.\n @param tk 128-bit Temporal Key for obtained during 4-way handshake\n @param frame Pointer to IEEE802.11 frame including header\n @param len Length of the frame including header\n @param hdrlen Length of the header\n @param pn Packet Number counter\n @param keyid Key ID to be mentioned in CCMP Vector\n @param encrypted_len Length of the encrypted frame including header"]
pub type esp_ccmp_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        frame: *mut u8,
        len: usize,
        hdrlen: usize,
        pn: *mut u8,
        keyid: crate::c_types::c_int,
        encrypted_len: *mut usize,
    ) -> *mut u8,
>;
#[doc = " @brief One-Key GMAC hash callback function with AES for MIC computation\n\n @param key key for the hash operation\n @param keylen key length\n @param iv initialization vector\n @param iv_len initialization vector length\n @param aad aad\n @param aad_len aad length\n @param mic Buffer for MIC (128 bits, i.e., 16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_aes_gmac_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        keylen: usize,
        iv: *const u8,
        iv_len: usize,
        aad: *const u8,
        aad_len: usize,
        mic: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA256 hash callback function for data vector\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param buf Buffer for the hash\n Returns: 0 on success, -1 on failure"]
pub type esp_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: usize,
        addr: *mut *const u8,
        len: *const usize,
        buf: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief CRC32 value callback function in little endian.\n\n @param crc Initial CRC value (result of last calculation or 0 for the first time)\n @param buf Data buffer that used to calculate the CRC value\n @param len Length of the data buffer\n @return CRC32 value"]
pub type esp_crc32_le_t =
    ::core::option::Option<unsafe extern "C" fn(crc: u32, buf: *const u8, len: u32) -> u32>;
#[doc = " @brief The crypto callback function structure used by esp_wifi.\n        The structure can be set as software crypto or the crypto optimized by device's\n        hardware."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wpa_crypto_funcs_t {
    #[doc = "< The crypto callback function structure size"]
    pub size: u32,
    #[doc = "< The crypto callback function structure version"]
    pub version: u32,
    #[doc = "< The SHA256 callback function used by esp_wifi"]
    pub hmac_sha256_vector: esp_hmac_sha256_vector_t,
    #[doc = "< SHA1-based key derivation function (PBKDF2) callback function for IEEE 802.11"]
    pub pbkdf2_sha1: esp_pbkdf2_sha1_t,
    #[doc = "< The AES 128 encrypt callback function used by esp_wifi"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< The AES 128 decrypt callback function used by esp_wifi"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
    #[doc = "< One-Key CBC MAC (OMAC1) hash with AES-128 callback function for MIC computation"]
    pub omac1_aes_128: esp_omac1_aes_128_t,
    #[doc = "< Decrypt data callback function using CCMP"]
    pub ccmp_decrypt: esp_ccmp_decrypt_t,
    #[doc = "< Encrypt data callback function using CCMP"]
    pub ccmp_encrypt: esp_ccmp_encrypt_t,
    #[doc = "< One-Key GMAC hash callback function with AES for MIC computation"]
    pub aes_gmac: esp_aes_gmac_t,
    #[doc = "< SHA256 hash callback function for data vector"]
    pub sha256_vector: esp_sha256_vector_t,
}
#[doc = " @brief The crypto callback function structure used in mesh vendor IE encryption. The\n        structure can be set as software crypto or the crypto optimized by device's\n        hardware."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mesh_crypto_funcs_t {
    #[doc = "< Callback function used in mesh vendor IE encryption"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< Callback function used in mesh vendor IE decryption"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
}
extern "C" {
    #[doc = " @brief Attaches wifi station interface to supplied netif\n\n @param esp_netif instance to attach the wifi station to\n\n @return\n  - ESP_OK on success\n  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_station(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Attaches wifi soft AP interface to supplied netif\n\n @param esp_netif instance to attach the wifi AP to\n\n @return\n  - ESP_OK on success\n  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_ap(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for STA interface\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_sta_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for AP interface\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_ap_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for NAN interface\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_nan_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clears default wifi event handlers for supplied network interface\n\n @param esp_netif instance of corresponding if object\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_clear_default_wifi_driver_and_handlers(
        esp_netif: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI AP. In case of any init error this API aborts.\n\n @note The API creates esp_netif object with default WiFi access point config,\n attaches the netif to wifi and registers wifi handlers to the default event loop.\n This API uses assert() to check for potential errors, so it could abort the program.\n (Note that the default event loop needs to be created prior to calling this API)\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_ap() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI STA. In case of any init error this API aborts.\n\n @note The API creates esp_netif object with default WiFi station config,\n attaches the netif to wifi and registers wifi handlers to the default event loop.\n This API uses assert() to check for potential errors, so it could abort the program.\n (Note that the default event loop needs to be created prior to calling this API)\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_sta() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI NAN. In case of any init error this API aborts.\n\n @note The API creates esp_netif object with default WiFi station config,\n attaches the netif to wifi and registers wifi handlers to the default event loop.\n (Note that the default event loop needs to be created prior to calling this API)\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_nan() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Destroys default WIFI netif created with esp_netif_create_default_wifi_...() API.\n\n @param[in] esp_netif object to detach from WiFi and destroy\n\n @note This API unregisters wifi handlers and detaches the created object from the wifi.\n (this function is a no-operation if esp_netif is NULL)"]
    pub fn esp_netif_destroy_default_wifi(esp_netif: *mut crate::c_types::c_void);
}
extern "C" {
    #[doc = " @brief Creates esp_netif WiFi object based on the custom configuration.\n\n @attention This API DOES NOT register default handlers!\n\n @param[in] wifi_if type of wifi interface\n @param[in] esp_netif_config inherent esp-netif configuration pointer\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_wifi(
        wifi_if: wifi_interface_t,
        esp_netif_config: *const esp_netif_inherent_config_t,
    ) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default STA and AP network interfaces for esp-mesh.\n\n Both netifs are almost identical to the default station and softAP, but with\n DHCP client and server disabled. Please note that the DHCP client is typically\n enabled only if the device is promoted to a root node.\n\n Returns created interfaces which could be ignored setting parameters to NULL\n if an application code does not need to save the interface instances\n for further processing.\n\n @param[out] p_netif_sta pointer where the resultant STA interface is saved (if non NULL)\n @param[out] p_netif_ap pointer where the resultant AP interface is saved (if non NULL)\n\n @return ESP_OK on success"]
    pub fn esp_netif_create_default_wifi_mesh_netifs(
        p_netif_sta: *mut *mut esp_netif_t,
        p_netif_ap: *mut *mut esp_netif_t,
    ) -> esp_err_t;
}
#[doc = " @brief WiFi stack configuration parameters passed to esp_wifi_init call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_init_config_t {
    #[doc = "< WiFi OS functions"]
    pub osi_funcs: *mut wifi_osi_funcs_t,
    #[doc = "< WiFi station crypto functions when connect"]
    pub wpa_crypto_funcs: wpa_crypto_funcs_t,
    #[doc = "< WiFi static RX buffer number"]
    pub static_rx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi dynamic RX buffer number"]
    pub dynamic_rx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi TX buffer type"]
    pub tx_buf_type: crate::c_types::c_int,
    #[doc = "< WiFi static TX buffer number"]
    pub static_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi dynamic TX buffer number"]
    pub dynamic_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi RX MGMT buffer type"]
    pub rx_mgmt_buf_type: crate::c_types::c_int,
    #[doc = "< WiFi RX MGMT buffer number"]
    pub rx_mgmt_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi TX cache buffer number"]
    pub cache_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi channel state information enable flag"]
    pub csi_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMPDU RX feature enable flag"]
    pub ampdu_rx_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMPDU TX feature enable flag"]
    pub ampdu_tx_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMSDU TX feature enable flag"]
    pub amsdu_tx_enable: crate::c_types::c_int,
    #[doc = "< WiFi NVS flash enable flag"]
    pub nvs_enable: crate::c_types::c_int,
    #[doc = "< Nano option for printf/scan family enable flag"]
    pub nano_enable: crate::c_types::c_int,
    #[doc = "< WiFi Block Ack RX window size"]
    pub rx_ba_win: crate::c_types::c_int,
    #[doc = "< WiFi Task Core ID"]
    pub wifi_task_core_id: crate::c_types::c_int,
    #[doc = "< WiFi softAP maximum length of the beacon"]
    pub beacon_max_len: crate::c_types::c_int,
    #[doc = "< WiFi management short buffer number, the minimum value is 6, the maximum value is 32"]
    pub mgmt_sbuf_num: crate::c_types::c_int,
    #[doc = "< Enables additional WiFi features and capabilities"]
    pub feature_caps: u64,
    #[doc = "< WiFi Power Management for station at disconnected status"]
    pub sta_disconnected_pm: bool,
    #[doc = "< Maximum encrypt number of peers supported by espnow"]
    pub espnow_max_encrypt_num: crate::c_types::c_int,
    #[doc = "< WiFi TX HE TB QUEUE number for STA HE TB PPDU transmission"]
    pub tx_hetb_queue_num: crate::c_types::c_int,
    #[doc = "< enable dump sigb field"]
    pub dump_hesigb_enable: bool,
    #[doc = "< WiFi init magic number, it should be the last field"]
    pub magic: crate::c_types::c_int,
}
extern "C" {
    #[doc = " @addtogroup WPA_APIs\n @{"]
    pub static g_wifi_default_wpa_crypto_funcs: wpa_crypto_funcs_t;
}
extern "C" {
    pub static mut g_wifi_osi_funcs: wifi_osi_funcs_t;
}
extern "C" {
    #[doc = " @brief  Initialize WiFi\n         Allocate resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n         WiFi NVS structure etc. This WiFi also starts WiFi task\n\n @attention 1. This API must be called before all other WiFi API can be called\n @attention 2. Always use WIFI_INIT_CONFIG_DEFAULT macro to initialize the configuration to default values, this can\n               guarantee all the fields get correct value when more fields are added into wifi_init_config_t\n               in future release. If you want to set your own initial values, overwrite the default values\n               which are set by WIFI_INIT_CONFIG_DEFAULT. Please be notified that the field 'magic' of\n               wifi_init_config_t should always be WIFI_INIT_CONFIG_MAGIC!\n\n @param  config pointer to WiFi initialized configuration structure; can point to a temporary variable.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_NO_MEM: out of memory\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Deinit WiFi\n         Free all resource allocated in esp_wifi_init and stop WiFi task\n\n @attention 1. This API should be called if you want to remove WiFi driver from the system\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi operating mode\n\n            Set the WiFi operating mode as station, soft-AP, station+soft-AP or NAN.\n            The default mode is station mode.\n\n @param     mode  WiFi operating mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_mode(mode: wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get current operating mode of WiFi\n\n @param[out]  mode  store current WiFi mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_mode(mode: *mut wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start WiFi according to current configuration\n         If mode is WIFI_MODE_STA, it creates station control block and starts station\n         If mode is WIFI_MODE_AP, it creates soft-AP control block and starts soft-AP\n         If mode is WIFI_MODE_APSTA, it creates soft-AP and station control block and starts soft-AP and station\n         If mode is WIFI_MODE_NAN, it creates NAN control block and starts NAN\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: It doesn't normally happen, the function called inside the API was passed invalid argument, user should check if the wifi related config is correct\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong\n    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop WiFi\n         If mode is WIFI_MODE_STA, it stops station and frees station control block\n         If mode is WIFI_MODE_AP, it stops soft-AP and frees soft-AP control block\n         If mode is WIFI_MODE_APSTA, it stops station/soft-AP and frees station/soft-AP control block\n         If mode is WIFI_MODE_NAN, it stops NAN and frees NAN control block\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restore WiFi stack persistent settings to default values\n\n This function will reset settings made using the following APIs:\n - esp_wifi_set_bandwidth,\n - esp_wifi_set_protocol,\n - esp_wifi_set_config related\n - esp_wifi_set_mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_restore() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Connect WiFi station to the AP.\n\n @attention 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode\n @attention 2. If station interface is connected to an AP, call esp_wifi_disconnect to disconnect.\n @attention 3. The scanning triggered by esp_wifi_scan_start() will not be effective until connection between device and the AP is established.\n               If device is scanning and connecting at the same time, it will abort scanning and return a warning message and error\n               number ESP_ERR_WIFI_STATE.\n @attention 4. This API attempts to connect to an Access Point (AP) only once. To enable reconnection in case of a connection failure, please use\n               the 'failure_retry_cnt' feature in the 'wifi_sta_config_t'. Users are suggested to implement reconnection logic in their application\n               for scenarios where the specified AP does not exist, or reconnection is desired after the device has received a disconnect event.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_MODE: WiFi mode error\n    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong\n    - ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid"]
    pub fn esp_wifi_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Disconnect WiFi station from the AP.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_disconnect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Currently this API is just an stub API\n\n\n @return\n    - ESP_OK: succeed\n    - others: fail"]
    pub fn esp_wifi_clear_fast_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     deauthenticate all stations or associated id equals to aid\n\n @param     aid  when aid is 0, deauthenticate all stations, otherwise deauthenticate station whose associated id is aid\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    pub fn esp_wifi_deauth_sta(aid: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Scan all available APs.\n\n @attention If this API is called, the found APs are stored in WiFi driver dynamic allocated memory. And then\n            can be freed in esp_wifi_scan_get_ap_records(), esp_wifi_scan_get_ap_record() or esp_wifi_clear_ap_list(),\n            so call any one to free the memory once the scan is done.\n @attention The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds.\n            Values above 1500ms may cause station to disconnect from AP and are not recommended.\n\n @param     config  configuration settings for scanning, if set to NULL default settings will be used\n                    of which default values are show_hidden:false, scan_type:active, scan_time.active.min:0,\n                    scan_time.active.max:120 milliseconds, scan_time.passive:360 milliseconds\n                    home_chan_dwell_time:30ms\n\n @param     block if block is true, this API will block the caller until the scan is done, otherwise\n                         it will return immediately\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_WIFI_TIMEOUT: blocking scan is timeout\n    - ESP_ERR_WIFI_STATE: wifi still connecting when invoke esp_wifi_scan_start\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_scan_start(config: *const wifi_scan_config_t, block: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set default parameters used for scanning by station.\n\n @attention The values set using this API are also used for scans used while connecting.\n\n @attention The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds.\n\n @attention The home_chan_dwell_time needs to be a minimum of 30ms and a maximum of 150ms.\n\n @attention Set any of the parameters to 0 to indicate using the default parameters -\n            scan_time.active.min : 0ms, scan_time.active.max : 120ms home_chan_dwell_time : 30ms\n            scan_time.passive : 360ms\n\n @attention Default values can be retrieved using the macro WIFI_SCAN_PARAMS_DEFAULT_CONFIG()\n\n @attention Set the config parameter to NULL to reset previously set scan parameters to their default values.\n\n @param     config  default configuration settings for all scans by stations\n\n @return\n    - ESP_OK: succeed\n    - ESP_FAIL: failed as station mode has not been started yet\n    - ESP_ERR_INVALID_ARG: values provided do not satisfy the requirements\n    - ESP_ERR_NOT_SUPPORTED: This API is not supported in AP mode yet\n    - ESP_ERR_INVALID_STATE: a scan/connect is in progress right now, cannot change scan parameters\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_scan_parameters(config: *const wifi_scan_default_params_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get default parameters used for scanning by station.\n\n @param     config  structure variable within which scan default params will be stored\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: passed parameter does not point to a valid memory\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_get_scan_parameters(config: *mut wifi_scan_default_params_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop the scan in process\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_scan_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get number of APs found in last scan\n\n @param[out] number  store number of APs found in last scan\n\n @attention This API can only be called when the scan is completed, otherwise it may get wrong value.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_scan_get_ap_num(number: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AP list found in last scan.\n\n @attention  This API will free all memory occupied by scanned AP list.\n\n @param[inout]  number As input param, it stores max AP number ap_records can hold.\n                As output param, it receives the actual AP number this API returns.\n @param         ap_records  wifi_ap_record_t array to hold the found APs\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_NO_MEM: out of memory"]
    pub fn esp_wifi_scan_get_ap_records(
        number: *mut u16,
        ap_records: *mut wifi_ap_record_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get one AP record from the scanned AP list.\n\n @attention  Different from esp_wifi_scan_get_ap_records(), this API only gets one AP record\n             from the scanned AP list each time. This API will free the memory of one AP record,\n             if the user doesn't get all records in the scannned AP list, then needs to call esp_wifi_clear_ap_list()\n             to free the remaining memory.\n\n @param[out] ap_record  pointer to one AP record\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_FAIL: scan APs is NULL, means all AP records fetched or no AP found"]
    pub fn esp_wifi_scan_get_ap_record(ap_record: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Clear AP list found in last scan\n\n @attention This API will free all memory occupied by scanned AP list.\n            When the obtained AP list fails, AP records must be cleared,otherwise it may cause memory leakage.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_INVALID_ARG: It doesn't normally happen, the function called inside the API was passed invalid argument, user should check if the wifi related config is correct"]
    pub fn esp_wifi_clear_ap_list() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get information of AP to which the device is associated with\n\n @attention When the obtained country information is empty, it means that the AP does not carry country information\n\n @param     ap_info  the wifi_ap_record_t to hold AP information\n            sta can get the connected ap's phy mode info through the struct member\n            phy_11b，phy_11g，phy_11n，phy_lr in the wifi_ap_record_t struct.\n            For example, phy_11b = 1 imply that ap support 802.11b mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_CONN: The station interface don't initialized\n    - ESP_ERR_WIFI_NOT_CONNECT: The station is in disconnect status"]
    pub fn esp_wifi_sta_get_ap_info(ap_info: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi power save type\n\n @attention Default power save type is WIFI_PS_MIN_MODEM.\n\n @param     type  power save type\n\n @return    ESP_OK: succeed"]
    pub fn esp_wifi_set_ps(type_: wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi power save type\n\n @attention Default power save type is WIFI_PS_MIN_MODEM.\n\n @param[out]  type: store current power save type\n\n @return    ESP_OK: succeed"]
    pub fn esp_wifi_get_ps(type_: *mut wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of specified interface\n            The default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N).\n            if CONFIG_SOC_WIFI_HE_SUPPORT and band is 2.4G, the default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_11AX).\n            if CONFIG_SOC_WIFI_HE_SUPPORT and band is 5G, the default protocol is (WIFI_PROTOCOL_11A|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_11AC|WIFI_PROTOCOL_11AX).\n\n @attention 2.4G: Support 802.11b or 802.11bg or 802.11bgn or 802.11bgnax or LR mode\n            5G: Support 802.11a or 802.11an or 802.11anac or 802.11anacax\n\n @param     ifx  interfaces\n @param     protocol_bitmap  WiFi protocol bitmap\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_protocol(ifx: wifi_interface_t, protocol_bitmap: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the current protocol bitmap of the specified interface\n\n @param     ifx  interface\n @param[out] protocol_bitmap  store current WiFi protocol bitmap of interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_get_protocol(ifx: wifi_interface_t, protocol_bitmap: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the bandwidth of specified interface\n\n @attention 1. API return false if try to configure an interface that is not enabled\n @attention 2. WIFI_BW_HT40 is supported only when the interface support 11N\n\n @param     ifx  interface to be configured\n @param     bw  bandwidth\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_bandwidth(ifx: wifi_interface_t, bw: wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the bandwidth of specified interface\n\n @attention 1. API return false if try to get a interface that is not enable\n\n @param     ifx interface to be configured\n @param[out] bw  store bandwidth of interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_bandwidth(ifx: wifi_interface_t, bw: *mut wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set primary/secondary channel of device\n\n @attention 1. This API should be called after esp_wifi_start() and before esp_wifi_stop()\n @attention 2. When device is in STA mode, this API should not be called when STA is scanning or connecting to an external AP\n @attention 3. When device is in softAP mode, this API should not be called when softAP has connected to external STAs\n @attention 4. When device is in STA+softAP mode, this API should not be called when in the scenarios described above\n @attention 5. The channel info set by this API will not be stored in NVS. So If you want to remember the channel used before wifi stop,\n               you need to call this API again after wifi start, or you can call `esp_wifi_set_config()` to store the channel info in NVS.\n\n @param     primary  for HT20, primary is the channel number, for HT40, primary is the primary channel\n @param     second   for HT20, second is ignored, for HT40, second is the second channel\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_set_channel(primary: u8, second: wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the primary/secondary channel of device\n\n @attention 1. API return false if try to get a interface that is not enable\n\n @param     primary   store current primary channel\n @param[out]  second  store current second channel\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_channel(primary: *mut u8, second: *mut wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country info\n\n @attention 1. It is discouraged to call this API since this doesn't validate the per-country rules,\n               it's up to the user to fill in all fields according to local regulations.\n               Please use esp_wifi_set_country_code instead.\n @attention 2. The default country is \"01\" (world safe mode) {.cc=\"01\", .schan=1, .nchan=11, .policy=WIFI_COUNTRY_POLICY_AUTO}.\n @attention 3. The third octet of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '.\n @attention 4. When the country policy is WIFI_COUNTRY_POLICY_AUTO, the country info of the AP to which\n               the station is connected is used. E.g. if the configured country info is {.cc=\"US\", .schan=1, .nchan=11}\n               and the country info of the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14}\n               then the country info that will be used is {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected\n               from the AP the country info is set back to the country info of the station automatically,\n               {.cc=\"US\", .schan=1, .nchan=11} in the example.\n @attention 5. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, then the configured country info is used always.\n @attention 6. When the country info is changed because of configuration or because the station connects to a different\n               external AP, the country IE in probe response/beacon of the soft-AP is also changed.\n @attention 7. The country configuration is stored into flash.\n @attention 8. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the\n               country info.\n\n @param     country   the configured country info\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country(country: *const wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country info\n\n @param     country  country info\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country(country: *mut wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set MAC address of WiFi station, soft-AP or NAN interface.\n\n @attention 1. This API can only be called when the interface is disabled\n @attention 2. Above mentioned interfaces have different MAC addresses, do not set them to be the same.\n @attention 3. The bit 0 of the first byte of MAC address can not be 1. For example, the MAC address\n      can set to be \"1a:XX:XX:XX:XX:XX\", but can not be \"15:XX:XX:XX:XX:XX\".\n\n @param     ifx  interface\n @param     mac  the MAC address\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_WIFI_MAC: invalid mac address\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_mac(ifx: wifi_interface_t, mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mac of specified interface\n\n @param      ifx  interface\n @param[out] mac  store mac of the interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_mac(ifx: wifi_interface_t, mac: *mut u8) -> esp_err_t;
}
#[doc = " @brief The RX callback function in the promiscuous mode.\n        Each time a packet is received, the callback function will be called.\n\n @param buf  Data received. Type of data in buffer (wifi_promiscuous_pkt_t or wifi_pkt_rx_ctrl_t) indicated by 'type' parameter.\n @param type  promiscuous packet type.\n"]
pub type wifi_promiscuous_cb_t = ::core::option::Option<
    unsafe extern "C" fn(buf: *mut crate::c_types::c_void, type_: wifi_promiscuous_pkt_type_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function in the promiscuous mode.\n\n Each time a packet is received, the registered callback function will be called.\n\n @param cb  callback\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Enable the promiscuous mode.\n\n @param     en  false - disable, true - enable\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous mode.\n\n @param[out] en  store the current status of promiscuous mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous(en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the promiscuous mode packet type filter.\n\n @note The default filter is to filter all packets except WIFI_PKT_MISC\n\n @param filter the packet type filtered in promiscuous mode.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_filter(filter: *const wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous filter.\n\n @param[out] filter  store the current status of promiscuous filter\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_filter(filter: *mut wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable subtype filter of the control packet in promiscuous mode.\n\n @note The default filter is to filter none control packet.\n\n @param filter the subtype of the control packet filtered in promiscuous mode.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_ctrl_filter(
        filter: *const wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the subtype filter of the control packet in promiscuous mode.\n\n @param[out] filter  store the current status of subtype filter of the control packet in promiscuous mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_ctrl_filter(
        filter: *mut wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the configuration of the STA, AP or NAN\n\n @attention 1. This API can be called only when specified interface is enabled, otherwise, API fail\n @attention 2. For station configuration, bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP.\n @attention 3. ESP devices are limited to only one channel, so when in the soft-AP+station mode, the soft-AP will adjust its channel automatically to be the same as\n               the channel of the station.\n @attention 4. The configuration will be stored in NVS for station and soft-AP\n\n @param     interface  interface\n @param     conf  station, soft-AP or NAN configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_WIFI_MODE: invalid mode\n    - ESP_ERR_WIFI_PASSWORD: invalid password\n    - ESP_ERR_WIFI_NVS: WiFi internal NVS error\n    - others: refer to the error code in esp_err.h"]
    pub fn esp_wifi_set_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get configuration of specified interface\n\n @param     interface  interface\n @param[out]  conf  station or soft-AP configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get STAs associated with soft-AP\n\n @attention SSC only API\n\n @param[out] sta  station list\n             ap can get the connected sta's phy mode info through the struct member\n             phy_11b，phy_11g，phy_11n，phy_lr in the wifi_sta_info_t struct.\n             For example, phy_11b = 1 imply that sta support 802.11b mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_list(sta: *mut wifi_sta_list_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AID of STA connected with soft-AP\n\n @param     mac  STA's mac address\n @param[out]  aid  Store the AID corresponding to STA mac\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_NOT_FOUND: Requested resource not found\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_aid(mac: *const u8, aid: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi API configuration storage type\n\n @attention 1. The default value is WIFI_STORAGE_FLASH\n\n @param     storage : storage type\n\n @return\n   - ESP_OK: succeed\n   - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n   - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_storage(storage: wifi_storage_t) -> esp_err_t;
}
#[doc = " @brief     Function signature for received Vendor-Specific Information Element callback.\n @param     ctx Context argument, as passed to esp_wifi_set_vendor_ie_cb() when registering callback.\n @param     type Information element type, based on frame type received.\n @param     sa Source 802.11 address.\n @param     vnd_ie Pointer to the vendor specific element data received.\n @param     rssi Received signal strength indication."]
pub type esp_vendor_ie_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        type_: wifi_vendor_ie_type_t,
        sa: *const u8,
        vnd_ie: *const vendor_ie_data_t,
        rssi: crate::c_types::c_int,
    ),
>;
extern "C" {
    #[doc = " @brief     Set 802.11 Vendor-Specific Information Element\n\n @param     enable If true, specified IE is enabled. If false, specified IE is removed.\n @param     type Information Element type. Determines the frame type to associate with the IE.\n @param     idx  Index to set or clear. Each IE type can be associated with up to two elements (indices 0 & 1).\n @param     vnd_ie Pointer to vendor specific element data. First 6 bytes should be a header with fields matching vendor_ie_data_t.\n            If enable is false, this argument is ignored and can be NULL. Data does not need to remain valid after the function returns.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init()\n    - ESP_ERR_INVALID_ARG: Invalid argument, including if first byte of vnd_ie is not WIFI_VENDOR_IE_ELEMENT_ID (0xDD)\n      or second byte is an invalid length.\n    - ESP_ERR_NO_MEM: Out of memory"]
    pub fn esp_wifi_set_vendor_ie(
        enable: bool,
        type_: wifi_vendor_ie_type_t,
        idx: wifi_vendor_ie_id_t,
        vnd_ie: *const crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register Vendor-Specific Information Element monitoring callback.\n\n @param     cb   Callback function\n @param     ctx  Context argument, passed to callback function.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_vendor_ie_cb(
        cb: esp_vendor_ie_cb_t,
        ctx: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set maximum transmitting power after WiFi start.\n\n @attention 1. Maximum power before wifi startup is limited by PHY init data bin.\n @attention 2. The value set by this API will be mapped to the max_tx_power of the structure wifi_country_t variable.\n @attention 3. Mapping Table {Power, max_tx_power} = {{8,   2}, {20,  5}, {28,  7}, {34,  8}, {44, 11},\n                                                      {52, 13}, {56, 14}, {60, 15}, {66, 16}, {72, 18}, {80, 20}}.\n @attention 4. Param power unit is 0.25dBm, range is [8, 84] corresponding to 2dBm - 20dBm.\n @attention 5. Relationship between set value and actual value. As follows: {set value range, actual value} = {{[8,  19],8}, {[20, 27],20}, {[28, 33],28}, {[34, 43],34}, {[44, 51],44}, {[52, 55],52}, {[56, 59],56}, {[60, 65],60}, {[66, 71],66}, {[72, 79],72}, {[80, 84],80}}.\n\n @param     power  Maximum WiFi transmitting power.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument, e.g. parameter is out of range"]
    pub fn esp_wifi_set_max_tx_power(power: i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get maximum transmitting power after WiFi start\n\n @param     power Maximum WiFi transmitting power, unit is 0.25dBm.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_max_tx_power(power: *mut i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mask to enable or disable some WiFi events\n\n @attention 1. Mask can be created by logical OR of various WIFI_EVENT_MASK_ constants.\n               Events which have corresponding bit set in the mask will not be delivered to the system event handler.\n @attention 2. Default WiFi event mask is WIFI_EVENT_MASK_AP_PROBEREQRECVED.\n @attention 3. There may be lots of stations sending probe request data around.\n               Don't unmask this event unless you need to receive probe request data.\n\n @param     mask  WiFi event mask.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_event_mask(mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mask of WiFi events\n\n @param     mask  WiFi event mask.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_event_mask(mask: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send raw ieee80211 data\n\n @attention Currently only support for sending beacon/probe request/probe response/action and non-QoS\n            data frame\n\n @param     ifx interface if the Wi-Fi mode is Station, the ifx should be WIFI_IF_STA. If the Wi-Fi\n            mode is SoftAP, the ifx should be WIFI_IF_AP. If the Wi-Fi mode is Station+SoftAP, the\n            ifx should be WIFI_IF_STA or WIFI_IF_AP. If the ifx is wrong, the API returns ESP_ERR_WIFI_IF.\n @param     buffer raw ieee80211 buffer\n @param     len the length of raw buffer, the len must be <= 1500 Bytes and >= 24 Bytes\n @param     en_sys_seq indicate whether use the internal sequence number. If en_sys_seq is false, the\n            sequence in raw buffer is unchanged, otherwise it will be overwritten by WiFi driver with\n            the system sequence number.\n            Generally, if esp_wifi_80211_tx is called before the Wi-Fi connection has been set up, both\n            en_sys_seq==true and en_sys_seq==false are fine. However, if the API is called after the Wi-Fi\n            connection has been set up, en_sys_seq must be true, otherwise ESP_ERR_INVALID_ARG is returned.\n\n @return\n    - ESP_OK: success\n    - ESP_ERR_WIFI_IF: Invalid interface\n    - ESP_ERR_INVALID_ARG: Invalid parameter\n    - ESP_ERR_WIFI_NO_MEM: out of memory"]
    pub fn esp_wifi_80211_tx(
        ifx: wifi_interface_t,
        buffer: *const crate::c_types::c_void,
        len: crate::c_types::c_int,
        en_sys_seq: bool,
    ) -> esp_err_t;
}
#[doc = " @brief The RX callback function of Channel State Information(CSI)  data.\n\n        Each time a CSI data is received, the callback function will be called.\n\n @param ctx context argument, passed to esp_wifi_set_csi_rx_cb() when registering callback function.\n @param data CSI data received. The memory that it points to will be deallocated after callback function returns.\n"]
pub type wifi_csi_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void, data: *mut wifi_csi_info_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function of CSI data.\n\n        Each time a CSI data is received, the callback function will be called.\n\n @param cb  callback\n @param ctx context argument, passed to callback function\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_csi_rx_cb(cb: wifi_csi_cb_t, ctx: *mut crate::c_types::c_void)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set CSI data configuration\n\n @param config configuration\n\n return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi_config(config: *const wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get CSI data configuration\n\n @param config configuration\n\n return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_csi_config(config: *mut wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable CSI\n\n @param en true - enable, false - disable\n\n return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna GPIO configuration\n\n @param     config  Antenna GPIO configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: Invalid argument, e.g. parameter is NULL, invalid GPIO number etc"]
    pub fn esp_wifi_set_ant_gpio(config: *const wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna GPIO configuration\n\n @param     config  Antenna GPIO configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant_gpio(config: *mut wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna configuration\n\n @param     config  Antenna configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: Invalid argument, e.g. parameter is NULL, invalid antenna mode or invalid GPIO number"]
    pub fn esp_wifi_set_ant(config: *const wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna configuration\n\n @param     config  Antenna configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant(config: *mut wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the TSF time\n             In Station mode or SoftAP+Station mode if station is not connected or station doesn't receive at least\n             one beacon after connected, will return 0\n\n @attention  Enabling power save may cause the return value inaccurate, except WiFi modem sleep\n\n @param      interface The interface whose tsf_time is to be retrieved.\n\n @return     0 or the TSF time"]
    pub fn esp_wifi_get_tsf_time(interface: wifi_interface_t) -> i64;
}
extern "C" {
    #[doc = " @brief     Set the inactive time of the STA or AP\n\n @attention 1. For Station, If the station does not receive a beacon frame from the connected SoftAP during the inactive time,\n               disconnect from SoftAP. Default 6s.\n @attention 2. For SoftAP, If the softAP doesn't receive any data from the connected STA during inactive time,\n               the softAP will force deauth the STA. Default is 300s.\n @attention 3. The inactive time configuration is not stored into flash\n\n @param     ifx  interface to be configured.\n @param     sec  Inactive time. Unit seconds.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument, For Station, if sec is less than 3. For SoftAP, if sec is less than 10."]
    pub fn esp_wifi_set_inactive_time(ifx: wifi_interface_t, sec: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get inactive time of specified interface\n\n @param     ifx  Interface to be configured.\n @param     sec  Inactive time. Unit seconds.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_inactive_time(ifx: wifi_interface_t, sec: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Dump WiFi statistics\n\n @param     modules statistic modules to be dumped\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_statis_dump(modules: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set RSSI threshold, if average rssi gets lower than threshold, WiFi task will post event WIFI_EVENT_STA_BSS_RSSI_LOW.\n\n @attention  If the user wants to receive another WIFI_EVENT_STA_BSS_RSSI_LOW event after receiving one, this API needs to be\n             called again with an updated/same RSSI threshold.\n\n @param      rssi threshold value in dbm between -100 to 10\n             Note that in some rare cases where signal strength is very strong, rssi values can be slightly positive.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_rssi_threshold(rssi: i32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Start an FTM Initiator session by sending FTM request\n             If successful, event WIFI_EVENT_FTM_REPORT is generated with the result of the FTM procedure\n\n @attention  1. Use this API only in Station mode.\n @attention  2. If FTM is initiated on a different channel than Station is connected in or internal SoftAP is started in,\n                FTM defaults to a single burst in ASAP mode.\n\n @param      cfg  FTM Initiator session configuration\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_initiate_session(cfg: *mut wifi_ftm_initiator_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      End the ongoing FTM Initiator session\n\n @attention  This API works only on FTM Initiator\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_end_session() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set offset in cm for FTM Responder. An equivalent offset is calculated in picoseconds\n             and added in TOD of FTM Measurement frame (T1).\n\n @attention  Use this API only in AP mode before performing FTM as responder\n\n @param      offset_cm  T1 Offset to be added in centimeters\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_resp_set_offset(offset_cm: i16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get FTM measurements report copied into a user provided buffer.\n\n @attention  1. To get the FTM report, user first needs to allocate a buffer of size\n                (sizeof(wifi_ftm_report_entry_t) * num_entries) where the API will fill up to num_entries\n                valid FTM measurements in the buffer. Total number of entries can be found in the event\n                WIFI_EVENT_FTM_REPORT as ftm_report_num_entries\n @attention  2. The internal FTM report is freed upon use of this API which means the API can only be used\n                once after every FTM session initiated\n @attention  3. Passing the buffer as NULL merely frees the FTM report\n\n @param      report  Pointer to the buffer for receiving the FTM report\n @param      num_entries Number of FTM report entries to be filled in the report\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_get_report(
        report: *mut wifi_ftm_report_entry_t,
        num_entries: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Enable or disable 11b rate of specified interface\n\n @attention  1. This API should be called after esp_wifi_init() and before esp_wifi_start().\n @attention  2. Only when really need to disable 11b rate call this API otherwise don't call this.\n\n @param      ifx  Interface to be configured.\n @param      disable true means disable 11b rate while false means enable 11b rate.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_11b_rate(ifx: wifi_interface_t, disable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set wake interval for connectionless modules to wake up periodically.\n\n @attention 1. Only one wake interval for all connectionless modules.\n @attention 2. This configuration could work at connected status.\n               When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status.\n @attention 3. Event WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START would be posted each time wake interval starts.\n @attention 4. Recommend to configure interval in multiples of hundred. (e.g. 100ms)\n @attention 5. Recommend to configure interval to ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE to get stable performance at coexistence mode.\n\n @param      wake_interval  Milliseconds after would the chip wake up, from 1 to 65535."]
    pub fn esp_wifi_connectionless_module_set_wake_interval(wake_interval: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Request extra reference of Wi-Fi radio.\n             Wi-Fi keep active state(RF opened) to be able to receive packets.\n\n @attention  Please pair the use of `esp_wifi_force_wakeup_acquire` with `esp_wifi_force_wakeup_release`.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_force_wakeup_acquire() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Release extra reference of Wi-Fi radio.\n             Wi-Fi go to sleep state(RF closed) if no more use of radio.\n\n @attention  Please pair the use of `esp_wifi_force_wakeup_acquire` with `esp_wifi_force_wakeup_release`.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_force_wakeup_release() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country\n\n @attention 1. When ieee80211d_enabled, the country info of the AP to which\n               the station is connected is used. E.g. if the configured country is US\n               and the country info of the AP to which the station is connected is JP\n               then the country info that will be used is JP. If the station disconnected\n               from the AP the country info is set back to the country info of the station automatically,\n               US in the example.\n @attention 2. When ieee80211d_enabled is disabled, then the configured country info is used always.\n @attention 3. When the country info is changed because of configuration or because the station connects to a different\n               external AP, the country IE in probe response/beacon of the soft-AP is also changed.\n @attention 4. The country configuration is stored into flash.\n @attention 5. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the\n               country info.\n @attention 6. Supported country codes are \"01\"(world safe mode) \"AT\",\"AU\",\"BE\",\"BG\",\"BR\",\n               \"CA\",\"CH\",\"CN\",\"CY\",\"CZ\",\"DE\",\"DK\",\"EE\",\"ES\",\"FI\",\"FR\",\"GB\",\"GR\",\"HK\",\"HR\",\"HU\",\n               \"IE\",\"IN\",\"IS\",\"IT\",\"JP\",\"KR\",\"LI\",\"LT\",\"LU\",\"LV\",\"MT\",\"MX\",\"NL\",\"NO\",\"NZ\",\"PL\",\"PT\",\n               \"RO\",\"SE\",\"SI\",\"SK\",\"TW\",\"US\"\n\n @attention 7. When country code \"01\" (world safe mode) is set, SoftAP mode won't contain country IE.\n @attention 8. The default country is \"01\" (world safe mode) and ieee80211d_enabled is TRUE.\n @attention 9. The third octet of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '.\n\n @param     country   the configured country ISO code\n @param     ieee80211d_enabled   802.11d is enabled or not\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country_code(
        country: *const crate::c_types::c_char,
        ieee80211d_enabled: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country code\n\n @param     country  country code\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country_code(country: *mut crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config 80211 tx rate of specified interface\n\n @attention  1. This API should be called after esp_wifi_init() and before esp_wifi_start().\n\n @param      ifx  Interface to be configured.\n @param      rate Phy rate to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_80211_tx_rate(ifx: wifi_interface_t, rate: wifi_phy_rate_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Disable PMF configuration for specified interface\n\n @attention  This API should be called after esp_wifi_set_config() and before esp_wifi_start().\n\n @param      ifx  Interface to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_disable_pmf_config(ifx: wifi_interface_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the Association id assigned to STA by AP\n\n @param[out] aid  store the aid\n\n @attention aid = 0 if station is not connected to AP.\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_get_aid(aid: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated phymode after connection.\n\n @param[out] phymode  store the negotiated phymode.\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_get_negotiated_phymode(phymode: *mut wifi_phy_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config dynamic carrier sense\n\n @attention  This API should be called after esp_wifi_start().\n\n @param      enabled Dynamic carrier sense is enabled or not.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_set_dynamic_cs(enabled: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the rssi information of AP to which the device is associated with\n\n @attention 1. This API should be called after station connected to AP.\n @attention 2. Use this API only in WIFI_MODE_STA or WIFI_MODE_APSTA mode.\n\n @param      rssi store the rssi info received from last beacon.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_FAIL: failed"]
    pub fn esp_wifi_sta_get_rssi(rssi: *mut crate::c_types::c_int) -> esp_err_t;
}
#[doc = "< protocol: ESPTouch"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH: smartconfig_type_t = 0;
#[doc = "< protocol: AirKiss"]
pub const smartconfig_type_t_SC_TYPE_AIRKISS: smartconfig_type_t = 1;
#[doc = "< protocol: ESPTouch and AirKiss"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_AIRKISS: smartconfig_type_t = 2;
#[doc = "< protocol: ESPTouch v2"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_V2: smartconfig_type_t = 3;
pub type smartconfig_type_t = crate::c_types::c_uint;
#[doc = "< Station smartconfig has finished to scan for APs"]
pub const smartconfig_event_t_SC_EVENT_SCAN_DONE: smartconfig_event_t = 0;
#[doc = "< Station smartconfig has found the channel of the target AP"]
pub const smartconfig_event_t_SC_EVENT_FOUND_CHANNEL: smartconfig_event_t = 1;
#[doc = "< Station smartconfig got the SSID and password"]
pub const smartconfig_event_t_SC_EVENT_GOT_SSID_PSWD: smartconfig_event_t = 2;
#[doc = "< Station smartconfig has sent ACK to cellphone"]
pub const smartconfig_event_t_SC_EVENT_SEND_ACK_DONE: smartconfig_event_t = 3;
#[doc = " Smartconfig event declarations"]
pub type smartconfig_event_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief smartconfig event base declaration"]
    pub static SC_EVENT: esp_event_base_t;
}
#[doc = " Argument structure for SC_EVENT_GOT_SSID_PSWD event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smartconfig_event_got_ssid_pswd_t {
    #[doc = "< SSID of the AP. Null terminated string."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of the AP. Null terminated string."]
    pub password: [u8; 64usize],
    #[doc = "< whether set MAC address of target AP or not."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP."]
    pub bssid: [u8; 6usize],
    #[doc = "< Type of smartconfig(ESPTouch or AirKiss)."]
    pub type_: smartconfig_type_t,
    #[doc = "< Token from cellphone which is used to send ACK to cellphone."]
    pub token: u8,
    #[doc = "< IP address of cellphone."]
    pub cellphone_ip: [u8; 4usize],
}
#[doc = " Configure structure for esp_smartconfig_start"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smartconfig_start_config_t {
    #[doc = "< Enable smartconfig logs."]
    pub enable_log: bool,
    #[doc = "< Enable ESPTouch v2 crypt."]
    pub esp_touch_v2_enable_crypt: bool,
    #[doc = "< ESPTouch v2 crypt key, len should be 16."]
    pub esp_touch_v2_key: *mut crate::c_types::c_char,
}
extern "C" {
    #[doc = " @brief  Get the version of SmartConfig.\n\n @return\n     - SmartConfig version const char."]
    pub fn esp_smartconfig_get_version() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP.\n            Device sniffer special packets from the air that containing SSID and password of target AP.\n\n @attention 1. This API can be called in station or softAP-station mode.\n @attention 2. Can not call esp_smartconfig_start twice before it finish, please call\n               esp_smartconfig_stop first.\n\n @param     config pointer to smartconfig start configure structure\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_start(config: *const smartconfig_start_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start.\n\n @attention Whether connect to AP succeed or not, this API should be called to free\n            memory taken by smartconfig_start.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set timeout of SmartConfig process.\n\n @attention Timing starts from SC_STATUS_FIND_CHANNEL status. SmartConfig will restart if timeout.\n\n @param     time_s  range 15s~255s, offset:45s.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_esptouch_set_timeout(time_s: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of SmartConfig.\n\n @attention If users need to set the SmartConfig type, please set it before calling\n            esp_smartconfig_start.\n\n @param     type  Choose from the smartconfig_type_t.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_set_type(type_: smartconfig_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mode of SmartConfig. default normal mode.\n\n @attention 1. Please call it before API esp_smartconfig_start.\n @attention 2. Fast mode have corresponding APP(phone).\n @attention 3. Two mode is compatible.\n\n @param     enable  false-disable(default); true-enable;\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_fast_mode(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get reserved data of ESPTouch v2.\n\n @param     rvd_data  reserved  data\n @param     len length  of  reserved data\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_get_rvd_data(rvd_data: *mut u8, len: u8) -> esp_err_t;
}
#[doc = "< Set the configuration of STA's HT2040 coexist management"]
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_SET_STA_HT2040_COEX: wifi_ioctl_cmd_t = 1;
#[doc = "< Get the configuration of STA's HT2040 coexist management"]
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_GET_STA_HT2040_COEX: wifi_ioctl_cmd_t = 2;
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_MAX: wifi_ioctl_cmd_t = 3;
#[doc = " @brief WiFi ioctl command type\n"]
pub type wifi_ioctl_cmd_t = crate::c_types::c_uint;
#[doc = " @brief Configuration for STA's HT2040 coexist management\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ht2040_coex_t {
    #[doc = "< Indicate whether STA's HT2040 coexist management is enabled or not"]
    pub enable: crate::c_types::c_int,
}
#[doc = " @brief Configuration for WiFi ioctl\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ioctl_config_t {
    #[doc = "< Configuration of ioctl command"]
    pub data: wifi_ioctl_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_ioctl_config_t__bindgen_ty_1 {
    #[doc = "< Configuration of STA's HT2040 coexist management"]
    pub ht2040_coex: wifi_ht2040_coex_t,
}
pub const wifi_beacon_drop_t_WIFI_BEACON_DROP_DISABLED: wifi_beacon_drop_t = 0;
pub const wifi_beacon_drop_t_WIFI_BEACON_DROP_AUTO: wifi_beacon_drop_t = 1;
pub const wifi_beacon_drop_t_WIFI_BEACON_DROP_FORCED: wifi_beacon_drop_t = 2;
#[doc = " @brief Mode for WiFi beacon drop\n"]
pub type wifi_beacon_drop_t = crate::c_types::c_uint;
#[doc = " @brief WiFi beacon monitor parameter configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_beacon_monitor_config_t {
    #[doc = "< Enable or disable beacon monitor"]
    pub enable: bool,
    #[doc = "< Beacon lost timeout"]
    pub loss_timeout: u8,
    #[doc = "< Maximum number of consecutive lost beacons allowed"]
    pub loss_threshold: u8,
    #[doc = "< Delta early time for RF PHY on"]
    pub delta_intr_early: u8,
    #[doc = "< Delta timeout time for RF PHY off"]
    pub delta_loss_timeout: u8,
    #[doc = "< Whether to drop the beacon if the beacon lost exceeds loss_threshold"]
    pub beacon_drop: wifi_beacon_drop_t,
}
#[doc = " @brief WiFi beacon sample parameter configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_beacon_offset_config_t {
    #[doc = "< Sample beacon period, unit: number of beacons"]
    pub sample_period: u16,
    #[doc = "< Resample period if beacon drop is active under the auto mode, unit: hours */\n/**< Standard triggers beacon drop when the expected rx beacon probability falls below this value under the auto mode, unit: percentage"]
    pub resample_period: u8,
    pub standard: u8,
    pub difference: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_static_queue_t {
    #[doc = "< FreeRTOS queue handler"]
    pub handle: QueueHandle_t,
    #[doc = "< storage for FreeRTOS queue"]
    pub storage: *mut crate::c_types::c_void,
}
pub const wifi_log_level_t_WIFI_LOG_NONE: wifi_log_level_t = 0;
pub const wifi_log_level_t_WIFI_LOG_ERROR: wifi_log_level_t = 1;
pub const wifi_log_level_t_WIFI_LOG_WARNING: wifi_log_level_t = 2;
pub const wifi_log_level_t_WIFI_LOG_INFO: wifi_log_level_t = 3;
pub const wifi_log_level_t_WIFI_LOG_DEBUG: wifi_log_level_t = 4;
pub const wifi_log_level_t_WIFI_LOG_VERBOSE: wifi_log_level_t = 5;
#[doc = " @brief WiFi log level\n"]
pub type wifi_log_level_t = crate::c_types::c_uint;
pub const wifi_log_module_t_WIFI_LOG_MODULE_ALL: wifi_log_module_t = 0;
pub const wifi_log_module_t_WIFI_LOG_MODULE_WIFI: wifi_log_module_t = 1;
pub const wifi_log_module_t_WIFI_LOG_MODULE_COEX: wifi_log_module_t = 2;
pub const wifi_log_module_t_WIFI_LOG_MODULE_MESH: wifi_log_module_t = 3;
#[doc = " @brief WiFi log module definition\n"]
pub type wifi_log_module_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief Initialize Wi-Fi Driver\n     Alloc resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n     WiFi NVS structure among others.\n\n For the most part, you need not call this function directly. It gets called\n from esp_wifi_init().\n\n This function may be called, if you only need to initialize the Wi-Fi driver\n without having to use the network stack on top.\n\n @param  config provide WiFi init configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_NO_MEM: out of memory\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init_internal(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize Wi-Fi Driver\n     Free resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n     WiFi NVS structure among others.\n\n For the most part, you need not call this function directly. It gets called\n from esp_wifi_deinit().\n\n This function may be called, if you call esp_wifi_init_internal to initialize\n WiFi driver.\n\n @return\n    - ESP_OK: succeed\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_deinit_internal() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  free the rx buffer which allocated by wifi driver\n\n @param  void* buffer: rx buffer pointer"]
    pub fn esp_wifi_internal_free_rx_buffer(buffer: *mut crate::c_types::c_void);
}
extern "C" {
    #[doc = " @brief  transmit the buffer via wifi driver\n\n This API makes a copy of the input buffer and then forwards the buffer\n copy to WiFi driver.\n\n @param  wifi_interface_t wifi_if : wifi interface id\n @param  void *buffer : the buffer to be transmit\n @param  uint16_t len : the length of buffer\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF : WiFi interface is invalid\n    - ESP_ERR_WIFI_CONN : WiFi interface is not created, e.g. send the data to STA while WiFi mode is AP mode\n    - ESP_ERR_WIFI_NOT_STARTED : WiFi is not started\n    - ESP_ERR_WIFI_STATE : WiFi internal state is not ready, e.g. WiFi is not started\n    - ESP_ERR_WIFI_NOT_ASSOC : WiFi is not associated\n    - ESP_ERR_WIFI_TX_DISALLOW : WiFi TX is disallowed, e.g. WiFi hasn't pass the authentication\n    - ESP_ERR_WIFI_POST : caller fails to post event to WiFi task"]
    pub fn esp_wifi_internal_tx(
        wifi_if: wifi_interface_t,
        buffer: *mut crate::c_types::c_void,
        len: u16,
    ) -> crate::c_types::c_int;
}
#[doc = " @brief     The net stack buffer reference counter callback function\n"]
pub type wifi_netstack_buf_ref_cb_t =
    ::core::option::Option<unsafe extern "C" fn(netstack_buf: *mut crate::c_types::c_void)>;
#[doc = " @brief     The net stack buffer free callback function\n"]
pub type wifi_netstack_buf_free_cb_t =
    ::core::option::Option<unsafe extern "C" fn(netstack_buf: *mut crate::c_types::c_void)>;
extern "C" {
    #[doc = " @brief  transmit the buffer by reference via wifi driver\n\n This API firstly increases the reference counter of the input buffer and\n then forwards the buffer to WiFi driver. The WiFi driver will free the buffer\n after processing it. Use esp_wifi_internal_tx() if the uplayer buffer doesn't\n supports reference counter.\n\n @param  wifi_if : wifi interface id\n @param  buffer : the buffer to be transmit\n @param  len : the length of buffer\n @param  netstack_buf : the netstack buffer related to buffer\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF : WiFi interface is invalid\n    - ESP_ERR_WIFI_CONN : WiFi interface is not created, e.g. send the data to STA while WiFi mode is AP mode\n    - ESP_ERR_WIFI_NOT_STARTED : WiFi is not started\n    - ESP_ERR_WIFI_STATE : WiFi internal state is not ready, e.g. WiFi is not started\n    - ESP_ERR_WIFI_NOT_ASSOC : WiFi is not associated\n    - ESP_ERR_WIFI_TX_DISALLOW : WiFi TX is disallowed, e.g. WiFi hasn't pass the authentication\n    - ESP_ERR_WIFI_POST : caller fails to post event to WiFi task"]
    pub fn esp_wifi_internal_tx_by_ref(
        ifx: wifi_interface_t,
        buffer: *mut crate::c_types::c_void,
        len: usize,
        netstack_buf: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Initialize WAPI function when wpa_supplicant initialize.\n\n This API is privately used, be careful not open to external applicantion.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WAPI_INTERNAL : Internal error"]
    pub fn esp_wifi_internal_wapi_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize WAPI function when wpa_supplicant de-initialize.\n\n This API is privately used, be careful not open to external applicantion.\n\n @return\n          - ESP_OK : succeed"]
    pub fn esp_wifi_internal_wapi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  register the net stack buffer reference increasing and free callback\n\n @param  ref : net stack buffer reference callback\n @param  free: net stack buffer free callback\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - others  : failed to register the callback"]
    pub fn esp_wifi_internal_reg_netstack_buf_cb(
        ref_: wifi_netstack_buf_ref_cb_t,
        free: wifi_netstack_buf_free_cb_t,
    ) -> esp_err_t;
}
#[doc = " @brief     The WiFi RX callback function\n\n            Each time the WiFi need to forward the packets to high layer, the callback function will be called"]
pub type wifi_rxcb_t = ::core::option::Option<
    unsafe extern "C" fn(
        buffer: *mut crate::c_types::c_void,
        len: u16,
        eb: *mut crate::c_types::c_void,
    ) -> esp_err_t,
>;
extern "C" {
    #[doc = " @brief     Set the WiFi RX callback\n\n @attention 1. Currently we support only one RX callback for each interface\n\n @param     wifi_interface_t ifx : interface\n @param     wifi_rxcb_t fn : WiFi RX callback\n\n @return\n     - ESP_OK : succeed\n     - others : fail"]
    pub fn esp_wifi_internal_reg_rxcb(ifx: wifi_interface_t, fn_: wifi_rxcb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Notify WIFI driver that the station got ip successfully\n\n @return\n     - ESP_OK : succeed\n     - others : fail"]
    pub fn esp_wifi_internal_set_sta_ip() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  enable or disable transmitting WiFi MAC frame with fixed rate\n\n @attention 1. If fixed rate is enabled, both management and data frame are transmitted with fixed rate\n @attention 2. Make sure that the receiver is able to receive the frame with the fixed rate if you want the frame to be received\n @attention 3. Not support to set fix rate for espnow and 80211_tx\n\n @param  ifx : wifi interface\n @param  en : false - disable, true - enable\n @param  rate : PHY rate\n\n @return\n    - ERR_OK  : succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_WIFI_IF : invalid WiFi interface\n    - ESP_ERR_INVALID_ARG : invalid rate\n    - ESP_ERR_NOT_SUPPORTED : do not support to set fixed rate if TX AMPDU is enabled"]
    pub fn esp_wifi_internal_set_fix_rate(
        ifx: wifi_interface_t,
        en: bool,
        rate: wifi_phy_rate_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP.\n            Device sniffer special packets from the air that containing SSID and password of target AP.\n\n @attention 1. This API can be called in station or softAP-station mode.\n @attention 2. Can not call esp_smartconfig_start twice before it finish, please call\n               esp_smartconfig_stop first.\n\n @param     config pointer to smartconfig start configure structure\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_internal_start(config: *const smartconfig_start_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start.\n\n @attention Whether connect to AP succeed or not, this API should be called to free\n            memory taken by smartconfig_start.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_internal_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the OS adapter header files in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_osi_funcs_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the crypto types header files in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_crypto_funcs_md5_check(
        md5: *const crate::c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_types.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_wifi_type_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_he_types.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_wifi_he_type_md5_check(
        md5: *const crate::c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_esp_wifi_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_he.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_esp_wifi_he_md5_check(md5: *const crate::c_types::c_char)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Allocate a chunk of memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_malloc(size: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief     Reallocate a chunk of memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     void * ptr  : Pointer to previously allocated memory, or NULL for a new allocation.\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_realloc(
        ptr: *mut crate::c_types::c_void,
        size: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief     Callocate memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     size_t n    : Number of continuing chunks of memory to allocate\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_calloc(n: usize, size: usize) -> *mut crate::c_types::c_void;
}
#[doc = " @brief     Update WiFi MAC time\n\n @param     uint32_t time_delta : time duration since the WiFi/BT common clock is disabled\n\n @return    Always returns ESP_OK"]
pub type wifi_mac_time_update_cb_t =
    ::core::option::Option<unsafe extern "C" fn(time_delta: u32) -> esp_err_t>;
extern "C" {
    #[doc = " @brief     Update WiFi MAC time\n\n @param     uint32_t time_delta : time duration since the WiFi/BT common clock is disabled\n\n @return    Always returns ESP_OK"]
    pub fn esp_wifi_internal_update_mac_time(time_delta: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi log level\n\n @param     level   Log level.\n\n @return\n    - ESP_OK: succeed\n    - ESP_FAIL: level is invalid"]
    pub fn esp_wifi_internal_set_log_level(level: wifi_log_level_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current log module and submodule\n\n @param     module      Log module\n @param     submodule   Log submodule\n @param     enable      enable or disable\n            If module == 0 && enable == 0, all log modules are disabled.\n            If module == 0 && enable == 1, all log modules are enabled.\n            If submodule == 0 && enable == 0, all log submodules are disabled.\n            If submodule == 0 && enable == 1, all log submodules are enabled.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_internal_set_log_mod(
        module: wifi_log_module_t,
        submodule: u32,
        enable: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi log info\n\n @param     log_level  the return log level.\n @param     log_mod    the return log module and submodule\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_log(
        log_level: *mut wifi_log_level_t,
        log_mod: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     A general API to set/get WiFi internal configuration, it's for debug only\n\n @param     cmd : ioctl command type\n @param     cfg : configuration for the command\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_internal_ioctl(
        cmd: crate::c_types::c_int,
        cfg: *mut wifi_ioctl_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the user-configured channel info\n\n @param     ifx : WiFi interface\n @param     primary : store the configured primary channel\n @param     second : store the configured second channel\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_config_channel(
        ifx: wifi_interface_t,
        primary: *mut u8,
        second: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated channel info after WiFi connection established\n\n @param     ifx : WiFi interface\n @param     aid : the connection number when a STA connects to the softAP\n @param     primary : store the negotiated primary channel\n @param     second : store the negotiated second channel\n @attention the aid param is only works when the device in softAP/softAP+STA mode\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_negotiated_channel(
        ifx: wifi_interface_t,
        aid: u8,
        primary: *mut u8,
        second: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated bandwidth info after WiFi connection established\n\n @param     ifx : WiFi interface\n @param     bw : store the negotiated bandwidth\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_negotiated_bandwidth(
        ifx: wifi_interface_t,
        aid: u8,
        bw: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wifi power domain power on"]
    pub fn esp_wifi_power_domain_on();
}
extern "C" {
    #[doc = " @brief Wifi power domain power off"]
    pub fn esp_wifi_power_domain_off();
}
#[doc = " @brief    TxDone callback function type. Should be registered using esp_wifi_set_tx_done_cb()\n\n @param    ifidx The interface id that the tx callback has been triggered from\n @param    data Pointer to the data transmitted\n @param    data_len Length of the data transmitted\n @param    txStatus True:if the data was transmitted successfully False: if data transmission failed"]
pub type wifi_tx_done_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ifidx: u8, data: *mut u8, data_len: *mut u16, txStatus: bool),
>;
extern "C" {
    #[doc = " @brief    Register the txDone callback function of type wifi_tx_done_cb_t\n\n @param    cb The callback function\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_set_tx_done_cb(cb: wifi_tx_done_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set device spp amsdu attributes\n\n @param     ifx: WiFi interface\n @param     spp_cap: spp amsdu capable\n @param     spp_req: spp amsdu require\n\n @return\n     - ESP_OK: succeed\n     - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n     - ESP_ERR_WIFI_IF : invalid WiFi interface"]
    pub fn esp_wifi_internal_set_spp_amsdu(
        ifidx: wifi_interface_t,
        spp_cap: bool,
        spp_req: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Update WIFI light sleep default parameters\n\n @param   min_freq_mhz: minimum frequency of DFS\n @param   max_freq_mhz: maximum frequency of DFS"]
    pub fn esp_wifi_internal_update_light_sleep_default_params(
        min_freq_mhz: crate::c_types::c_int,
        max_freq_mhz: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " @brief   Update WIFI modem sleep default parameters"]
    pub fn esp_wifi_internal_update_modem_sleep_default_params();
}
extern "C" {
    #[doc = " @brief   Set the min active time for wifi to enter the sleep state when light sleep\n\n @param   min_active_time: minimum timeout time  for waiting to receive\n                      data, when no data is received during the timeout period,\n                      the wifi enters the sleep process."]
    pub fn esp_wifi_set_sleep_min_active_time(min_active_time: u32);
}
extern "C" {
    #[doc = " @brief   Set wifi keep alive time\n\n @param   keep_alive_time: keep alive time"]
    pub fn esp_wifi_set_keep_alive_time(keep_alive_time: u32);
}
extern "C" {
    #[doc = " @brief      Set the min broadcast data wait time for wifi to enter the sleep state\n\n @attention  Default sleep wait broadcast data time is 15000, Uint µs.\n\n @param      time: When the station knows through the beacon that the AP\n                   will send broadcast packet, it will wait for a minimum of\n                   wait_broadcast_data_time before entering the sleep process."]
    pub fn esp_wifi_set_sleep_wait_broadcast_data_time(time: u32);
}
extern "C" {
    #[doc = " @brief   Configure wifi beacon montior default parameters\n\n @param   config: the configuration parameters for wifi beacon monitor"]
    pub fn esp_wifi_beacon_monitor_configure(config: *mut wifi_beacon_monitor_config_t);
}
extern "C" {
    #[doc = " @brief   Set modem state mode to require WiFi to enable or disable Advanced DTIM sleep function\n\n @param   require_modem_state: true for require WiFi to enable Advanced DTIM sleep function,\n                              false for require WiFi to disable Advanced DTIM sleep function.\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_modem_state_configure(require_modem_state: bool);
}
extern "C" {
    #[doc = " @brief   Set light sleep mode to require WiFi to enable or disable Advanced DTIM sleep function\n\n @param   light_sleep_enable: true for light sleep mode is enabled, false for light sleep mode is disabled.\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_light_sleep_configure(light_sleep_enable: bool);
}
extern "C" {
    #[doc = " @brief      Start Publishing a service in the NAN cluster\n\n @attention  This API should be called after esp_wifi_start() in NAN Mode.\n\n @param      publish_cfg  Configuration parameters for publishing a service.\n @param      id  Identifier for the Publish service.\n @param      cancel  Cancel the service identified by the id.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_publish_service(
        publish_cfg: *const wifi_nan_publish_cfg_t,
        id: *mut u8,
        cancel: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Subscribe for a service within the NAN cluster\n\n @attention  This API should be called after esp_wifi_start() in NAN Mode.\n\n @param      subscribe_cfg  Configuration parameters for subscribing for a service.\n @param      id  Identifier for the Subscribe service.\n @param      cancel  Cancel the service identified by the id.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_subscribe_service(
        subscribe_cfg: *const wifi_nan_subscribe_cfg_t,
        id: *mut u8,
        cancel: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Follow-up to the Publisher with matching service\n\n @attention  This API should be called after WIFI_EVENT_NAN_SVC_MATCH event is received.\n\n @param      fup_params  Configuration parameters for sending a Follow-up to the Peer.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_send_followup(
        fup_params: *const wifi_nan_followup_params_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Datapath Request to the Publisher with matching service\n\n @attention  This API should be called after WIFI_EVENT_NAN_SVC_MATCH event is received.\n\n @param      req  NAN Datapath Request parameters.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_datapath_req(
        req: *mut wifi_nan_datapath_req_t,
        ndp_id: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Datapath Response to accept or reject the received request\n\n @attention  This API should be called on the Publisher after receiving WIFI_EVENT_NDP_INDICATION event.\n\n @param      resp  NAN Datapath Response parameters.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_datapath_resp(resp: *mut wifi_nan_datapath_resp_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      End NAN Datapath that is active\n\n @attention  This API should be called after receiving WIFI_EVENT_NDP_CONFIRM event.\n\n @param      req  NAN Datapath end request parameters.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_datapath_end(req: *mut wifi_nan_datapath_end_req_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Connect WiFi station to the AP.\n\n @attention 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_MODE: WiFi mode error\n    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong\n    - ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid"]
    pub fn esp_wifi_connect_internal() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Disconnect WiFi station from the AP.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_FAIL: other WiFi internal errors\n"]
    pub fn esp_wifi_disconnect_internal() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the time information from the MAC clock. The time is precise only if modem sleep or light sleep is not enabled.\n\n @return 32-bit time value, unit: microsecond. This time is only 32 bits, which means it will overflow and reset to 0 after approximately 71 minutes.\n         Therefore, when using it, the time difference between two consecutive readings should not be too long."]
    pub fn esp_wifi_internal_get_mac_clock_time() -> u32;
}
extern "C" {
    #[doc = " @brief empty init pm_beacon_offset."]
    pub fn pm_beacon_offset_funcs_empty_init();
}
extern "C" {
    #[doc = " @brief This API is not context safe and enable easy fragment just for internal test only."]
    pub fn esp_wifi_enable_easy_fragment(enable: bool);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_osi_funcs_t {
    pub _version: i32,
    pub _env_is_chip: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _set_intr: ::core::option::Option<
        unsafe extern "C" fn(cpu_no: i32, intr_source: u32, intr_num: u32, intr_prio: i32),
    >,
    pub _clear_intr: ::core::option::Option<unsafe extern "C" fn(intr_source: u32, intr_num: u32)>,
    pub _set_isr: ::core::option::Option<
        unsafe extern "C" fn(
            n: i32,
            f: *mut crate::c_types::c_void,
            arg: *mut crate::c_types::c_void,
        ),
    >,
    pub _ints_on: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _ints_off: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _is_from_isr: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _spin_lock_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _spin_lock_delete:
        ::core::option::Option<unsafe extern "C" fn(lock: *mut crate::c_types::c_void)>,
    pub _wifi_int_disable: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut crate::c_types::c_void) -> u32,
    >,
    pub _wifi_int_restore: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut crate::c_types::c_void, tmp: u32),
    >,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create: ::core::option::Option<
        unsafe extern "C" fn(max: u32, init: u32) -> *mut crate::c_types::c_void,
    >,
    pub _semphr_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void)>,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut crate::c_types::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void) -> i32>,
    pub _wifi_thread_semphr_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _recursive_mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _mutex_delete:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void)>,
    pub _mutex_lock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void) -> i32>,
    pub _mutex_unlock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void) -> i32>,
    pub _queue_create: ::core::option::Option<
        unsafe extern "C" fn(queue_len: u32, item_size: u32) -> *mut crate::c_types::c_void,
    >,
    pub _queue_delete:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void)>,
    pub _queue_send: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            hptw: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _queue_send_to_back: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_to_front: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_recv: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_msg_waiting:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void) -> u32>,
    pub _event_group_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _event_group_delete:
        ::core::option::Option<unsafe extern "C" fn(event: *mut crate::c_types::c_void)>,
    pub _event_group_set_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut crate::c_types::c_void, bits: u32) -> u32,
    >,
    pub _event_group_clear_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut crate::c_types::c_void, bits: u32) -> u32,
    >,
    pub _event_group_wait_bits: ::core::option::Option<
        unsafe extern "C" fn(
            event: *mut crate::c_types::c_void,
            bits_to_wait_for: u32,
            clear_on_exit: crate::c_types::c_int,
            wait_for_all_bits: crate::c_types::c_int,
            block_time_tick: u32,
        ) -> u32,
    >,
    pub _task_create_pinned_to_core: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut crate::c_types::c_void,
            name: *const crate::c_types::c_char,
            stack_depth: u32,
            param: *mut crate::c_types::c_void,
            prio: u32,
            task_handle: *mut crate::c_types::c_void,
            core_id: u32,
        ) -> i32,
    >,
    pub _task_create: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut crate::c_types::c_void,
            name: *const crate::c_types::c_char,
            stack_depth: u32,
            param: *mut crate::c_types::c_void,
            prio: u32,
            task_handle: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _task_delete:
        ::core::option::Option<unsafe extern "C" fn(task_handle: *mut crate::c_types::c_void)>,
    pub _task_delay: ::core::option::Option<unsafe extern "C" fn(tick: u32)>,
    pub _task_ms_to_tick: ::core::option::Option<unsafe extern "C" fn(ms: u32) -> i32>,
    pub _task_get_current_task:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _task_get_max_priority: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    pub _malloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut crate::c_types::c_void)>,
    pub _event_post: ::core::option::Option<
        unsafe extern "C" fn(
            event_base: *const crate::c_types::c_char,
            event_id: i32,
            event_data: *mut crate::c_types::c_void,
            event_data_size: usize,
            ticks_to_wait: u32,
        ) -> i32,
    >,
    pub _get_free_heap_size: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _rand: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _dport_access_stall_other_cpu_start_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _dport_access_stall_other_cpu_end_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_apb80m_request: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_apb80m_release: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_update_country_info: ::core::option::Option<
        unsafe extern "C" fn(country: *const crate::c_types::c_char) -> crate::c_types::c_int,
    >,
    pub _read_mac: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut u8, type_: crate::c_types::c_uint) -> crate::c_types::c_int,
    >,
    pub _timer_arm: ::core::option::Option<
        unsafe extern "C" fn(timer: *mut crate::c_types::c_void, tmout: u32, repeat: bool),
    >,
    pub _timer_disarm:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut crate::c_types::c_void)>,
    pub _timer_done:
        ::core::option::Option<unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut crate::c_types::c_void,
            pfunction: *mut crate::c_types::c_void,
            parg: *mut crate::c_types::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void, us: u32, repeat: bool),
    >,
    pub _wifi_reset_mac: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_clock_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_clock_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_rtc_enable_iso: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_rtc_disable_iso: ::core::option::Option<unsafe extern "C" fn()>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _nvs_set_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: i8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut i8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_set_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: u8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut u8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_set_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: u16,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut u16,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_open: ::core::option::Option<
        unsafe extern "C" fn(
            name: *const crate::c_types::c_char,
            open_mode: crate::c_types::c_uint,
            out_handle: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_close: ::core::option::Option<unsafe extern "C" fn(handle: u32)>,
    pub _nvs_commit:
        ::core::option::Option<unsafe extern "C" fn(handle: u32) -> crate::c_types::c_int>,
    pub _nvs_set_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: *const crate::c_types::c_void,
            length: usize,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut crate::c_types::c_void,
            length: *mut usize,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_erase_key: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
        ) -> crate::c_types::c_int,
    >,
    pub _get_random: ::core::option::Option<
        unsafe extern "C" fn(buf: *mut u8, len: usize) -> crate::c_types::c_int,
    >,
    pub _get_time: ::core::option::Option<
        unsafe extern "C" fn(t: *mut crate::c_types::c_void) -> crate::c_types::c_int,
    >,
    pub _random: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_ulong>,
    pub _slowclk_cal_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _log_write: ::core::option::Option<
        unsafe extern "C" fn(
            level: crate::c_types::c_uint,
            tag: *const crate::c_types::c_char,
            format: *const crate::c_types::c_char,
            ...
        ),
    >,
    pub _log_writev: ::core::option::Option<
        unsafe extern "C" fn(
            level: crate::c_types::c_uint,
            tag: *const crate::c_types::c_char,
            format: *const crate::c_types::c_char,
            args: va_list,
        ),
    >,
    pub _log_timestamp: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _realloc_internal: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut crate::c_types::c_void,
            size: usize,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _calloc_internal: ::core::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut crate::c_types::c_void,
    >,
    pub _zalloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _wifi_malloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _wifi_realloc: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut crate::c_types::c_void,
            size: usize,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_calloc: ::core::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_zalloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _wifi_create_queue: ::core::option::Option<
        unsafe extern "C" fn(
            queue_len: crate::c_types::c_int,
            item_size: crate::c_types::c_int,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_delete_queue:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void)>,
    pub _coex_init: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_deinit: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_enable: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_status_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_condition_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, dissatisfy: bool)>,
    pub _coex_wifi_request: ::core::option::Option<
        unsafe extern "C" fn(event: u32, latency: u32, duration: u32) -> crate::c_types::c_int,
    >,
    pub _coex_wifi_release:
        ::core::option::Option<unsafe extern "C" fn(event: u32) -> crate::c_types::c_int>,
    pub _coex_wifi_channel_set: ::core::option::Option<
        unsafe extern "C" fn(primary: u8, secondary: u8) -> crate::c_types::c_int,
    >,
    pub _coex_event_duration_get: ::core::option::Option<
        unsafe extern "C" fn(event: u32, duration: *mut u32) -> crate::c_types::c_int,
    >,
    pub _coex_pti_get: ::core::option::Option<
        unsafe extern "C" fn(event: u32, pti: *mut u8) -> crate::c_types::c_int,
    >,
    pub _coex_schm_status_bit_clear:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, status: u32)>,
    pub _coex_schm_status_bit_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, status: u32)>,
    pub _coex_schm_interval_set:
        ::core::option::Option<unsafe extern "C" fn(interval: u32) -> crate::c_types::c_int>,
    pub _coex_schm_interval_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_schm_curr_period_get: ::core::option::Option<unsafe extern "C" fn() -> u8>,
    pub _coex_schm_curr_phase_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _coex_schm_process_restart:
        ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_schm_register_cb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: crate::c_types::c_int,
            cb: ::core::option::Option<
                unsafe extern "C" fn(arg1: crate::c_types::c_int) -> crate::c_types::c_int,
            >,
        ) -> crate::c_types::c_int,
    >,
    pub _coex_register_start_cb: ::core::option::Option<
        unsafe extern "C" fn(
            cb: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
        ) -> crate::c_types::c_int,
    >,
    pub _regdma_link_set_write_wait_content: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crate::c_types::c_void, arg2: u32, arg3: u32),
    >,
    pub _sleep_retention_find_link_by_id: ::core::option::Option<
        unsafe extern "C" fn(arg1: crate::c_types::c_int) -> *mut crate::c_types::c_void,
    >,
    pub _coex_schm_flexible_period_set:
        ::core::option::Option<unsafe extern "C" fn(arg1: u8) -> crate::c_types::c_int>,
    pub _coex_schm_flexible_period_get: ::core::option::Option<unsafe extern "C" fn() -> u8>,
    pub _coex_schm_get_phase_by_idx: ::core::option::Option<
        unsafe extern "C" fn(arg1: crate::c_types::c_int) -> *mut crate::c_types::c_void,
    >,
    pub _magic: i32,
}
extern "C" {
    pub static g_wifi_default_mesh_crypto_funcs: mesh_crypto_funcs_t;
}
extern "C" {
    #[doc = " @brief     Supplicant initialization\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_NO_MEM : out of memory"]
    pub fn esp_supplicant_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Supplicant deinitialization\n\n @return\n          - ESP_OK : succeed\n          - others: failed"]
    pub fn esp_supplicant_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable or enable the caching of Pairwise Master Keys (PMK) in the supplicant.\n\n This function allows disabling or enabling the caching of Pairwise Master Keys (PMK).\n PMK caching is used in Wi-Fi Protected Access (WPA/WPA2/WPA3) networks to speed up the reconnection process\n by storing the PMK generated during the initial connection. Disabling PMK caching may result in slightly\n longer reconnection times. PMK caching is enabled by default, this configuration has been provided\n in case the AP is known not to support PMK caching or has a buggy implementation for PMK caching.\n\n @param disable Boolean indicating whether to disable (true) or enable (false) PMK caching.\n @return\n     - ESP_OK: Success\n     - An error code if disabling or enabling PMK caching fails."]
    pub fn esp_supplicant_disable_pmk_caching(disable: bool) -> esp_err_t;
}
#[doc = " @brief Structure holding PHY init parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_init_data_t {
    #[doc = "< opaque PHY initialization parameters"]
    pub params: [u8; 128usize],
}
#[doc = "< PHY modem WIFI"]
pub const esp_phy_modem_t_PHY_MODEM_WIFI: esp_phy_modem_t = 1;
#[doc = "< PHY modem BT"]
pub const esp_phy_modem_t_PHY_MODEM_BT: esp_phy_modem_t = 2;
#[doc = "< PHY modem IEEE802154"]
pub const esp_phy_modem_t_PHY_MODEM_IEEE802154: esp_phy_modem_t = 4;
#[doc = "< Don't use it. Used by ESP_PHY_MODEM_COUNT_MAX"]
pub const esp_phy_modem_t_PHY_MODEM_MAX: esp_phy_modem_t = 5;
#[doc = " @brief PHY enable or disable modem"]
pub type esp_phy_modem_t = crate::c_types::c_uint;
#[doc = " @brief Opaque PHY calibration data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_calibration_data_t {
    #[doc = "< PHY version"]
    pub version: [u8; 4usize],
    #[doc = "< The MAC address of the station"]
    pub mac: [u8; 6usize],
    #[doc = "< calibration data"]
    pub opaque: [u8; 1894usize],
}
#[doc = "< Do part of RF calibration. This should be used after power-on reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_PARTIAL: esp_phy_calibration_mode_t = 0;
#[doc = "< Don't do any RF calibration. This mode is only suggested to be used after deep sleep reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_NONE: esp_phy_calibration_mode_t = 1;
#[doc = "< Do full RF calibration. Produces best results, but also consumes a lot of time and current. Suggested to be used once."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_FULL: esp_phy_calibration_mode_t = 2;
#[doc = " @brief PHY calibration mode\n"]
pub type esp_phy_calibration_mode_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief Get PHY init data\n\n If \"Use a partition to store PHY init data\" option is set in menuconfig,\n This function will load PHY init data from a partition. Otherwise,\n PHY init data will be compiled into the application itself, and this function\n will return a pointer to PHY init data located in read-only memory (DROM).\n\n If \"Use a partition to store PHY init data\" option is enabled, this function\n may return NULL if the data loaded from flash is not valid.\n\n @note Call esp_phy_release_init_data to release the pointer obtained using\n this function after the call to esp_wifi_init.\n\n @return pointer to PHY init data structure"]
    pub fn esp_phy_get_init_data() -> *const esp_phy_init_data_t;
}
extern "C" {
    #[doc = " @brief Release PHY init data\n @param data  pointer to PHY init data structure obtained from\n              esp_phy_get_init_data function"]
    pub fn esp_phy_release_init_data(data: *const esp_phy_init_data_t);
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_load_cal_and_init to load PHY calibration data\n\n This is a convenience function which can be used to load PHY calibration\n data from NVS. Data can be stored to NVS using esp_phy_store_cal_data_to_nvs\n function.\n\n If calibration data is not present in the NVS, or\n data is not valid (was obtained for a chip with a different MAC address,\n or obtained for a different version of software), this function will\n return an error.\n\n @param out_cal_data pointer to calibration data structure to be filled with\n                     loaded data.\n @return ESP_OK on success"]
    pub fn esp_phy_load_cal_data_from_nvs(
        out_cal_data: *mut esp_phy_calibration_data_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_load_cal_and_init to store PHY calibration data\n\n This is a convenience function which can be used to store PHY calibration\n data to the NVS. Calibration data is returned by esp_phy_load_cal_and_init function.\n Data saved using this function to the NVS can later be loaded using\n esp_phy_store_cal_data_to_nvs function.\n\n @param cal_data pointer to calibration data which has to be saved.\n @return ESP_OK on success"]
    pub fn esp_phy_store_cal_data_to_nvs(cal_data: *const esp_phy_calibration_data_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase PHY calibration data which is stored in the NVS\n\n This is a function which can be used to trigger full calibration as a last-resort remedy\n if partial calibration is used. It can be called in the application based on some conditions\n (e.g. an option provided in some diagnostic mode).\n\n @return ESP_OK on success\n @return others on fail. Please refer to NVS API return value error number."]
    pub fn esp_phy_erase_cal_data_in_nvs() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable PHY and RF module\n\n PHY and RF module should be enabled in order to use WiFi or BT.\n Now PHY and RF enabling job is done automatically when start WiFi or BT. Users should not\n call this API in their application.\n\n @param modem the modem to call the phy enable."]
    pub fn esp_phy_enable(modem: esp_phy_modem_t);
}
extern "C" {
    #[doc = " @brief Disable PHY and RF module\n\n PHY module should be disabled in order to shutdown WiFi or BT.\n Now PHY and RF disabling job is done automatically when stop WiFi or BT. Users should not\n call this API in their application.\n\n @param modem the modem to call the phy disable."]
    pub fn esp_phy_disable(modem: esp_phy_modem_t);
}
extern "C" {
    #[doc = " @brief Enable BTBB module\n\n BTBB module should be enabled in order to use IEEE802154 or BT.\n Now BTBB enabling job is done automatically when start IEEE802154 or BT. Users should not\n call this API in their application.\n"]
    pub fn esp_btbb_enable();
}
extern "C" {
    #[doc = " @brief Disable BTBB module\n\n Disable BTBB module, used by IEEE802154 or Bluetooth.\n Users should not call this API in their application.\n"]
    pub fn esp_btbb_disable();
}
extern "C" {
    #[doc = " @brief Load calibration data from NVS and initialize PHY and RF module"]
    pub fn esp_phy_load_cal_and_init();
}
extern "C" {
    #[doc = " @brief Initialize backup memory for Phy power up/down"]
    pub fn esp_phy_modem_init();
}
extern "C" {
    #[doc = " @brief Deinitialize backup memory for Phy power up/down\n Set phy_init_flag if all modems deinit on ESP32C3"]
    pub fn esp_phy_modem_deinit();
}
extern "C" {
    #[doc = " @brief Enable WiFi/BT common clock\n"]
    pub fn esp_phy_common_clock_enable();
}
extern "C" {
    #[doc = " @brief Disable WiFi/BT common clock\n"]
    pub fn esp_phy_common_clock_disable();
}
extern "C" {
    #[doc = " @brief            Get the time stamp when PHY/RF was switched on\n @return           return 0 if PHY/RF is never switched on. Otherwise return time in\n                   microsecond since boot when phy/rf was last switched on"]
    pub fn esp_phy_rf_get_on_ts() -> i64;
}
extern "C" {
    #[doc = " @brief Update the corresponding PHY init type according to the country code of Wi-Fi.\n\n @param country country code\n @return ESP_OK on success.\n @return esp_err_t code describing the error on fail"]
    pub fn esp_phy_update_country_info(country: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get PHY lib version\n @return PHY lib version."]
    pub fn get_phy_version_str() -> *mut crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief Set PHY init parameters\n @param param is 1 means combo module"]
    pub fn phy_init_param_set(param: u8);
}
extern "C" {
    #[doc = " @brief Wi-Fi RX enable\n @param enable True for enable wifi receiving mode as default, false for closing wifi receiving mode as default."]
    pub fn phy_wifi_enable_set(enable: u8);
}
extern "C" {
    #[doc = " @brief Power on Bluetooth Wi-Fi power domain"]
    pub fn esp_wifi_bt_power_domain_on();
}
extern "C" {
    #[doc = " @brief Power off Bluetooth Wi-Fi power domain"]
    pub fn esp_wifi_bt_power_domain_off();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_i2c_master_command_attribute_t {
    pub cmd_type: u8,
    pub config: phy_i2c_master_command_attribute_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_i2c_master_command_attribute_t__bindgen_ty_1 {
    pub start: u8,
    pub end: u8,
    pub host_id: u8,
}
extern "C" {
    #[doc = " @brief Return ROM function pointer table from PHY library."]
    pub fn phy_get_romfunc_addr();
}
extern "C" {
    #[doc = " @brief Initialize PHY module and do RF calibration\n @param[in] init_data Initialization parameters to be used by the PHY\n @param[inout] cal_data As input, calibration data previously obtained. As output, will contain new calibration data.\n @param[in] cal_mode  RF calibration mode\n @return ESP_CAL_DATA_CHECK_FAIL if the calibration data checksum fails or if the calibration data is outdated, other values are reserved for future use"]
    pub fn register_chipv7_phy(
        init_data: *const esp_phy_init_data_t,
        cal_data: *mut esp_phy_calibration_data_t,
        cal_mode: esp_phy_calibration_mode_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get the format version of calibration data used by PHY library.\n @return Format version number, OR'ed with BIT(16) if PHY is in WIFI only mode."]
    pub fn phy_get_rf_cal_version() -> u32;
}
extern "C" {
    #[doc = " @brief Set RF/BB for only WIFI mode or coexist(WIFI & BT) mode\n @param[in] true is for only WIFI mode, false is for coexist mode. default is 0.\n @return NULL"]
    pub fn phy_set_wifi_mode_only(wifi_only: bool);
}
extern "C" {
    #[doc = " @brief Set BT the highest priority in coexist mode.\n @return NULL"]
    pub fn coex_bt_high_prio();
}
extern "C" {
    #[doc = " @brief Open PHY and RF."]
    pub fn phy_wakeup_init();
}
extern "C" {
    #[doc = " @brief Shutdown PHY and RF."]
    pub fn phy_close_rf();
}
extern "C" {
    #[doc = " @brief Disable PHY temperature sensor."]
    pub fn phy_xpd_tsens();
}
extern "C" {
    #[doc = " @brief Get the configuration info of PHY i2c master command memory.\n\n @param[out] attr  the configuration info of PHY i2c master command memory\n @param[out] size  the count of PHY i2c master command memory configuration"]
    pub fn phy_i2c_master_command_mem_cfg(
        attr: *mut phy_i2c_master_command_attribute_t,
        size: *mut crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " @brief Store and load PHY digital registers.\n\n @param     backup_en  if backup_en is true, store PHY digital registers to memory. Otherwise load PHY digital registers from memory\n @param     mem_addr   Memory address to store and load PHY digital registers\n\n @return    memory size"]
    pub fn phy_dig_reg_backup(backup_en: bool, mem_addr: *mut u32) -> u8;
}
extern "C" {
    #[doc = " @brief Enable phy track pll\n"]
    pub fn phy_track_pll_init();
}
extern "C" {
    #[doc = " @brief Disable phy track pll\n"]
    pub fn phy_track_pll_deinit();
}
extern "C" {
    #[doc = " @brief Set the flag recorded which modem has already enabled phy\n"]
    pub fn phy_set_modem_flag(modem: esp_phy_modem_t);
}
extern "C" {
    #[doc = " @brief Clear the flag to record which modem calls phy disenable"]
    pub fn phy_clr_modem_flag(modem: esp_phy_modem_t);
}
extern "C" {
    #[doc = " @brief Get the flag recorded which modem has already enabled phy\n"]
    pub fn phy_get_modem_flag() -> esp_phy_modem_t;
}
extern "C" {
    #[doc = " @brief Get the PHY lock, only used in esp_phy, the user should not use this function.\n"]
    pub fn phy_get_lock() -> _lock_t;
}
extern "C" {
    #[doc = " @brief Call this funnction to track pll immediately.\n"]
    pub fn phy_track_pll();
}
extern "C" {
    #[doc = " @brief PHY antenna default configuration\n"]
    pub fn ant_dft_cfg(default_ant: bool);
}
extern "C" {
    #[doc = " @brief PHY tx antenna config\n"]
    pub fn ant_tx_cfg(ant0: u8);
}
extern "C" {
    #[doc = " @brief PHY rx antenna config\n"]
    pub fn ant_rx_cfg(auto_en: bool, ant0: u8, ant1: u8);
}
extern "C" {
    #[doc = " @brief PHY antenna need update\n"]
    pub fn phy_ant_need_update() -> bool;
}
extern "C" {
    #[doc = " @brief PHY antenna need update\n"]
    pub fn phy_ant_clr_update_flag();
}
extern "C" {
    #[doc = " @brief PHY antenna configuration update\n"]
    pub fn phy_ant_update();
}
extern "C" {
    #[doc = " @brief Get the REGDMA config value of the BBPLL in analog i2c master burst mode\n\n @return  the BBPLL REGDMA configure value of i2c master burst mode"]
    pub fn phy_ana_i2c_master_burst_bbpll_config() -> u32;
}
extern "C" {
    #[doc = " @brief Get the REGDMA config value of the RF PHY on or off in analog i2c master burst mode\n\n @param[in] on true for enable RF PHY, false for disable RF PHY.\n\n @return  the RF on or off configure value of i2c master burst mode"]
    pub fn phy_ana_i2c_master_burst_rf_onoff(on: bool) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_channel_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM channel handle"]
pub type esp_etm_channel_handle_t = *mut esp_etm_channel_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_event_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM event handle"]
pub type esp_etm_event_handle_t = *mut esp_etm_event_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_task_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM task handle"]
pub type esp_etm_task_handle_t = *mut esp_etm_task_t;
#[doc = " @brief ETM channel configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_channel_config_t {}
extern "C" {
    #[doc = " @brief Allocate an ETM channel\n\n @note The channel can later be freed by `esp_etm_del_channel`\n\n @param[in] config ETM channel configuration\n @param[out] ret_chan Returned ETM channel handle\n @return\n      - ESP_OK: Allocate ETM channel successfully\n      - ESP_ERR_INVALID_ARG: Allocate ETM channel failed because of invalid argument\n      - ESP_ERR_NO_MEM: Allocate ETM channel failed because of out of memory\n      - ESP_ERR_NOT_FOUND: Allocate ETM channel failed because all channels are used up and no more free one\n      - ESP_FAIL: Allocate ETM channel failed because of other reasons"]
    pub fn esp_etm_new_channel(
        config: *const esp_etm_channel_config_t,
        ret_chan: *mut esp_etm_channel_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an ETM channel\n\n @param[in] chan ETM channel handle that created by `esp_etm_new_channel`\n @return\n      - ESP_OK: Delete ETM channel successfully\n      - ESP_ERR_INVALID_ARG: Delete ETM channel failed because of invalid argument\n      - ESP_FAIL: Delete ETM channel failed because of other reasons"]
    pub fn esp_etm_del_channel(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable ETM channel\n\n @note This function will transit the channel state from init to enable.\n\n @param[in] chan ETM channel handle that created by `esp_etm_new_channel`\n @return\n      - ESP_OK: Enable ETM channel successfully\n      - ESP_ERR_INVALID_ARG: Enable ETM channel failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Enable ETM channel failed because the channel has been enabled already\n      - ESP_FAIL: Enable ETM channel failed because of other reasons"]
    pub fn esp_etm_channel_enable(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable ETM channel\n\n @note This function will transit the channel state from enable to init.\n\n @param[in] chan ETM channel handle that created by `esp_etm_new_channel`\n @return\n      - ESP_OK: Disable ETM channel successfully\n      - ESP_ERR_INVALID_ARG: Disable ETM channel failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Disable ETM channel failed because the channel is not enabled yet\n      - ESP_FAIL: Disable ETM channel failed because of other reasons"]
    pub fn esp_etm_channel_disable(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Connect an ETM event to an ETM task via a previously allocated ETM channel\n\n @note Setting the ETM event/task handle to NULL means to disconnect the channel from any event/task\n\n @param[in] chan ETM channel handle that created by `esp_etm_new_channel`\n @param[in] event ETM event handle obtained from a driver/peripheral, e.g. `xxx_new_etm_event`\n @param[in] task ETM task handle obtained from a driver/peripheral, e.g. `xxx_new_etm_task`\n @return\n      - ESP_OK: Connect ETM event and task to the channel successfully\n      - ESP_ERR_INVALID_ARG: Connect ETM event and task to the channel failed because of invalid argument\n      - ESP_FAIL: Connect ETM event and task to the channel failed because of other reasons"]
    pub fn esp_etm_channel_connect(
        chan: esp_etm_channel_handle_t,
        event: esp_etm_event_handle_t,
        task: esp_etm_task_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete ETM event\n\n @note Although the ETM event comes from various peripherals, we provide the same user API to delete the event handle seamlessly.\n\n @param[in] event ETM event handle obtained from a driver/peripheral, e.g. `xxx_new_etm_event`\n @return\n      - ESP_OK: Delete ETM event successfully\n      - ESP_ERR_INVALID_ARG: Delete ETM event failed because of invalid argument\n      - ESP_FAIL: Delete ETM event failed because of other reasons"]
    pub fn esp_etm_del_event(event: esp_etm_event_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete ETM task\n\n @note Although the ETM task comes from various peripherals, we provide the same user API to delete the task handle seamlessly.\n\n @param[in] task ETM task handle obtained from a driver/peripheral, e.g. `xxx_new_etm_task`\n @return\n      - ESP_OK: Delete ETM task successfully\n      - ESP_ERR_INVALID_ARG: Delete ETM task failed because of invalid argument\n      - ESP_FAIL: Delete ETM task failed because of other reasons"]
    pub fn esp_etm_del_task(task: esp_etm_task_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dump ETM channel usages to the given IO stream\n\n @param[in] out_stream IO stream (e.g. stdout)\n @return\n      - ESP_OK: Dump ETM channel usages successfully\n      - ESP_ERR_INVALID_ARG: Dump ETM channel usages failed because of invalid argument\n      - ESP_FAIL: Dump ETM channel usages failed because of other reasons"]
    pub fn esp_etm_dump(out_stream: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type representing a single timer handle"]
pub type esp_timer_handle_t = *mut esp_timer;
#[doc = " @brief Timer callback function type\n @param arg pointer to opaque user-specific data"]
pub type esp_timer_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut crate::c_types::c_void)>;
#[doc = "!< Callback is dispatched from esp_timer task"]
pub const esp_timer_dispatch_t_ESP_TIMER_TASK: esp_timer_dispatch_t = 0;
#[doc = "!< Sentinel value for the number of callback dispatch methods"]
pub const esp_timer_dispatch_t_ESP_TIMER_MAX: esp_timer_dispatch_t = 1;
#[doc = " @brief Method to dispatch timer callback"]
pub type esp_timer_dispatch_t = crate::c_types::c_uint;
#[doc = " @brief Timer configuration passed to esp_timer_create()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_timer_create_args_t {
    #[doc = "!< Callback function to execute when timer expires"]
    pub callback: esp_timer_cb_t,
    #[doc = "!< Argument to pass to callback"]
    pub arg: *mut crate::c_types::c_void,
    #[doc = "!< Dispatch callback from task or ISR; if not specified, esp_timer task"]
    pub dispatch_method: esp_timer_dispatch_t,
    #[doc = "!< Timer name, used in esp_timer_dump() function"]
    pub name: *const crate::c_types::c_char,
    #[doc = "!< Setting to skip unhandled events in light sleep for periodic timers"]
    pub skip_unhandled_events: bool,
}
extern "C" {
    #[doc = " @brief Minimal initialization of esp_timer\n\n @note This function is called from startup code. Applications do not need\n to call this function before using other esp_timer APIs.\n\n This function can be called very early in startup process, after this call\n only esp_timer_get_time() function can be used.\n\n @return\n      - ESP_OK on success"]
    pub fn esp_timer_early_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize esp_timer library\n\n @note This function is called from startup code. Applications do not need\n to call this function before using other esp_timer APIs.\n Before calling this function, esp_timer_early_init() must be called by the\n startup code.\n\n This function will be called from startup code on every core.\n If Kconfig option `CONFIG_ESP_TIMER_ISR_AFFINITY` is set to `NO_AFFINITY`,\n it allocates the timer ISR on MULTIPLE cores and\n creates the timer task which can be run on any core.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if allocation has failed\n      - ESP_ERR_INVALID_STATE if already initialized\n      - other errors from interrupt allocator"]
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize esp_timer library\n\n @note Normally this function should not be called from applications\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if not yet initialized"]
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create an esp_timer instance\n\n @note When timer no longer needed, delete it using esp_timer_delete().\n\n @param create_args   Pointer to a structure with timer creation arguments.\n                      Not saved by the library, can be allocated on the stack.\n @param[out] out_handle  Output, pointer to esp_timer_handle_t variable that\n                         holds the created timer handle.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if some of the create_args are not valid\n      - ESP_ERR_INVALID_STATE if esp_timer library is not initialized yet\n      - ESP_ERR_NO_MEM if memory allocation fails"]
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a one-shot timer\n\n Timer represented by `timer` should not be running when this function is called.\n\n @param timer timer handle created using esp_timer_create()\n @param timeout_us timer timeout, in microseconds relative to the current moment\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a periodic timer\n\n Timer represented by `timer` should not be running when this function is called.\n This function starts the timer which will trigger every `period` microseconds.\n\n @param timer timer handle created using esp_timer_create()\n @param period timer period, in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Restart a currently running timer\n\n Type of `timer` | Action\n --------------- | ------\n One-shot timer  | Restarted immediately and times out once in `timeout_us` microseconds\n Periodic timer  | Restarted immediately with a new period of `timeout_us` microseconds\n\n @param timer timer handle created using esp_timer_create()\n @param timeout_us Timeout in microseconds relative to the current time.\n                   In case of a periodic timer, also represents the new period.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_restart(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop a running timer\n\n This function stops the timer previously started using esp_timer_start_once()\n or esp_timer_start_periodic().\n\n @param timer timer handle created using esp_timer_create()\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an esp_timer instance\n\n The timer must be stopped before deleting. A one-shot timer which has expired\n does not need to be stopped.\n\n @param timer timer handle created using esp_timer_create()\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if the timer is running"]
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get time in microseconds since boot\n @return Number of microseconds since the initialization of ESP Timer"]
    pub fn esp_timer_get_time() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp of the next expected timeout\n @return Timestamp of the nearest timer event, in microseconds.\n         The timebase is the same as for the values returned by esp_timer_get_time()."]
    pub fn esp_timer_get_next_alarm() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp of the next expected timeout excluding those timers\n        that should not interrupt light sleep (such timers have\n        ::esp_timer_create_args_t::skip_unhandled_events enabled)\n @return Timestamp of the nearest timer event, in microseconds.\n         The timebase is the same as for the values returned by esp_timer_get_time()."]
    pub fn esp_timer_get_next_alarm_for_wake_up() -> i64;
}
extern "C" {
    #[doc = " @brief Get the period of a timer\n\n This function fetches the timeout period of a timer.\n For a one-shot timer, the timeout period will be 0.\n\n @param timer timer handle created using esp_timer_create()\n @param period memory to store the timer period value in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the arguments are invalid"]
    pub fn esp_timer_get_period(timer: esp_timer_handle_t, period: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the expiry time of a one-shot timer\n\n This function fetches the expiry time of a one-shot timer.\n\n @note Passing the timer handle of a periodic timer will result in an error.\n\n @param timer timer handle created using esp_timer_create()\n @param expiry memory to store the timeout value in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the arguments are invalid\n      - ESP_ERR_NOT_SUPPORTED if the timer type is periodic"]
    pub fn esp_timer_get_expiry_time(timer: esp_timer_handle_t, expiry: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dump the list of timers to a stream\n\n By default, this function prints the list of active (running) timers. The output format is:\n\n | Name | Period | Alarm |\n\n - Name — timer pointer\n - Period — period of timer in microseconds, or 0 for one-shot timer\n - Alarm - time of the next alarm in microseconds since boot, or 0 if the timer is not started\n\n To print the list of all created timers, enable Kconfig option `CONFIG_ESP_TIMER_PROFILING`.\n In this case, the output format is:\n\n | Name | Period | Alarm | Times_armed | Times_trigg | Times_skip | Cb_exec_time |\n\n - Name — timer name\n - Period — same as above\n - Alarm — same as above\n - Times_armed — number of times the timer was armed via esp_timer_start_X\n - Times_triggered - number of times the callback was triggered\n - Times_skipped - number of times the callback was skipped\n - Callback_exec_time - total time taken by callback to execute, across all calls\n\n @param stream stream (such as stdout) to which to dump the information\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if can not allocate temporary buffer for the output"]
    pub fn esp_timer_dump(stream: *mut FILE) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns status of a timer, active or not\n\n This function is used to identify if the timer is still active (running) or not.\n\n @param timer timer handle created using esp_timer_create()\n @return\n      - 1 if timer is still active (running)\n      - 0 if timer is not active"]
    pub fn esp_timer_is_active(timer: esp_timer_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief Get the ETM event handle of esp_timer underlying alarm event\n\n @note The created ETM event object can be deleted later using esp_etm_del_event()\n\n @note The ETM event is generated by the underlying hardware - systimer;\n       therefore, if the esp_timer is not clocked by systimer, then no ETM event will be generated.\n\n @param[out] out_event Returned ETM event handle\n @return\n      - ESP_OK Success\n      - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn esp_timer_new_etm_alarm_event(out_event: *mut esp_etm_event_handle_t) -> esp_err_t;
}
#[doc = "< EAP (Extensible Authentication Protocol)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_EAP: esp_eap_ttls_phase2_types = 0;
#[doc = "< MS-CHAPv2 (Microsoft Challenge Handshake Authentication Protocol - Version 2)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_MSCHAPV2: esp_eap_ttls_phase2_types = 1;
#[doc = "< MS-CHAP (Microsoft Challenge Handshake Authentication Protocol)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_MSCHAP: esp_eap_ttls_phase2_types = 2;
#[doc = "< PAP (Password Authentication Protocol)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_PAP: esp_eap_ttls_phase2_types = 3;
#[doc = "< CHAP (Challenge Handshake Authentication Protocol)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_CHAP: esp_eap_ttls_phase2_types = 4;
#[doc = " @brief Enumeration of phase 2 authentication types for EAP-TTLS.\n\n This enumeration defines the supported phase 2 authentication methods\n that can be used in the EAP-TTLS (Extensible Authentication Protocol -\n Tunneled Transport Layer Security) protocol for the second authentication\n phase."]
pub type esp_eap_ttls_phase2_types = crate::c_types::c_uint;
#[doc = "< No EAP method defined"]
pub const esp_eap_method_t_ESP_EAP_TYPE_NONE: esp_eap_method_t = 0;
#[doc = "< EAP-TLS method"]
pub const esp_eap_method_t_ESP_EAP_TYPE_TLS: esp_eap_method_t = 1;
#[doc = "< EAP-TTLS method"]
pub const esp_eap_method_t_ESP_EAP_TYPE_TTLS: esp_eap_method_t = 2;
#[doc = "< EAP-PEAP method"]
pub const esp_eap_method_t_ESP_EAP_TYPE_PEAP: esp_eap_method_t = 4;
#[doc = "< EAP-FAST method"]
pub const esp_eap_method_t_ESP_EAP_TYPE_FAST: esp_eap_method_t = 8;
#[doc = "< All supported EAP methods"]
pub const esp_eap_method_t_ESP_EAP_TYPE_ALL: esp_eap_method_t = 15;
#[doc = " @brief Bitmask of supported EAP authentication methods."]
pub type esp_eap_method_t = crate::c_types::c_uint;
#[doc = " @brief Configuration settings for EAP-FAST\n        (Extensible Authentication Protocol - Flexible Authentication via Secure Tunneling).\n\n This structure defines the configuration options that can be used to customize the behavior of the\n EAP-FAST authentication protocol, specifically for Fast Provisioning and PAC (Protected Access Credential) handling."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_eap_fast_config {
    #[doc = "< Enable or disable Fast Provisioning in EAP-FAST (0 = disabled, 1 = enabled)"]
    pub fast_provisioning: crate::c_types::c_int,
    #[doc = "< Maximum length of the PAC (Protected Access Credential) list"]
    pub fast_max_pac_list_len: crate::c_types::c_int,
    #[doc = "< Set to true for binary format PAC, false for ASCII format PAC"]
    pub fast_pac_format_binary: bool,
}
extern "C" {
    #[doc = " @brief Enable EAP authentication(WiFi Enterprise) for the station mode.\n\n This function enables Extensible Authentication Protocol (EAP) authentication\n for the Wi-Fi station mode. When EAP authentication is enabled, the ESP device\n will attempt to authenticate with the configured EAP credentials when connecting\n to a secure Wi-Fi network.\n\n @note Before calling this function, ensure that the Wi-Fi configuration and EAP\n credentials (such as username and password) have been properly set using the\n appropriate configuration APIs.\n\n @return\n    - ESP_OK: EAP authentication enabled successfully.\n    - ESP_ERR_NO_MEM: Failed to enable EAP authentication due to memory allocation failure."]
    pub fn esp_wifi_sta_enterprise_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable EAP authentication(WiFi Enterprise) for the station mode.\n\n This function disables Extensible Authentication Protocol (EAP) authentication\n for the Wi-Fi station mode. When EAP authentication is disabled, the ESP device\n will not attempt to authenticate using EAP credentials when connecting to a\n secure Wi-Fi network.\n\n @note Disabling EAP authentication may cause the device to connect to the Wi-Fi\n network using other available authentication methods, if configured using esp_wifi_set_config().\n @note Calling this will reset all eap configuration set using esp_eap_client_xxx APIs.\n Please call esp_eap_client_XXX APIs again to set new config after calling this function.\n\n @return\n    - ESP_OK: EAP authentication disabled successfully.\n    - ESP_ERR_INVALID_STATE: EAP client is in an invalid state for disabling."]
    pub fn esp_wifi_sta_enterprise_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set identity for PEAP/TTLS authentication method.\n\n This function sets the identity to be used during PEAP/TTLS authentication.\n\n @param[in] identity Pointer to the identity data.\n @param[in] len      Length of the identity data (limited to 1~127 bytes).\n\n @return\n    - ESP_OK: The identity was set successfully.\n    - ESP_ERR_INVALID_ARG: Invalid argument (len <= 0 or len >= 128).\n    - ESP_ERR_NO_MEM: Memory allocation failure."]
    pub fn esp_eap_client_set_identity(
        identity: *const crate::c_types::c_uchar,
        len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear the previously set identity for PEAP/TTLS authentication.\n\n This function clears the identity that was previously set for the EAP client.\n After calling this function, the EAP client will no longer use the previously\n configured identity during the authentication process."]
    pub fn esp_eap_client_clear_identity();
}
extern "C" {
    #[doc = " @brief Set username for PEAP/TTLS authentication method.\n\n This function sets the username to be used during PEAP/TTLS authentication.\n\n @param[in] username Pointer to the username data.\n @param[in] len      Length of the username data (limited to 1~127 bytes).\n\n @return\n    - ESP_OK: The username was set successfully.\n    - ESP_ERR_INVALID_ARG: Failed due to an invalid argument (len <= 0 or len >= 128).\n    - ESP_ERR_NO_MEM: Failed due to memory allocation failure."]
    pub fn esp_eap_client_set_username(
        username: *const crate::c_types::c_uchar,
        len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear username for PEAP/TTLS method.\n\n This function clears the previously set username for the EAP client."]
    pub fn esp_eap_client_clear_username();
}
extern "C" {
    #[doc = " @brief Set password for PEAP/TTLS authentication method.\n\n This function sets the password to be used during PEAP/TTLS authentication.\n\n @param[in] password Pointer to the password data.\n @param[in] len      Length of the password data (len > 0).\n\n @return\n    - ESP_OK: The password was set successfully.\n    - ESP_ERR_INVALID_ARG: Failed due to an invalid argument (len <= 0).\n    - ESP_ERR_NO_MEM: Failed due to memory allocation failure."]
    pub fn esp_eap_client_set_password(
        password: *const crate::c_types::c_uchar,
        len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear password for PEAP/TTLS method.\n\n This function clears the previously set password for the EAP client."]
    pub fn esp_eap_client_clear_password();
}
extern "C" {
    #[doc = " @brief Set a new password for MSCHAPv2 authentication method.\n\n This function sets the new password to be used during MSCHAPv2 authentication.\n The new password is used to substitute the old password when an eap-mschapv2 failure request\n message with error code ERROR_PASSWD_EXPIRED is received.\n\n @param[in] new_password Pointer to the new password data.\n @param[in] len          Length of the new password data.\n\n @return\n    - ESP_OK: The new password was set successfully.\n    - ESP_ERR_INVALID_ARG: Failed due to an invalid argument (len <= 0).\n    - ESP_ERR_NO_MEM: Failed due to memory allocation failure."]
    pub fn esp_eap_client_set_new_password(
        new_password: *const crate::c_types::c_uchar,
        len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear new password for MSCHAPv2 method.\n\n This function clears the previously set new password for the EAP client."]
    pub fn esp_eap_client_clear_new_password();
}
extern "C" {
    #[doc = " @brief Set CA certificate for EAP authentication.\n\n This function sets the Certificate Authority (CA) certificate to be used during EAP authentication.\n The CA certificate is passed to the EAP client module through a global pointer.\n\n @param[in] ca_cert     Pointer to the CA certificate data.\n @param[in] ca_cert_len Length of the CA certificate data.\n\n @return\n    - ESP_OK: The CA certificate was set successfully."]
    pub fn esp_eap_client_set_ca_cert(
        ca_cert: *const crate::c_types::c_uchar,
        ca_cert_len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear the previously set Certificate Authority (CA) certificate for EAP authentication.\n\n This function clears the CA certificate that was previously set for the EAP client.\n After calling this function, the EAP client will no longer use the previously\n configured CA certificate during the authentication process."]
    pub fn esp_eap_client_clear_ca_cert();
}
extern "C" {
    #[doc = " @brief Set client certificate and private key for EAP authentication.\n\n This function sets the client certificate and private key to be used during authentication.\n Optionally, a private key password can be provided for encrypted private keys.\n\n @attention 1. The client certificate, private key, and private key password are provided as pointers\n              to the respective data arrays.\n @attention 2. The client_cert, private_key, and private_key_password should be zero-terminated.\n\n @param[in] client_cert           Pointer to the client certificate data.\n @param[in] client_cert_len       Length of the client certificate data.\n @param[in] private_key           Pointer to the private key data.\n @param[in] private_key_len       Length of the private key data (limited to 1~4096 bytes).\n @param[in] private_key_password  Pointer to the private key password data (optional).\n @param[in] private_key_passwd_len Length of the private key password data (can be 0 for no password).\n\n @return\n    - ESP_OK: The certificate, private key, and password (if provided) were set successfully."]
    pub fn esp_eap_client_set_certificate_and_key(
        client_cert: *const crate::c_types::c_uchar,
        client_cert_len: crate::c_types::c_int,
        private_key: *const crate::c_types::c_uchar,
        private_key_len: crate::c_types::c_int,
        private_key_password: *const crate::c_types::c_uchar,
        private_key_passwd_len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear the previously set client certificate and private key for EAP authentication.\n\n This function clears the client certificate and private key that were previously set\n for the EAP client. After calling this function, the EAP client will no longer use the\n previously configured certificate and private key during the authentication process."]
    pub fn esp_eap_client_clear_certificate_and_key();
}
extern "C" {
    #[doc = " @brief Set EAP client certificates time check (disable or not).\n\n This function enables or disables the time check for EAP client certificates.\n When disabled, the certificates' expiration time will not be checked during the authentication process.\n\n @param[in] disable True to disable EAP client certificates time check, false to enable it.\n\n @return\n    - ESP_OK: The EAP client certificates time check setting was updated successfully."]
    pub fn esp_eap_client_set_disable_time_check(disable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get EAP client certificates time check status.\n\n This function retrieves the current status of the EAP client certificates time check.\n\n @param[out] disable Pointer to a boolean variable to store the disable status.\n\n @return\n    - ESP_OK: The status of EAP client certificates time check was retrieved successfully."]
    pub fn esp_eap_client_get_disable_time_check(disable: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set EAP-TTLS phase 2 method.\n\n This function sets the phase 2 method to be used during EAP-TTLS authentication.\n\n @param[in] type The type of phase 2 method to be used (e.g., EAP, MSCHAPv2, MSCHAP, PAP, CHAP).\n\n @return\n    - ESP_OK: The EAP-TTLS phase 2 method was set successfully."]
    pub fn esp_eap_client_set_ttls_phase2_method(type_: esp_eap_ttls_phase2_types) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable Suite-B 192-bit certification checks.\n\n This function enables or disables the 192-bit Suite-B certification checks during EAP-TLS authentication.\n Suite-B is a set of cryptographic algorithms which generally are considered more secure.\n\n @param[in] enable True to enable 192-bit Suite-B certification checks, false to disable it.\n\n @return\n    - ESP_OK: The 192-bit Suite-B certification checks were set successfully."]
    pub fn esp_eap_client_set_suiteb_192bit_certification(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the PAC (Protected Access Credential) file for EAP-FAST authentication.\n\n EAP-FAST requires a PAC file that contains the client's credentials.\n\n @attention  1. For files read from the file system, length has to be decremented by 1 byte.\n @attention  2. Disabling the ESP_WIFI_MBEDTLS_TLS_CLIENT config is required to use EAP-FAST.\n\n @param[in] pac_file     Pointer to the PAC file buffer.\n @param[in] pac_file_len Length of the PAC file buffer.\n\n @return\n    - ESP_OK: The PAC file for EAP-FAST authentication was set successfully."]
    pub fn esp_eap_client_set_pac_file(
        pac_file: *const crate::c_types::c_uchar,
        pac_file_len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the parameters for EAP-FAST Phase 1 authentication.\n\n EAP-FAST supports Fast Provisioning, where clients can be authenticated faster using precomputed keys (PAC).\n This function allows configuring parameters for Fast Provisioning.\n\n @attention  1. Disabling the ESP_WIFI_MBEDTLS_TLS_CLIENT config is required to use EAP-FAST.\n\n @param[in] config Configuration structure with Fast Provisioning parameters.\n\n @return\n    - ESP_OK: The parameters for EAP-FAST Phase 1 authentication were set successfully."]
    pub fn esp_eap_client_set_fast_params(config: esp_eap_fast_config) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Use the default certificate bundle for EAP authentication.\n\n By default, the EAP client uses a built-in certificate bundle for server verification.\n Enabling this option allows the use of the default certificate bundle.\n\n @param[in] use_default_bundle True to use the default certificate bundle, false to use a custom bundle.\n\n @return\n    - ESP_OK: The option to use the default certificate bundle was set successfully."]
    pub fn esp_eap_client_use_default_cert_bundle(use_default_bundle: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set Opportunistic key caching support for station.\n\n @param enable Boolean indicating whether to enable (true) or disable (false) OKC support."]
    pub fn esp_wifi_set_okc_support(enable: bool);
}
extern "C" {
    #[doc = " @brief Set the domain name for certificate validation\n\n This function sets the expected domain name for validating the certificate's subject name.\n If the provided domain name does not match the certificate's subject name, validation will fail.\n\n @attention  1. The `domain_name` should be a NULL-terminated string.\n\n @param[in] domain_name The expected domain name. Pass `NULL` to clear the domain matching.\n\n @return\n    - ESP_OK: The domain match was set successfully.\n    - ESP_ERR_INVALID_ARG: Invalid argument (length > 255).\n    - ESP_ERR_NO_MEM: Memory allocation failure.\n    - ESP_ERR_NOT_SUPPORTED: Feature not supported."]
    pub fn esp_eap_client_set_domain_name(domain_name: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set one or more EAP (Extensible Authentication Protocol) methods to be used by the EAP client.\n\n This API sets the allowed EAP authentication methods using a bitmask.\n Multiple methods can be specified by OR-ing together values from `esp_eap_method_t`.\n\n @param[in] methods Bitmask of EAP methods to enable.\n\n @return\n     - ESP_OK on success\n     - ESP_ERR_INVALID_ARG if none of the methods are valid\n\n @note\n If this API is not called, all supported EAP methods will be considered.\n If one or more methods are set using this API, only the specified methods will be considered."]
    pub fn esp_eap_client_set_eap_methods(methods: esp_eap_method_t) -> esp_err_t;
}
pub type ble_npl_event_fn = ::core::option::Option<unsafe extern "C" fn(ev: *mut ble_npl_event)>;
pub const ble_npl_error_BLE_NPL_OK: ble_npl_error = 0;
pub const ble_npl_error_BLE_NPL_ENOMEM: ble_npl_error = 1;
pub const ble_npl_error_BLE_NPL_EINVAL: ble_npl_error = 2;
pub const ble_npl_error_BLE_NPL_INVALID_PARAM: ble_npl_error = 3;
pub const ble_npl_error_BLE_NPL_MEM_NOT_ALIGNED: ble_npl_error = 4;
pub const ble_npl_error_BLE_NPL_BAD_MUTEX: ble_npl_error = 5;
pub const ble_npl_error_BLE_NPL_TIMEOUT: ble_npl_error = 6;
pub const ble_npl_error_BLE_NPL_ERR_IN_ISR: ble_npl_error = 7;
pub const ble_npl_error_BLE_NPL_ERR_PRIV: ble_npl_error = 8;
pub const ble_npl_error_BLE_NPL_OS_NOT_STARTED: ble_npl_error = 9;
pub const ble_npl_error_BLE_NPL_ENOENT: ble_npl_error = 10;
pub const ble_npl_error_BLE_NPL_EBUSY: ble_npl_error = 11;
pub const ble_npl_error_BLE_NPL_ERROR: ble_npl_error = 12;
pub type ble_npl_error = crate::c_types::c_uint;
pub use self::ble_npl_error as ble_npl_error_t;
pub type ble_npl_time_t = u32;
pub type ble_npl_stime_t = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_npl_event {
    pub dummy: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_npl_eventq {
    pub dummy: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_npl_callout {
    pub dummy: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_npl_mutex {
    pub dummy: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_npl_sem {
    pub dummy: crate::c_types::c_int,
}
extern "C" {
    pub fn ble_npl_os_started() -> bool;
}
extern "C" {
    pub fn ble_npl_get_current_task_id() -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn ble_npl_eventq_init(evq: *mut ble_npl_eventq);
}
extern "C" {
    pub fn ble_npl_eventq_deinit(evq: *mut ble_npl_eventq);
}
extern "C" {
    pub fn ble_npl_eventq_get(evq: *mut ble_npl_eventq, tmo: ble_npl_time_t) -> *mut ble_npl_event;
}
extern "C" {
    pub fn ble_npl_eventq_put(evq: *mut ble_npl_eventq, ev: *mut ble_npl_event);
}
extern "C" {
    pub fn ble_npl_eventq_remove(evq: *mut ble_npl_eventq, ev: *mut ble_npl_event);
}
extern "C" {
    pub fn ble_npl_event_init(
        ev: *mut ble_npl_event,
        fn_: ble_npl_event_fn,
        arg: *mut crate::c_types::c_void,
    );
}
extern "C" {
    pub fn ble_npl_event_is_queued(ev: *mut ble_npl_event) -> bool;
}
extern "C" {
    pub fn ble_npl_event_get_arg(ev: *mut ble_npl_event) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn ble_npl_event_set_arg(ev: *mut ble_npl_event, arg: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn ble_npl_eventq_is_empty(evq: *mut ble_npl_eventq) -> bool;
}
extern "C" {
    pub fn ble_npl_event_run(ev: *mut ble_npl_event);
}
extern "C" {
    pub fn ble_npl_mutex_init(mu: *mut ble_npl_mutex) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_mutex_pend(mu: *mut ble_npl_mutex, timeout: ble_npl_time_t) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_mutex_release(mu: *mut ble_npl_mutex) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_mutex_deinit(mu: *mut ble_npl_mutex) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_sem_init(sem: *mut ble_npl_sem, tokens: u16) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_sem_pend(sem: *mut ble_npl_sem, timeout: ble_npl_time_t) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_sem_release(sem: *mut ble_npl_sem) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_sem_deinit(sem: *mut ble_npl_sem) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_sem_get_count(sem: *mut ble_npl_sem) -> u16;
}
extern "C" {
    pub fn ble_npl_callout_init(
        co: *mut ble_npl_callout,
        evq: *mut ble_npl_eventq,
        ev_cb: ble_npl_event_fn,
        ev_arg: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ble_npl_callout_reset(
        co: *mut ble_npl_callout,
        ticks: ble_npl_time_t,
    ) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_callout_stop(co: *mut ble_npl_callout);
}
extern "C" {
    pub fn ble_npl_callout_is_active(co: *mut ble_npl_callout) -> bool;
}
extern "C" {
    pub fn ble_npl_callout_get_ticks(co: *mut ble_npl_callout) -> ble_npl_time_t;
}
extern "C" {
    pub fn ble_npl_callout_remaining_ticks(
        co: *mut ble_npl_callout,
        time: ble_npl_time_t,
    ) -> ble_npl_time_t;
}
extern "C" {
    pub fn ble_npl_callout_set_arg(co: *mut ble_npl_callout, arg: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn ble_npl_time_get() -> ble_npl_time_t;
}
extern "C" {
    pub fn ble_npl_time_ms_to_ticks(ms: u32, out_ticks: *mut ble_npl_time_t) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_time_ticks_to_ms(ticks: ble_npl_time_t, out_ms: *mut u32) -> ble_npl_error_t;
}
extern "C" {
    pub fn ble_npl_time_ms_to_ticks32(ms: u32) -> ble_npl_time_t;
}
extern "C" {
    pub fn ble_npl_time_ticks_to_ms32(ticks: ble_npl_time_t) -> u32;
}
extern "C" {
    pub fn ble_npl_time_delay(ticks: ble_npl_time_t);
}
extern "C" {
    pub fn ble_npl_hw_enter_critical() -> u32;
}
extern "C" {
    pub fn ble_npl_hw_exit_critical(ctx: u32);
}
extern "C" {
    pub fn ble_npl_hw_is_in_critical() -> bool;
}
#[doc = "< interrupt of WiFi MAC, level"]
pub const periph_interrupt_t_ETS_WIFI_MAC_INTR_SOURCE: periph_interrupt_t = 0;
#[doc = "< interrupt of WiFi MAC, NMI, use if MAC have bug to fix in NMI"]
pub const periph_interrupt_t_ETS_WIFI_MAC_NMI_SOURCE: periph_interrupt_t = 1;
#[doc = "<"]
pub const periph_interrupt_t_ETS_WIFI_PWR_INTR_SOURCE: periph_interrupt_t = 2;
#[doc = "< interrupt of WiFi BB, level, we can do some calibartion"]
pub const periph_interrupt_t_ETS_WIFI_BB_INTR_SOURCE: periph_interrupt_t = 3;
#[doc = "< will be cancelled"]
pub const periph_interrupt_t_ETS_BT_MAC_INTR_SOURCE: periph_interrupt_t = 4;
#[doc = "< interrupt of BT BB, level"]
pub const periph_interrupt_t_ETS_BT_BB_INTR_SOURCE: periph_interrupt_t = 5;
#[doc = "< interrupt of BT BB, NMI, use if BB have bug to fix in NMI"]
pub const periph_interrupt_t_ETS_BT_BB_NMI_SOURCE: periph_interrupt_t = 6;
pub const periph_interrupt_t_ETS_LP_TIMER_INTR_SOURCE: periph_interrupt_t = 7;
pub const periph_interrupt_t_ETS_COEX_INTR_SOURCE: periph_interrupt_t = 8;
pub const periph_interrupt_t_ETS_BLE_TIMER_INTR_SOURCE: periph_interrupt_t = 9;
pub const periph_interrupt_t_ETS_BLE_SEC_INTR_SOURCE: periph_interrupt_t = 10;
#[doc = "< interrupt of I2C Master, level"]
pub const periph_interrupt_t_ETS_I2C_MASTER_SOURCE: periph_interrupt_t = 11;
pub const periph_interrupt_t_ETS_ZB_MAC_SOURCE: periph_interrupt_t = 12;
pub const periph_interrupt_t_ETS_PMU_INTR_SOURCE: periph_interrupt_t = 13;
#[doc = "< interrupt of efuse, level, not likely to use"]
pub const periph_interrupt_t_ETS_EFUSE_INTR_SOURCE: periph_interrupt_t = 14;
pub const periph_interrupt_t_ETS_LP_RTC_TIMER_INTR_SOURCE: periph_interrupt_t = 15;
pub const periph_interrupt_t_ETS_LP_UART_INTR_SOURCE: periph_interrupt_t = 16;
pub const periph_interrupt_t_ETS_LP_I2C_INTR_SOURCE: periph_interrupt_t = 17;
pub const periph_interrupt_t_ETS_LP_WDT_INTR_SOURCE: periph_interrupt_t = 18;
pub const periph_interrupt_t_ETS_LP_PERI_TIMEOUT_INTR_SOURCE: periph_interrupt_t = 19;
pub const periph_interrupt_t_ETS_LP_APM_M0_INTR_SOURCE: periph_interrupt_t = 20;
pub const periph_interrupt_t_ETS_LP_APM_M1_INTR_SOURCE: periph_interrupt_t = 21;
#[doc = "< interrupt0 generated from a CPU, level"]
pub const periph_interrupt_t_ETS_FROM_CPU_INTR0_SOURCE: periph_interrupt_t = 22;
#[doc = "< interrupt1 generated from a CPU, level"]
pub const periph_interrupt_t_ETS_FROM_CPU_INTR1_SOURCE: periph_interrupt_t = 23;
#[doc = "< interrupt2 generated from a CPU, level"]
pub const periph_interrupt_t_ETS_FROM_CPU_INTR2_SOURCE: periph_interrupt_t = 24;
#[doc = "< interrupt3 generated from a CPU, level"]
pub const periph_interrupt_t_ETS_FROM_CPU_INTR3_SOURCE: periph_interrupt_t = 25;
#[doc = "< interrupt of Assist debug module, LEVEL"]
pub const periph_interrupt_t_ETS_ASSIST_DEBUG_INTR_SOURCE: periph_interrupt_t = 26;
pub const periph_interrupt_t_ETS_TRACE_INTR_SOURCE: periph_interrupt_t = 27;
pub const periph_interrupt_t_ETS_CACHE_INTR_SOURCE: periph_interrupt_t = 28;
pub const periph_interrupt_t_ETS_CPU_PERI_TIMEOUT_INTR_SOURCE: periph_interrupt_t = 29;
#[doc = "< interrupt of GPIO, level"]
pub const periph_interrupt_t_ETS_GPIO_INTR_SOURCE: periph_interrupt_t = 30;
#[doc = "< interrupt of GPIO, NMI"]
pub const periph_interrupt_t_ETS_GPIO_NMI_SOURCE: periph_interrupt_t = 31;
pub const periph_interrupt_t_ETS_PAU_INTR_SOURCE: periph_interrupt_t = 32;
pub const periph_interrupt_t_ETS_HP_PERI_TIMEOUT_INTR_SOURCE: periph_interrupt_t = 33;
pub const periph_interrupt_t_ETS_MODEM_PERI_TIMEOUT_INTR_SOURCE: periph_interrupt_t = 34;
pub const periph_interrupt_t_ETS_HP_APM_M0_INTR_SOURCE: periph_interrupt_t = 35;
pub const periph_interrupt_t_ETS_HP_APM_M1_INTR_SOURCE: periph_interrupt_t = 36;
pub const periph_interrupt_t_ETS_HP_APM_M2_INTR_SOURCE: periph_interrupt_t = 37;
pub const periph_interrupt_t_ETS_HP_APM_M3_INTR_SOURCE: periph_interrupt_t = 38;
pub const periph_interrupt_t_ETS_LP_APM0_INTR_SOURCE: periph_interrupt_t = 39;
pub const periph_interrupt_t_ETS_MSPI_INTR_SOURCE: periph_interrupt_t = 40;
#[doc = "< interrupt of I2S0, level"]
pub const periph_interrupt_t_ETS_I2S0_INTR_SOURCE: periph_interrupt_t = 41;
#[doc = "< interrupt of UHCI0, level"]
pub const periph_interrupt_t_ETS_UHCI0_INTR_SOURCE: periph_interrupt_t = 42;
#[doc = "< interrupt of UART0, level"]
pub const periph_interrupt_t_ETS_UART0_INTR_SOURCE: periph_interrupt_t = 43;
#[doc = "< interrupt of UART1, level"]
pub const periph_interrupt_t_ETS_UART1_INTR_SOURCE: periph_interrupt_t = 44;
#[doc = "< interrupt of LED PWM, level"]
pub const periph_interrupt_t_ETS_LEDC_INTR_SOURCE: periph_interrupt_t = 45;
#[doc = "< interrupt of twai0, level"]
pub const periph_interrupt_t_ETS_TWAI0_INTR_SOURCE: periph_interrupt_t = 46;
#[doc = "< interrupt of twai1, level"]
pub const periph_interrupt_t_ETS_TWAI1_INTR_SOURCE: periph_interrupt_t = 47;
#[doc = "< interrupt of USB, level"]
pub const periph_interrupt_t_ETS_USB_SERIAL_JTAG_INTR_SOURCE: periph_interrupt_t = 48;
#[doc = "< interrupt of remote controller, level"]
pub const periph_interrupt_t_ETS_RMT_INTR_SOURCE: periph_interrupt_t = 49;
#[doc = "< interrupt of I2C controller1, level"]
pub const periph_interrupt_t_ETS_I2C_EXT0_INTR_SOURCE: periph_interrupt_t = 50;
#[doc = "< interrupt of TIMER_GROUP0, TIMER0, level"]
pub const periph_interrupt_t_ETS_TG0_T0_LEVEL_INTR_SOURCE: periph_interrupt_t = 51;
#[doc = "< interrupt of TIMER_GROUP0, TIMER1, level"]
pub const periph_interrupt_t_ETS_TG0_T1_LEVEL_INTR_SOURCE: periph_interrupt_t = 52;
#[doc = "< interrupt of TIMER_GROUP0, WATCH DOG, level"]
pub const periph_interrupt_t_ETS_TG0_WDT_LEVEL_INTR_SOURCE: periph_interrupt_t = 53;
#[doc = "< interrupt of TIMER_GROUP1, TIMER0, level"]
pub const periph_interrupt_t_ETS_TG1_T0_LEVEL_INTR_SOURCE: periph_interrupt_t = 54;
#[doc = "< interrupt of TIMER_GROUP1, TIMER1, level"]
pub const periph_interrupt_t_ETS_TG1_T1_LEVEL_INTR_SOURCE: periph_interrupt_t = 55;
#[doc = "< interrupt of TIMER_GROUP1, WATCHDOG, level"]
pub const periph_interrupt_t_ETS_TG1_WDT_LEVEL_INTR_SOURCE: periph_interrupt_t = 56;
#[doc = "< interrupt of system timer 0"]
pub const periph_interrupt_t_ETS_SYSTIMER_TARGET0_INTR_SOURCE: periph_interrupt_t = 57;
#[doc = "< interrupt of system timer 1"]
pub const periph_interrupt_t_ETS_SYSTIMER_TARGET1_INTR_SOURCE: periph_interrupt_t = 58;
#[doc = "< interrupt of system timer 2"]
pub const periph_interrupt_t_ETS_SYSTIMER_TARGET2_INTR_SOURCE: periph_interrupt_t = 59;
#[doc = "< use ETS_SYSTIMER_TARGET0_INTR_SOURCE"]
pub const periph_interrupt_t_ETS_SYSTIMER_TARGET0_EDGE_INTR_SOURCE: periph_interrupt_t = 57;
#[doc = "< use ETS_SYSTIMER_TARGET1_INTR_SOURCE"]
pub const periph_interrupt_t_ETS_SYSTIMER_TARGET1_EDGE_INTR_SOURCE: periph_interrupt_t = 58;
#[doc = "< use ETS_SYSTIMER_TARGET2_INTR_SOURCE"]
pub const periph_interrupt_t_ETS_SYSTIMER_TARGET2_EDGE_INTR_SOURCE: periph_interrupt_t = 59;
#[doc = "< interrupt of APB ADC, LEVEL"]
pub const periph_interrupt_t_ETS_APB_ADC_INTR_SOURCE: periph_interrupt_t = 60;
pub const periph_interrupt_t_ETS_TEMPERATURE_SENSOR_INTR_SOURCE: periph_interrupt_t = 60;
#[doc = "< interrupt of MCPWM0, LEVEL"]
pub const periph_interrupt_t_ETS_MCPWM0_INTR_SOURCE: periph_interrupt_t = 61;
pub const periph_interrupt_t_ETS_PCNT_INTR_SOURCE: periph_interrupt_t = 62;
pub const periph_interrupt_t_ETS_PARL_IO_INTR_SOURCE: periph_interrupt_t = 63;
pub const periph_interrupt_t_ETS_SLC0_INTR_SOURCE: periph_interrupt_t = 64;
pub const periph_interrupt_t_ETS_SLC_INTR_SOURCE: periph_interrupt_t = 65;
#[doc = "< interrupt of general DMA IN channel 0, LEVEL"]
pub const periph_interrupt_t_ETS_DMA_IN_CH0_INTR_SOURCE: periph_interrupt_t = 66;
#[doc = "< interrupt of general DMA IN channel 1, LEVEL"]
pub const periph_interrupt_t_ETS_DMA_IN_CH1_INTR_SOURCE: periph_interrupt_t = 67;
#[doc = "< interrupt of general DMA IN channel 2, LEVEL"]
pub const periph_interrupt_t_ETS_DMA_IN_CH2_INTR_SOURCE: periph_interrupt_t = 68;
#[doc = "< interrupt of general DMA OUT channel 0, LEVEL"]
pub const periph_interrupt_t_ETS_DMA_OUT_CH0_INTR_SOURCE: periph_interrupt_t = 69;
#[doc = "< interrupt of general DMA OUT channel 1, LEVEL"]
pub const periph_interrupt_t_ETS_DMA_OUT_CH1_INTR_SOURCE: periph_interrupt_t = 70;
#[doc = "< interrupt of general DMA OUT channel 2, LEVEL"]
pub const periph_interrupt_t_ETS_DMA_OUT_CH2_INTR_SOURCE: periph_interrupt_t = 71;
pub const periph_interrupt_t_ETS_GSPI2_INTR_SOURCE: periph_interrupt_t = 72;
#[doc = "< interrupt of AES accelerator, level"]
pub const periph_interrupt_t_ETS_AES_INTR_SOURCE: periph_interrupt_t = 73;
#[doc = "< interrupt of SHA accelerator, level"]
pub const periph_interrupt_t_ETS_SHA_INTR_SOURCE: periph_interrupt_t = 74;
#[doc = "< interrupt of RSA accelerator, level"]
pub const periph_interrupt_t_ETS_RSA_INTR_SOURCE: periph_interrupt_t = 75;
#[doc = "< interrupt of ECC accelerator, level"]
pub const periph_interrupt_t_ETS_ECC_INTR_SOURCE: periph_interrupt_t = 76;
pub const periph_interrupt_t_ETS_MAX_INTR_SOURCE: periph_interrupt_t = 77;
pub type periph_interrupt_t = crate::c_types::c_uint;
pub use self::periph_interrupt_t as periph_interrput_t;
extern "C" {
    pub static esp_isr_names: [*const crate::c_types::c_char; 77usize];
}
pub const periph_module_t_PERIPH_LEDC_MODULE: periph_module_t = 0;
pub const periph_module_t_PERIPH_UART0_MODULE: periph_module_t = 1;
pub const periph_module_t_PERIPH_UART1_MODULE: periph_module_t = 2;
pub const periph_module_t_PERIPH_USB_DEVICE_MODULE: periph_module_t = 3;
pub const periph_module_t_PERIPH_I2C0_MODULE: periph_module_t = 4;
pub const periph_module_t_PERIPH_I2S0_MODULE: periph_module_t = 5;
pub const periph_module_t_PERIPH_TIMG0_MODULE: periph_module_t = 6;
pub const periph_module_t_PERIPH_TIMG1_MODULE: periph_module_t = 7;
pub const periph_module_t_PERIPH_UHCI0_MODULE: periph_module_t = 8;
pub const periph_module_t_PERIPH_RMT_MODULE: periph_module_t = 9;
pub const periph_module_t_PERIPH_PCNT_MODULE: periph_module_t = 10;
pub const periph_module_t_PERIPH_SPI_MODULE: periph_module_t = 11;
pub const periph_module_t_PERIPH_SPI2_MODULE: periph_module_t = 12;
pub const periph_module_t_PERIPH_TWAI0_MODULE: periph_module_t = 13;
pub const periph_module_t_PERIPH_TWAI1_MODULE: periph_module_t = 14;
pub const periph_module_t_PERIPH_RNG_MODULE: periph_module_t = 15;
pub const periph_module_t_PERIPH_RSA_MODULE: periph_module_t = 16;
pub const periph_module_t_PERIPH_AES_MODULE: periph_module_t = 17;
pub const periph_module_t_PERIPH_SHA_MODULE: periph_module_t = 18;
pub const periph_module_t_PERIPH_ECC_MODULE: periph_module_t = 19;
pub const periph_module_t_PERIPH_HMAC_MODULE: periph_module_t = 20;
pub const periph_module_t_PERIPH_DS_MODULE: periph_module_t = 21;
pub const periph_module_t_PERIPH_SDIO_SLAVE_MODULE: periph_module_t = 22;
pub const periph_module_t_PERIPH_GDMA_MODULE: periph_module_t = 23;
pub const periph_module_t_PERIPH_MCPWM0_MODULE: periph_module_t = 24;
pub const periph_module_t_PERIPH_ETM_MODULE: periph_module_t = 25;
pub const periph_module_t_PERIPH_PARLIO_MODULE: periph_module_t = 26;
pub const periph_module_t_PERIPH_SYSTIMER_MODULE: periph_module_t = 27;
pub const periph_module_t_PERIPH_SARADC_MODULE: periph_module_t = 28;
pub const periph_module_t_PERIPH_TEMPSENSOR_MODULE: periph_module_t = 29;
pub const periph_module_t_PERIPH_ASSIST_DEBUG_MODULE: periph_module_t = 30;
pub const periph_module_t_PERIPH_LP_I2C0_MODULE: periph_module_t = 31;
pub const periph_module_t_PERIPH_LP_UART0_MODULE: periph_module_t = 32;
pub const periph_module_t_PERIPH_WIFI_MODULE: periph_module_t = 33;
pub const periph_module_t_PERIPH_BT_MODULE: periph_module_t = 34;
pub const periph_module_t_PERIPH_IEEE802154_MODULE: periph_module_t = 35;
pub const periph_module_t_PERIPH_COEX_MODULE: periph_module_t = 36;
pub const periph_module_t_PERIPH_PHY_MODULE: periph_module_t = 37;
pub const periph_module_t_PERIPH_ANA_I2C_MASTER_MODULE: periph_module_t = 38;
pub const periph_module_t_PERIPH_MODEM_ETM_MODULE: periph_module_t = 39;
pub const periph_module_t_PERIPH_MODEM_ADC_COMMON_FE_MODULE: periph_module_t = 40;
pub const periph_module_t_PERIPH_MODULE_MAX: periph_module_t = 41;
pub type periph_module_t = crate::c_types::c_uint;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_MODEM_APB: modem_clock_domain_t = 0;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_MODEM_PERIPH: modem_clock_domain_t = 1;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_WIFI: modem_clock_domain_t = 2;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_BT: modem_clock_domain_t = 3;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_MODEM_FE: modem_clock_domain_t = 4;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_IEEE802154: modem_clock_domain_t = 5;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_LP_APB: modem_clock_domain_t = 6;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_I2C_MASTER: modem_clock_domain_t = 7;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_COEX: modem_clock_domain_t = 8;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_WIFIPWR: modem_clock_domain_t = 9;
pub const modem_clock_domain_t_MODEM_CLOCK_DOMAIN_MAX: modem_clock_domain_t = 10;
pub type modem_clock_domain_t = crate::c_types::c_uint;
pub const modem_clock_lpclk_src_t_MODEM_CLOCK_LPCLK_SRC_INVALID: modem_clock_lpclk_src_t = -1;
pub const modem_clock_lpclk_src_t_MODEM_CLOCK_LPCLK_SRC_RC_SLOW: modem_clock_lpclk_src_t = 0;
pub const modem_clock_lpclk_src_t_MODEM_CLOCK_LPCLK_SRC_RC_FAST: modem_clock_lpclk_src_t = 1;
pub const modem_clock_lpclk_src_t_MODEM_CLOCK_LPCLK_SRC_MAIN_XTAL: modem_clock_lpclk_src_t = 2;
pub const modem_clock_lpclk_src_t_MODEM_CLOCK_LPCLK_SRC_RC32K: modem_clock_lpclk_src_t = 3;
pub const modem_clock_lpclk_src_t_MODEM_CLOCK_LPCLK_SRC_XTAL32K: modem_clock_lpclk_src_t = 4;
pub const modem_clock_lpclk_src_t_MODEM_CLOCK_LPCLK_SRC_EXT32K: modem_clock_lpclk_src_t = 5;
pub const modem_clock_lpclk_src_t_MODEM_CLOCK_LPCLK_SRC_MAX: modem_clock_lpclk_src_t = 6;
pub type modem_clock_lpclk_src_t = crate::c_types::c_int;
#[doc = "< Internal 17.5MHz RC oscillator"]
pub const soc_root_clk_t_SOC_ROOT_CLK_INT_RC_FAST: soc_root_clk_t = 0;
#[doc = "< Internal 136kHz RC oscillator"]
pub const soc_root_clk_t_SOC_ROOT_CLK_INT_RC_SLOW: soc_root_clk_t = 1;
#[doc = "< External 40MHz crystal"]
pub const soc_root_clk_t_SOC_ROOT_CLK_EXT_XTAL: soc_root_clk_t = 2;
#[doc = "< External 32kHz crystal"]
pub const soc_root_clk_t_SOC_ROOT_CLK_EXT_XTAL32K: soc_root_clk_t = 3;
#[doc = "< Internal 32kHz RC oscillator"]
pub const soc_root_clk_t_SOC_ROOT_CLK_INT_RC32K: soc_root_clk_t = 4;
#[doc = "< External slow clock signal at pin0"]
pub const soc_root_clk_t_SOC_ROOT_CLK_EXT_OSC_SLOW: soc_root_clk_t = 5;
#[doc = " @brief Root clock"]
pub type soc_root_clk_t = crate::c_types::c_uint;
#[doc = "< Select XTAL_CLK as CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_XTAL: soc_cpu_clk_src_t = 0;
#[doc = "< Select PLL_CLK as CPU_CLK source (PLL_CLK is the output of 40MHz crystal oscillator frequency multiplier, 480MHz)"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_PLL: soc_cpu_clk_src_t = 1;
#[doc = "< Select RC_FAST_CLK as CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_RC_FAST: soc_cpu_clk_src_t = 2;
#[doc = "< Invalid CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_INVALID: soc_cpu_clk_src_t = 3;
#[doc = " @brief CPU_CLK mux inputs, which are the supported clock sources for the CPU_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_cpu_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select RC_SLOW_CLK as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_RC_SLOW: soc_rtc_slow_clk_src_t = 0;
#[doc = "< Select XTAL32K_CLK as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_XTAL32K: soc_rtc_slow_clk_src_t = 1;
#[doc = "< Select RC32K_CLK as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_RC32K: soc_rtc_slow_clk_src_t = 2;
#[doc = "< Select OSC_SLOW_CLK (external slow clock) as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_OSC_SLOW: soc_rtc_slow_clk_src_t = 3;
#[doc = "< Invalid RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_INVALID: soc_rtc_slow_clk_src_t = 4;
#[doc = " @brief RTC_SLOW_CLK mux inputs, which are the supported clock sources for the RTC_SLOW_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_rtc_slow_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select RC_FAST_CLK as RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_RC_FAST: soc_rtc_fast_clk_src_t = 0;
#[doc = "< Select XTAL_D2_CLK as RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_XTAL_D2: soc_rtc_fast_clk_src_t = 1;
#[doc = "< Invalid RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_INVALID: soc_rtc_fast_clk_src_t = 2;
#[doc = "< XTAL_D2_CLK is the default clock source for RTC_FAST_CLK"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_DEFAULT: soc_rtc_fast_clk_src_t = 1;
#[doc = "< Alias name for `SOC_RTC_FAST_CLK_SRC_XTAL_D2`"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_XTAL_DIV: soc_rtc_fast_clk_src_t = 1;
#[doc = " @brief RTC_FAST_CLK mux inputs, which are the supported clock sources for the RTC_FAST_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_rtc_fast_clk_src_t = crate::c_types::c_uint;
#[doc = "< 40MHz XTAL"]
pub const soc_xtal_freq_t_SOC_XTAL_FREQ_40M: soc_xtal_freq_t = 40;
#[doc = " @brief Possible main XTAL frequency options on the target\n @note Enum values equal to the frequency value in MHz\n @note Not all frequency values listed here are supported in IDF. Please check SOC_XTAL_SUPPORT_XXX in soc_caps.h for\n       the supported ones."]
pub type soc_xtal_freq_t = crate::c_types::c_uint;
#[doc = "< CPU_CLK can be sourced from XTAL, PLL, or RC_FAST by configuring soc_cpu_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_CPU: soc_module_clk_t = 1;
#[doc = "< RTC_FAST_CLK can be sourced from XTAL_D2 or RC_FAST by configuring soc_rtc_fast_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_RTC_FAST: soc_module_clk_t = 2;
#[doc = "< RTC_SLOW_CLK can be sourced from RC_SLOW, XTAL32K, RC32K, or OSC_SLOW by configuring soc_rtc_slow_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_RTC_SLOW: soc_module_clk_t = 3;
#[doc = "< PLL_F80M_CLK is derived from PLL (clock gating + fixed divider of 6), it has a fixed frequency of 80MHz"]
pub const soc_module_clk_t_SOC_MOD_CLK_PLL_F80M: soc_module_clk_t = 4;
#[doc = "< PLL_F160M_CLK is derived from PLL (clock gating + fixed divider of 3), it has a fixed frequency of 160MHz"]
pub const soc_module_clk_t_SOC_MOD_CLK_PLL_F160M: soc_module_clk_t = 5;
#[doc = "< PLL_F240M_CLK is derived from PLL (clock gating + fixed divider of 2), it has a fixed frequency of 240MHz"]
pub const soc_module_clk_t_SOC_MOD_CLK_PLL_F240M: soc_module_clk_t = 6;
#[doc = "< XTAL32K_CLK comes from the external 32kHz crystal, passing a clock gating to the peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_XTAL32K: soc_module_clk_t = 7;
#[doc = "< RC_FAST_CLK comes from the internal 20MHz rc oscillator, passing a clock gating to the peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_RC_FAST: soc_module_clk_t = 8;
#[doc = "< XTAL_CLK comes from the external 40MHz crystal"]
pub const soc_module_clk_t_SOC_MOD_CLK_XTAL: soc_module_clk_t = 9;
#[doc = "< XTAL_D2_CLK comes from the external 40MHz crystal, passing a div of 2 to the LP peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_XTAL_D2: soc_module_clk_t = 10;
#[doc = "< Indication of the end of the available module clock sources"]
pub const soc_module_clk_t_SOC_MOD_CLK_INVALID: soc_module_clk_t = 11;
#[doc = " @brief Supported clock sources for modules (CPU, peripherals, RTC, etc.)\n\n @note enum starts from 1, to save 0 for special purpose"]
pub type soc_module_clk_t = crate::c_types::c_uint;
#[doc = "< SYSTIMER source clock is XTAL"]
pub const soc_periph_systimer_clk_src_t_SYSTIMER_CLK_SRC_XTAL: soc_periph_systimer_clk_src_t = 9;
#[doc = "< SYSTIMER source clock is RC_FAST"]
pub const soc_periph_systimer_clk_src_t_SYSTIMER_CLK_SRC_RC_FAST: soc_periph_systimer_clk_src_t = 8;
#[doc = "< SYSTIMER source clock default choice is XTAL"]
pub const soc_periph_systimer_clk_src_t_SYSTIMER_CLK_SRC_DEFAULT: soc_periph_systimer_clk_src_t = 9;
#[doc = " @brief Type of SYSTIMER clock source"]
pub type soc_periph_systimer_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select PLL_F80M as the source clock"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_PLL_F80M: soc_periph_gptimer_clk_src_t = 4;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_RC_FAST: soc_periph_gptimer_clk_src_t = 8;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_XTAL: soc_periph_gptimer_clk_src_t = 9;
#[doc = "< Select PLL_F80M as the default choice"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_DEFAULT: soc_periph_gptimer_clk_src_t = 4;
#[doc = " @brief Type of GPTimer clock source"]
pub type soc_periph_gptimer_clk_src_t = crate::c_types::c_uint;
#[doc = "< Timer group clock source is PLL_F80M"]
pub const soc_periph_tg_clk_src_legacy_t_TIMER_SRC_CLK_PLL_F80M: soc_periph_tg_clk_src_legacy_t = 4;
#[doc = "< Timer group clock source is XTAL"]
pub const soc_periph_tg_clk_src_legacy_t_TIMER_SRC_CLK_XTAL: soc_periph_tg_clk_src_legacy_t = 9;
#[doc = "< Timer group clock source default choice is PLL_F80M"]
pub const soc_periph_tg_clk_src_legacy_t_TIMER_SRC_CLK_DEFAULT: soc_periph_tg_clk_src_legacy_t = 4;
#[doc = " @brief Type of Timer Group clock source, reserved for the legacy timer group driver"]
pub type soc_periph_tg_clk_src_legacy_t = crate::c_types::c_uint;
#[doc = "< Select PLL_F80M as the source clock"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_PLL_F80M: soc_periph_rmt_clk_src_t = 4;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_RC_FAST: soc_periph_rmt_clk_src_t = 8;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_XTAL: soc_periph_rmt_clk_src_t = 9;
#[doc = "< Select PLL_F80M as the default choice"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_DEFAULT: soc_periph_rmt_clk_src_t = 4;
#[doc = " @brief Type of RMT clock source"]
pub type soc_periph_rmt_clk_src_t = crate::c_types::c_uint;
#[doc = "< RMT source clock is PLL_F80M"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_PLL_F80M: soc_periph_rmt_clk_src_legacy_t = 4;
#[doc = "< RMT source clock is XTAL"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_XTAL: soc_periph_rmt_clk_src_legacy_t = 9;
#[doc = "< RMT source clock default choice is PLL_F80M"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_DEFAULT: soc_periph_rmt_clk_src_legacy_t = 4;
#[doc = " @brief Type of RMT clock source, reserved for the legacy RMT driver"]
pub type soc_periph_rmt_clk_src_legacy_t = crate::c_types::c_uint;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_temperature_sensor_clk_src_t_TEMPERATURE_SENSOR_CLK_SRC_XTAL:
    soc_periph_temperature_sensor_clk_src_t = 9;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_temperature_sensor_clk_src_t_TEMPERATURE_SENSOR_CLK_SRC_RC_FAST:
    soc_periph_temperature_sensor_clk_src_t = 8;
#[doc = "< Select XTAL as the default choice"]
pub const soc_periph_temperature_sensor_clk_src_t_TEMPERATURE_SENSOR_CLK_SRC_DEFAULT:
    soc_periph_temperature_sensor_clk_src_t = 9;
#[doc = " @brief Type of Temp Sensor clock source"]
pub type soc_periph_temperature_sensor_clk_src_t = crate::c_types::c_uint;
#[doc = "< UART source clock is PLL_F80M"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_PLL_F80M: soc_periph_uart_clk_src_legacy_t = 4;
#[doc = "< UART source clock is RC_FAST"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_RTC: soc_periph_uart_clk_src_legacy_t = 8;
#[doc = "< UART source clock is XTAL"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_XTAL: soc_periph_uart_clk_src_legacy_t = 9;
#[doc = "< UART source clock default choice is PLL_F80M"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_DEFAULT: soc_periph_uart_clk_src_legacy_t = 4;
#[doc = " @brief Type of UART clock source, reserved for the legacy UART driver"]
pub type soc_periph_uart_clk_src_legacy_t = crate::c_types::c_uint;
#[doc = "< LP_UART source clock is LP(RTC)_FAST"]
pub const soc_periph_lp_uart_clk_src_t_LP_UART_SCLK_LP_FAST: soc_periph_lp_uart_clk_src_t = 2;
#[doc = "< LP_UART source clock is XTAL_D2"]
pub const soc_periph_lp_uart_clk_src_t_LP_UART_SCLK_XTAL_D2: soc_periph_lp_uart_clk_src_t = 10;
#[doc = "< LP_UART source clock default choice is LP(RTC)_FAST"]
pub const soc_periph_lp_uart_clk_src_t_LP_UART_SCLK_DEFAULT: soc_periph_lp_uart_clk_src_t = 2;
#[doc = " @brief Type of LP_UART clock source"]
pub type soc_periph_lp_uart_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select PLL_F160M as the source clock"]
pub const soc_periph_mcpwm_timer_clk_src_t_MCPWM_TIMER_CLK_SRC_PLL160M:
    soc_periph_mcpwm_timer_clk_src_t = 5;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_mcpwm_timer_clk_src_t_MCPWM_TIMER_CLK_SRC_XTAL:
    soc_periph_mcpwm_timer_clk_src_t = 9;
#[doc = "< Select PLL_F160M as the default clock choice"]
pub const soc_periph_mcpwm_timer_clk_src_t_MCPWM_TIMER_CLK_SRC_DEFAULT:
    soc_periph_mcpwm_timer_clk_src_t = 5;
#[doc = " @brief Type of MCPWM timer clock source"]
pub type soc_periph_mcpwm_timer_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select PLL_F160M as the source clock"]
pub const soc_periph_mcpwm_capture_clk_src_t_MCPWM_CAPTURE_CLK_SRC_PLL160M:
    soc_periph_mcpwm_capture_clk_src_t = 5;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_mcpwm_capture_clk_src_t_MCPWM_CAPTURE_CLK_SRC_XTAL:
    soc_periph_mcpwm_capture_clk_src_t = 9;
#[doc = "< Select PLL_F160M as the default clock choice"]
pub const soc_periph_mcpwm_capture_clk_src_t_MCPWM_CAPTURE_CLK_SRC_DEFAULT:
    soc_periph_mcpwm_capture_clk_src_t = 5;
#[doc = " @brief Type of MCPWM capture clock source"]
pub type soc_periph_mcpwm_capture_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select PLL_F160M as the source clock"]
pub const soc_periph_mcpwm_carrier_clk_src_t_MCPWM_CARRIER_CLK_SRC_PLL160M:
    soc_periph_mcpwm_carrier_clk_src_t = 5;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_mcpwm_carrier_clk_src_t_MCPWM_CARRIER_CLK_SRC_XTAL:
    soc_periph_mcpwm_carrier_clk_src_t = 9;
#[doc = "< Select PLL_F160M as the default clock choice"]
pub const soc_periph_mcpwm_carrier_clk_src_t_MCPWM_CARRIER_CLK_SRC_DEFAULT:
    soc_periph_mcpwm_carrier_clk_src_t = 5;
#[doc = " @brief Type of MCPWM carrier clock source"]
pub type soc_periph_mcpwm_carrier_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select PLL_F160M as the default source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_DEFAULT: soc_periph_i2s_clk_src_t = 5;
#[doc = "< Select PLL_F160M as the source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_PLL_160M: soc_periph_i2s_clk_src_t = 5;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_XTAL: soc_periph_i2s_clk_src_t = 9;
#[doc = "< Select external clock as source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_EXTERNAL: soc_periph_i2s_clk_src_t = -1;
#[doc = " @brief I2S clock source enum"]
pub type soc_periph_i2s_clk_src_t = crate::c_types::c_int;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_i2c_clk_src_t_I2C_CLK_SRC_XTAL: soc_periph_i2c_clk_src_t = 9;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_i2c_clk_src_t_I2C_CLK_SRC_RC_FAST: soc_periph_i2c_clk_src_t = 8;
#[doc = "< Select XTAL as the default source clock"]
pub const soc_periph_i2c_clk_src_t_I2C_CLK_SRC_DEFAULT: soc_periph_i2c_clk_src_t = 9;
#[doc = " @brief Type of I2C clock source."]
pub type soc_periph_i2c_clk_src_t = crate::c_types::c_uint;
#[doc = "< LP_I2C source clock is RTC_FAST"]
pub const soc_periph_lp_i2c_clk_src_t_LP_I2C_SCLK_LP_FAST: soc_periph_lp_i2c_clk_src_t = 2;
#[doc = "< LP_I2C source clock is XTAL_D2"]
pub const soc_periph_lp_i2c_clk_src_t_LP_I2C_SCLK_XTAL_D2: soc_periph_lp_i2c_clk_src_t = 10;
#[doc = "< LP_I2C source clock default choice is RTC_FAST"]
pub const soc_periph_lp_i2c_clk_src_t_LP_I2C_SCLK_DEFAULT: soc_periph_lp_i2c_clk_src_t = 2;
#[doc = " @brief Type of LP_I2C clock source."]
pub type soc_periph_lp_i2c_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select PLL_80M as SPI source clock"]
pub const soc_periph_spi_clk_src_t_SPI_CLK_SRC_DEFAULT: soc_periph_spi_clk_src_t = 4;
#[doc = "< Select PLL_80M as SPI source clock"]
pub const soc_periph_spi_clk_src_t_SPI_CLK_SRC_PLL_F80M: soc_periph_spi_clk_src_t = 4;
#[doc = "< Select XTAL as SPI source clock"]
pub const soc_periph_spi_clk_src_t_SPI_CLK_SRC_XTAL: soc_periph_spi_clk_src_t = 9;
#[doc = "< Select RC_FAST as SPI source clock"]
pub const soc_periph_spi_clk_src_t_SPI_CLK_SRC_RC_FAST: soc_periph_spi_clk_src_t = 8;
#[doc = " @brief Type of SPI clock source."]
pub type soc_periph_spi_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select XTAL clock as the source clock"]
pub const soc_periph_sdm_clk_src_t_SDM_CLK_SRC_XTAL: soc_periph_sdm_clk_src_t = 9;
#[doc = "< Select PLL_F80M clock as the source clock"]
pub const soc_periph_sdm_clk_src_t_SDM_CLK_SRC_PLL_F80M: soc_periph_sdm_clk_src_t = 4;
#[doc = "< Select PLL_F80M clock as the default clock choice"]
pub const soc_periph_sdm_clk_src_t_SDM_CLK_SRC_DEFAULT: soc_periph_sdm_clk_src_t = 4;
#[doc = " @brief Sigma Delta Modulator clock source"]
pub type soc_periph_sdm_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select XTAL clock as the source clock"]
pub const soc_periph_glitch_filter_clk_src_t_GLITCH_FILTER_CLK_SRC_XTAL:
    soc_periph_glitch_filter_clk_src_t = 9;
#[doc = "< Select PLL_F80M clock as the source clock"]
pub const soc_periph_glitch_filter_clk_src_t_GLITCH_FILTER_CLK_SRC_PLL_F80M:
    soc_periph_glitch_filter_clk_src_t = 4;
#[doc = "< Select PLL_F80M clock as the default clock choice"]
pub const soc_periph_glitch_filter_clk_src_t_GLITCH_FILTER_CLK_SRC_DEFAULT:
    soc_periph_glitch_filter_clk_src_t = 4;
#[doc = " @brief Glitch filter clock source"]
pub type soc_periph_glitch_filter_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_twai_clk_src_t_TWAI_CLK_SRC_XTAL: soc_periph_twai_clk_src_t = 9;
#[doc = "< Select XTAL as the default clock choice"]
pub const soc_periph_twai_clk_src_t_TWAI_CLK_SRC_DEFAULT: soc_periph_twai_clk_src_t = 9;
#[doc = " @brief TWAI clock source"]
pub type soc_periph_twai_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_adc_digi_clk_src_t_ADC_DIGI_CLK_SRC_XTAL: soc_periph_adc_digi_clk_src_t = 9;
#[doc = "< Select PLL_F80M as the source clock"]
pub const soc_periph_adc_digi_clk_src_t_ADC_DIGI_CLK_SRC_PLL_F80M: soc_periph_adc_digi_clk_src_t =
    4;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_adc_digi_clk_src_t_ADC_DIGI_CLK_SRC_RC_FAST: soc_periph_adc_digi_clk_src_t = 8;
#[doc = "< Select PLL_F80M as the default clock choice"]
pub const soc_periph_adc_digi_clk_src_t_ADC_DIGI_CLK_SRC_DEFAULT: soc_periph_adc_digi_clk_src_t = 4;
#[doc = " @brief ADC digital controller clock source"]
pub type soc_periph_adc_digi_clk_src_t = crate::c_types::c_uint;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_mwdt_clk_src_t_MWDT_CLK_SRC_XTAL: soc_periph_mwdt_clk_src_t = 9;
#[doc = "< Select PLL fixed 80 MHz as the source clock"]
pub const soc_periph_mwdt_clk_src_t_MWDT_CLK_SRC_PLL_F80M: soc_periph_mwdt_clk_src_t = 4;
#[doc = "< Select RTC fast as the source clock"]
pub const soc_periph_mwdt_clk_src_t_MWDT_CLK_SRC_RC_FAST: soc_periph_mwdt_clk_src_t = 8;
#[doc = "< Select PLL fixed 80 MHz as the default clock choice"]
pub const soc_periph_mwdt_clk_src_t_MWDT_CLK_SRC_DEFAULT: soc_periph_mwdt_clk_src_t = 9;
#[doc = " @brief MWDT clock source"]
pub type soc_periph_mwdt_clk_src_t = crate::c_types::c_uint;
#[doc = "< LEDC source clock will be automatically selected based on the giving resolution and duty parameter when init the timer"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_AUTO_CLK: soc_periph_ledc_clk_src_legacy_t = 0;
#[doc = "< Select PLL_F80M clock as the source clock"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_USE_PLL_DIV_CLK: soc_periph_ledc_clk_src_legacy_t =
    4;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_USE_RC_FAST_CLK: soc_periph_ledc_clk_src_legacy_t =
    8;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_USE_XTAL_CLK: soc_periph_ledc_clk_src_legacy_t = 9;
#[doc = "< Alias of 'LEDC_USE_RC_FAST_CLK'"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_USE_RTC8M_CLK: soc_periph_ledc_clk_src_legacy_t = 8;
#[doc = " @brief Type of LEDC clock source, reserved for the legacy LEDC driver"]
pub type soc_periph_ledc_clk_src_legacy_t = crate::c_types::c_uint;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_parlio_clk_src_t_PARLIO_CLK_SRC_XTAL: soc_periph_parlio_clk_src_t = 9;
#[doc = "< Select PLL_F240M as the source clock"]
pub const soc_periph_parlio_clk_src_t_PARLIO_CLK_SRC_PLL_F240M: soc_periph_parlio_clk_src_t = 6;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_parlio_clk_src_t_PARLIO_CLK_SRC_RC_FAST: soc_periph_parlio_clk_src_t = 8;
#[doc = "< Select EXTERNAL clock as the source clock"]
pub const soc_periph_parlio_clk_src_t_PARLIO_CLK_SRC_EXTERNAL: soc_periph_parlio_clk_src_t = -1;
#[doc = "< Select PLL_F240M as the default clock choice"]
pub const soc_periph_parlio_clk_src_t_PARLIO_CLK_SRC_DEFAULT: soc_periph_parlio_clk_src_t = 6;
#[doc = " @brief PARLIO clock source"]
pub type soc_periph_parlio_clk_src_t = crate::c_types::c_int;
#[doc = "< PLL_CLK is the output of crystal oscillator frequency multiplier"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_PLL: soc_clkout_sig_id_t = 1;
#[doc = "< Main crystal oscillator clock"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_XTAL: soc_clkout_sig_id_t = 5;
#[doc = "< From PLL, usually be 80MHz"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_PLL_F80M: soc_clkout_sig_id_t = 13;
#[doc = "< CPU clock"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_CPU: soc_clkout_sig_id_t = 16;
#[doc = "< AHB clock"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_AHB: soc_clkout_sig_id_t = 17;
#[doc = "< APB clock"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_APB: soc_clkout_sig_id_t = 18;
#[doc = "< External 32kHz crystal clock"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_XTAL32K: soc_clkout_sig_id_t = 21;
#[doc = "< External slow clock input through XTAL_32K_P"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_EXT32K: soc_clkout_sig_id_t = 22;
#[doc = "< RC fast clock, about 17.5MHz"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_RC_FAST: soc_clkout_sig_id_t = 23;
#[doc = "< Internal slow RC oscillator"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_RC_32K: soc_clkout_sig_id_t = 24;
#[doc = "< RC slow clock, depends on the RTC_CLK_SRC configuration"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_RC_SLOW: soc_clkout_sig_id_t = 25;
pub const soc_clkout_sig_id_t_CLKOUT_SIG_INVALID: soc_clkout_sig_id_t = 255;
#[doc = "CLOCK OUTPUT///////////////////////////////////////////////////////////"]
pub type soc_clkout_sig_id_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_dig_power_reg_t {
    pub __bindgen_anon_1: pmu_hp_dig_power_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_dig_power_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_dig_power_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn vdd_spi_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vdd_spi_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_dslp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_dslp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mem_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aon_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aon_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn top_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_top_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        vdd_spi_pd_en: u32,
        mem_dslp: u32,
        mem_pd_en: u32,
        wifi_pd_en: u32,
        reserved1: u32,
        cpu_pd_en: u32,
        aon_pd_en: u32,
        top_pd_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 21u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let vdd_spi_pd_en: u32 = unsafe { ::core::mem::transmute(vdd_spi_pd_en) };
            vdd_spi_pd_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let mem_dslp: u32 = unsafe { ::core::mem::transmute(mem_dslp) };
            mem_dslp as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let mem_pd_en: u32 = unsafe { ::core::mem::transmute(mem_pd_en) };
            mem_pd_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let wifi_pd_en: u32 = unsafe { ::core::mem::transmute(wifi_pd_en) };
            wifi_pd_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let cpu_pd_en: u32 = unsafe { ::core::mem::transmute(cpu_pd_en) };
            cpu_pd_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let aon_pd_en: u32 = unsafe { ::core::mem::transmute(aon_pd_en) };
            aon_pd_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let top_pd_en: u32 = unsafe { ::core::mem::transmute(top_pd_en) };
            top_pd_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_icg_modem_reg_t {
    pub __bindgen_anon_1: pmu_hp_icg_modem_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_icg_modem_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_icg_modem_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn code(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, code: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let code: u32 = unsafe { ::core::mem::transmute(code) };
            code as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_sys_cntl_reg_t {
    pub __bindgen_anon_1: pmu_hp_sys_cntl_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_sys_cntl_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_sys_cntl_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn uart_wakeup_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uart_wakeup_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_pad_hold_all(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lp_pad_hold_all(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_pad_hold_all(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_pad_hold_all(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_pad_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_pad_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_pause_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_pause_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_cpu_stall(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_cpu_stall(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        uart_wakeup_en: u32,
        lp_pad_hold_all: u32,
        hp_pad_hold_all: u32,
        dig_pad_slp_sel: u32,
        dig_pause_wdt: u32,
        dig_cpu_stall: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let uart_wakeup_en: u32 = unsafe { ::core::mem::transmute(uart_wakeup_en) };
            uart_wakeup_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let lp_pad_hold_all: u32 = unsafe { ::core::mem::transmute(lp_pad_hold_all) };
            lp_pad_hold_all as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let hp_pad_hold_all: u32 = unsafe { ::core::mem::transmute(hp_pad_hold_all) };
            hp_pad_hold_all as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dig_pad_slp_sel: u32 = unsafe { ::core::mem::transmute(dig_pad_slp_sel) };
            dig_pad_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let dig_pause_wdt: u32 = unsafe { ::core::mem::transmute(dig_pause_wdt) };
            dig_pause_wdt as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let dig_cpu_stall: u32 = unsafe { ::core::mem::transmute(dig_cpu_stall) };
            dig_cpu_stall as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_clk_power_reg_t {
    pub __bindgen_anon_1: pmu_hp_clk_power_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_clk_power_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_clk_power_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_iso_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_iso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_retention(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_retention(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bb_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bb_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bbpll_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bbpll_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bbpll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bbpll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        i2c_iso_en: u32,
        i2c_retention: u32,
        xpd_bb_i2c: u32,
        xpd_bbpll_i2c: u32,
        xpd_bbpll: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let i2c_iso_en: u32 = unsafe { ::core::mem::transmute(i2c_iso_en) };
            i2c_iso_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let i2c_retention: u32 = unsafe { ::core::mem::transmute(i2c_retention) };
            i2c_retention as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let xpd_bb_i2c: u32 = unsafe { ::core::mem::transmute(xpd_bb_i2c) };
            xpd_bb_i2c as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let xpd_bbpll_i2c: u32 = unsafe { ::core::mem::transmute(xpd_bbpll_i2c) };
            xpd_bbpll_i2c as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let xpd_bbpll: u32 = unsafe { ::core::mem::transmute(xpd_bbpll) };
            xpd_bbpll as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_bias_reg_t {
    pub __bindgen_anon_1: pmu_hp_bias_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_bias_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_bias_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbg_atten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dbg_atten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_cur(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_cur(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_sleep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_sleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        xpd_bias: u32,
        dbg_atten: u32,
        pd_cur: u32,
        bias_sleep: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let xpd_bias: u32 = unsafe { ::core::mem::transmute(xpd_bias) };
            xpd_bias as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let dbg_atten: u32 = unsafe { ::core::mem::transmute(dbg_atten) };
            dbg_atten as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let pd_cur: u32 = unsafe { ::core::mem::transmute(pd_cur) };
            pd_cur as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bias_sleep: u32 = unsafe { ::core::mem::transmute(bias_sleep) };
            bias_sleep as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_backup_reg_t {
    pub __bindgen_anon_1: pmu_hp_backup_reg_t__bindgen_ty_1,
    pub __bindgen_anon_2: pmu_hp_backup_reg_t__bindgen_ty_2,
    pub __bindgen_anon_3: pmu_hp_backup_reg_t__bindgen_ty_3,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_backup_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_backup_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2active_backup_modem_clk_code(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2active_backup_modem_clk_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2active_backup_modem_clk_code(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2active_backup_modem_clk_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_active_retention_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_active_retention_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2active_retention_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2active_retention_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2active_retention_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2active_retention_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2active_backup_clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2active_backup_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2active_backup_clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2active_backup_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2active_backup_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2active_backup_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2active_backup_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2active_backup_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2active_backup_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2active_backup_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2active_backup_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2active_backup_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        hp_sleep2active_backup_modem_clk_code: u32,
        hp_modem2active_backup_modem_clk_code: u32,
        reserved1: u32,
        hp_active_retention_mode: u32,
        hp_sleep2active_retention_en: u32,
        hp_modem2active_retention_en: u32,
        reserved2: u32,
        hp_sleep2active_backup_clk_sel: u32,
        hp_modem2active_backup_clk_sel: u32,
        reserved3: u32,
        hp_sleep2active_backup_mode: u32,
        hp_modem2active_backup_mode: u32,
        reserved4: u32,
        hp_sleep2active_backup_en: u32,
        hp_modem2active_backup_en: u32,
        reserved5: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let hp_sleep2active_backup_modem_clk_code: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2active_backup_modem_clk_code) };
            hp_sleep2active_backup_modem_clk_code as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let hp_modem2active_backup_modem_clk_code: u32 =
                unsafe { ::core::mem::transmute(hp_modem2active_backup_modem_clk_code) };
            hp_modem2active_backup_modem_clk_code as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hp_active_retention_mode: u32 =
                unsafe { ::core::mem::transmute(hp_active_retention_mode) };
            hp_active_retention_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hp_sleep2active_retention_en: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2active_retention_en) };
            hp_sleep2active_retention_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hp_modem2active_retention_en: u32 =
                unsafe { ::core::mem::transmute(hp_modem2active_retention_en) };
            hp_modem2active_retention_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let hp_sleep2active_backup_clk_sel: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2active_backup_clk_sel) };
            hp_sleep2active_backup_clk_sel as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let hp_modem2active_backup_clk_sel: u32 =
                unsafe { ::core::mem::transmute(hp_modem2active_backup_clk_sel) };
            hp_modem2active_backup_clk_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let hp_sleep2active_backup_mode: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2active_backup_mode) };
            hp_sleep2active_backup_mode as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let hp_modem2active_backup_mode: u32 =
                unsafe { ::core::mem::transmute(hp_modem2active_backup_mode) };
            hp_modem2active_backup_mode as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let hp_sleep2active_backup_en: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2active_backup_en) };
            hp_sleep2active_backup_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let hp_modem2active_backup_en: u32 =
                unsafe { ::core::mem::transmute(hp_modem2active_backup_en) };
            hp_modem2active_backup_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved5: u32 = unsafe { ::core::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_backup_reg_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_backup_reg_t__bindgen_ty_2 {
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2modem_backup_modem_clk_code(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2modem_backup_modem_clk_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem_retention_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem_retention_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2modem_retention_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2modem_retention_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2modem_backup_clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2modem_backup_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2modem_backup_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2modem_backup_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep2modem_backup_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep2modem_backup_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved6: u32,
        hp_sleep2modem_backup_modem_clk_code: u32,
        reserved7: u32,
        hp_modem_retention_mode: u32,
        hp_sleep2modem_retention_en: u32,
        reserved8: u32,
        hp_sleep2modem_backup_clk_sel: u32,
        reserved9: u32,
        hp_sleep2modem_backup_mode: u32,
        reserved10: u32,
        hp_sleep2modem_backup_en: u32,
        reserved11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let hp_sleep2modem_backup_modem_clk_code: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2modem_backup_modem_clk_code) };
            hp_sleep2modem_backup_modem_clk_code as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let reserved7: u32 = unsafe { ::core::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hp_modem_retention_mode: u32 =
                unsafe { ::core::mem::transmute(hp_modem_retention_mode) };
            hp_modem_retention_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hp_sleep2modem_retention_en: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2modem_retention_en) };
            hp_sleep2modem_retention_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let hp_sleep2modem_backup_clk_sel: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2modem_backup_clk_sel) };
            hp_sleep2modem_backup_clk_sel as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let hp_sleep2modem_backup_mode: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2modem_backup_mode) };
            hp_sleep2modem_backup_mode as u64
        });
        __bindgen_bitfield_unit.set(23usize, 6u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let hp_sleep2modem_backup_en: u32 =
                unsafe { ::core::mem::transmute(hp_sleep2modem_backup_en) };
            hp_sleep2modem_backup_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_backup_reg_t__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_backup_reg_t__bindgen_ty_3 {
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2sleep_backup_modem_clk_code(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2sleep_backup_modem_clk_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_active2sleep_backup_modem_clk_code(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_active2sleep_backup_modem_clk_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_sleep_retention_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_sleep_retention_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2sleep_retention_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2sleep_retention_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_active2sleep_retention_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_active2sleep_retention_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2sleep_backup_clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2sleep_backup_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_active2sleep_backup_clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hp_active2sleep_backup_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2sleep_backup_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2sleep_backup_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_active2sleep_backup_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hp_active2sleep_backup_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_modem2sleep_backup_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_modem2sleep_backup_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_active2sleep_backup_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_active2sleep_backup_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved12: u32,
        hp_modem2sleep_backup_modem_clk_code: u32,
        hp_active2sleep_backup_modem_clk_code: u32,
        hp_sleep_retention_mode: u32,
        reserved13: u32,
        hp_modem2sleep_retention_en: u32,
        hp_active2sleep_retention_en: u32,
        reserved14: u32,
        hp_modem2sleep_backup_clk_sel: u32,
        hp_active2sleep_backup_clk_sel: u32,
        reserved15: u32,
        hp_modem2sleep_backup_mode: u32,
        hp_active2sleep_backup_mode: u32,
        reserved16: u32,
        hp_modem2sleep_backup_en: u32,
        hp_active2sleep_backup_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let hp_modem2sleep_backup_modem_clk_code: u32 =
                unsafe { ::core::mem::transmute(hp_modem2sleep_backup_modem_clk_code) };
            hp_modem2sleep_backup_modem_clk_code as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let hp_active2sleep_backup_modem_clk_code: u32 =
                unsafe { ::core::mem::transmute(hp_active2sleep_backup_modem_clk_code) };
            hp_active2sleep_backup_modem_clk_code as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hp_sleep_retention_mode: u32 =
                unsafe { ::core::mem::transmute(hp_sleep_retention_mode) };
            hp_sleep_retention_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved13: u32 = unsafe { ::core::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hp_modem2sleep_retention_en: u32 =
                unsafe { ::core::mem::transmute(hp_modem2sleep_retention_en) };
            hp_modem2sleep_retention_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hp_active2sleep_retention_en: u32 =
                unsafe { ::core::mem::transmute(hp_active2sleep_retention_en) };
            hp_active2sleep_retention_en as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let reserved14: u32 = unsafe { ::core::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let hp_modem2sleep_backup_clk_sel: u32 =
                unsafe { ::core::mem::transmute(hp_modem2sleep_backup_clk_sel) };
            hp_modem2sleep_backup_clk_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let hp_active2sleep_backup_clk_sel: u32 =
                unsafe { ::core::mem::transmute(hp_active2sleep_backup_clk_sel) };
            hp_active2sleep_backup_clk_sel as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let hp_modem2sleep_backup_mode: u32 =
                unsafe { ::core::mem::transmute(hp_modem2sleep_backup_mode) };
            hp_modem2sleep_backup_mode as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let hp_active2sleep_backup_mode: u32 =
                unsafe { ::core::mem::transmute(hp_active2sleep_backup_mode) };
            hp_active2sleep_backup_mode as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let hp_modem2sleep_backup_en: u32 =
                unsafe { ::core::mem::transmute(hp_modem2sleep_backup_en) };
            hp_modem2sleep_backup_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let hp_active2sleep_backup_en: u32 =
                unsafe { ::core::mem::transmute(hp_active2sleep_backup_en) };
            hp_active2sleep_backup_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_sysclk_reg_t {
    pub __bindgen_anon_1: pmu_hp_sysclk_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_sysclk_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_sysclk_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_sysclk_nodiv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_sysclk_nodiv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icg_sysclk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icg_sysclk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sysclk_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sysclk_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icg_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icg_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_sysclk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dig_sysclk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dig_sysclk_nodiv: u32,
        icg_sysclk_en: u32,
        sysclk_slp_sel: u32,
        icg_slp_sel: u32,
        dig_sysclk_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let dig_sysclk_nodiv: u32 = unsafe { ::core::mem::transmute(dig_sysclk_nodiv) };
            dig_sysclk_nodiv as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let icg_sysclk_en: u32 = unsafe { ::core::mem::transmute(icg_sysclk_en) };
            icg_sysclk_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sysclk_slp_sel: u32 = unsafe { ::core::mem::transmute(sysclk_slp_sel) };
            sysclk_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let icg_slp_sel: u32 = unsafe { ::core::mem::transmute(icg_slp_sel) };
            icg_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let dig_sysclk_sel: u32 = unsafe { ::core::mem::transmute(dig_sysclk_sel) };
            dig_sysclk_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_regulator0_reg_t {
    pub __bindgen_anon_1: pmu_hp_regulator0_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_regulator0_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_regulator0_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_dbias_vol(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_lp_dbias_vol(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_dbias_vol(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hp_dbias_vol(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dbias_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dbias_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbias_init(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dbias_init(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_mem_xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_mem_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_logic_xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_logic_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_mem_dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_slp_mem_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_logic_dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_slp_logic_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        lp_dbias_vol: u32,
        hp_dbias_vol: u32,
        dbias_sel: u32,
        dbias_init: u32,
        slp_mem_xpd: u32,
        slp_logic_xpd: u32,
        xpd: u32,
        slp_mem_dbias: u32,
        slp_logic_dbias: u32,
        dbias: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 5u8, {
            let lp_dbias_vol: u32 = unsafe { ::core::mem::transmute(lp_dbias_vol) };
            lp_dbias_vol as u64
        });
        __bindgen_bitfield_unit.set(9usize, 5u8, {
            let hp_dbias_vol: u32 = unsafe { ::core::mem::transmute(hp_dbias_vol) };
            hp_dbias_vol as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let dbias_sel: u32 = unsafe { ::core::mem::transmute(dbias_sel) };
            dbias_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dbias_init: u32 = unsafe { ::core::mem::transmute(dbias_init) };
            dbias_init as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slp_mem_xpd: u32 = unsafe { ::core::mem::transmute(slp_mem_xpd) };
            slp_mem_xpd as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slp_logic_xpd: u32 = unsafe { ::core::mem::transmute(slp_logic_xpd) };
            slp_logic_xpd as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let xpd: u32 = unsafe { ::core::mem::transmute(xpd) };
            xpd as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let slp_mem_dbias: u32 = unsafe { ::core::mem::transmute(slp_mem_dbias) };
            slp_mem_dbias as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let slp_logic_dbias: u32 = unsafe { ::core::mem::transmute(slp_logic_dbias) };
            slp_logic_dbias as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let dbias: u32 = unsafe { ::core::mem::transmute(dbias) };
            dbias as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_regulator1_reg_t {
    pub __bindgen_anon_1: pmu_hp_regulator1_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_regulator1_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_regulator1_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn drv_b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_drv_b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, drv_b: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let drv_b: u32 = unsafe { ::core::mem::transmute(drv_b) };
            drv_b as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_xtal_reg_t {
    pub __bindgen_anon_1: pmu_hp_xtal_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_xtal_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_xtal_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, xpd_xtal: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_xtal: u32 = unsafe { ::core::mem::transmute(xpd_xtal) };
            xpd_xtal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_hw_regmap_t {
    pub dig_power: pmu_hp_dig_power_reg_t,
    pub icg_func: u32,
    pub icg_apb: u32,
    pub icg_modem: pmu_hp_icg_modem_reg_t,
    pub syscntl: pmu_hp_sys_cntl_reg_t,
    pub clk_power: pmu_hp_clk_power_reg_t,
    pub bias: pmu_hp_bias_reg_t,
    pub backup: pmu_hp_backup_reg_t,
    pub backup_clk: u32,
    pub sysclk: pmu_hp_sysclk_reg_t,
    pub regulator0: pmu_hp_regulator0_reg_t,
    pub regulator1: pmu_hp_regulator1_reg_t,
    pub xtal: pmu_hp_xtal_reg_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_regulator0_reg_t {
    pub __bindgen_anon_1: pmu_lp_regulator0_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_regulator0_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_regulator0_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_slp_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        slp_xpd: u32,
        xpd: u32,
        slp_dbias: u32,
        dbias: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 21u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let slp_xpd: u32 = unsafe { ::core::mem::transmute(slp_xpd) };
            slp_xpd as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let xpd: u32 = unsafe { ::core::mem::transmute(xpd) };
            xpd as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let slp_dbias: u32 = unsafe { ::core::mem::transmute(slp_dbias) };
            slp_dbias as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let dbias: u32 = unsafe { ::core::mem::transmute(dbias) };
            dbias as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_regulator1_reg_t {
    pub __bindgen_anon_1: pmu_lp_regulator1_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_regulator1_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_regulator1_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn drv_b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_drv_b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, drv_b: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let drv_b: u32 = unsafe { ::core::mem::transmute(drv_b) };
            drv_b as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_xtal_reg_t {
    pub __bindgen_anon_1: pmu_lp_xtal_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_xtal_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_xtal_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, xpd_xtal: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_xtal: u32 = unsafe { ::core::mem::transmute(xpd_xtal) };
            xpd_xtal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_dig_power_reg_t {
    pub __bindgen_anon_1: pmu_lp_dig_power_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_dig_power_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_dig_power_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_dslp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_dslp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn peri_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_peri_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        mem_dslp: u32,
        peri_pd_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let mem_dslp: u32 = unsafe { ::core::mem::transmute(mem_dslp) };
            mem_dslp as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let peri_pd_en: u32 = unsafe { ::core::mem::transmute(peri_pd_en) };
            peri_pd_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_clk_power_reg_t {
    pub __bindgen_anon_1: pmu_lp_clk_power_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_clk_power_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_clk_power_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_rc32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_rc32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_fosc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_fosc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_osc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_osc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        xpd_xtal32k: u32,
        xpd_rc32k: u32,
        xpd_fosc: u32,
        pd_osc: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let xpd_xtal32k: u32 = unsafe { ::core::mem::transmute(xpd_xtal32k) };
            xpd_xtal32k as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let xpd_rc32k: u32 = unsafe { ::core::mem::transmute(xpd_rc32k) };
            xpd_rc32k as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let xpd_fosc: u32 = unsafe { ::core::mem::transmute(xpd_fosc) };
            xpd_fosc as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pd_osc: u32 = unsafe { ::core::mem::transmute(pd_osc) };
            pd_osc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_bias_reg_t {
    pub __bindgen_anon_1: pmu_lp_bias_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_bias_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_bias_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbg_atten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dbg_atten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_cur(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_cur(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_sleep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_sleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        xpd_bias: u32,
        dbg_atten: u32,
        pd_cur: u32,
        bias_sleep: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let xpd_bias: u32 = unsafe { ::core::mem::transmute(xpd_bias) };
            xpd_bias as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let dbg_atten: u32 = unsafe { ::core::mem::transmute(dbg_atten) };
            dbg_atten as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let pd_cur: u32 = unsafe { ::core::mem::transmute(pd_cur) };
            pd_cur as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bias_sleep: u32 = unsafe { ::core::mem::transmute(bias_sleep) };
            bias_sleep as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_lp_hw_regmap_t {
    pub regulator0: pmu_lp_regulator0_reg_t,
    pub regulator1: pmu_lp_regulator1_reg_t,
    pub xtal: pmu_lp_xtal_reg_t,
    pub dig_power: pmu_lp_dig_power_reg_t,
    pub clk_power: pmu_lp_clk_power_reg_t,
    pub bias: pmu_lp_bias_reg_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_imm_hp_clk_power_reg_t {
    pub __bindgen_anon_1: pmu_imm_hp_clk_power_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_imm_hp_clk_power_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_imm_hp_clk_power_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn tie_low_global_bbpll_icg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_global_bbpll_icg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_global_xtal_icg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_global_xtal_icg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_i2c_retention(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_i2c_retention(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_xpd_bb_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_xpd_bb_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_xpd_bbpll_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_xpd_bbpll_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_xpd_bbpll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_xpd_bbpll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_xpd_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_xpd_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_global_bbpll_icg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_global_bbpll_icg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_global_xtal_icg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_global_xtal_icg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_i2c_retention(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_i2c_retention(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_xpd_bb_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_xpd_bb_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_xpd_bbpll_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_xpd_bbpll_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_xpd_bbpll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_xpd_bbpll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_xpd_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_xpd_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tie_low_global_bbpll_icg: u32,
        tie_low_global_xtal_icg: u32,
        tie_low_i2c_retention: u32,
        tie_low_xpd_bb_i2c: u32,
        tie_low_xpd_bbpll_i2c: u32,
        tie_low_xpd_bbpll: u32,
        tie_low_xpd_xtal: u32,
        reserved0: u32,
        tie_high_global_bbpll_icg: u32,
        tie_high_global_xtal_icg: u32,
        tie_high_i2c_retention: u32,
        tie_high_xpd_bb_i2c: u32,
        tie_high_xpd_bbpll_i2c: u32,
        tie_high_xpd_bbpll: u32,
        tie_high_xpd_xtal: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tie_low_global_bbpll_icg: u32 =
                unsafe { ::core::mem::transmute(tie_low_global_bbpll_icg) };
            tie_low_global_bbpll_icg as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tie_low_global_xtal_icg: u32 =
                unsafe { ::core::mem::transmute(tie_low_global_xtal_icg) };
            tie_low_global_xtal_icg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tie_low_i2c_retention: u32 =
                unsafe { ::core::mem::transmute(tie_low_i2c_retention) };
            tie_low_i2c_retention as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tie_low_xpd_bb_i2c: u32 = unsafe { ::core::mem::transmute(tie_low_xpd_bb_i2c) };
            tie_low_xpd_bb_i2c as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tie_low_xpd_bbpll_i2c: u32 =
                unsafe { ::core::mem::transmute(tie_low_xpd_bbpll_i2c) };
            tie_low_xpd_bbpll_i2c as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tie_low_xpd_bbpll: u32 = unsafe { ::core::mem::transmute(tie_low_xpd_bbpll) };
            tie_low_xpd_bbpll as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tie_low_xpd_xtal: u32 = unsafe { ::core::mem::transmute(tie_low_xpd_xtal) };
            tie_low_xpd_xtal as u64
        });
        __bindgen_bitfield_unit.set(7usize, 18u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let tie_high_global_bbpll_icg: u32 =
                unsafe { ::core::mem::transmute(tie_high_global_bbpll_icg) };
            tie_high_global_bbpll_icg as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let tie_high_global_xtal_icg: u32 =
                unsafe { ::core::mem::transmute(tie_high_global_xtal_icg) };
            tie_high_global_xtal_icg as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let tie_high_i2c_retention: u32 =
                unsafe { ::core::mem::transmute(tie_high_i2c_retention) };
            tie_high_i2c_retention as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let tie_high_xpd_bb_i2c: u32 = unsafe { ::core::mem::transmute(tie_high_xpd_bb_i2c) };
            tie_high_xpd_bb_i2c as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let tie_high_xpd_bbpll_i2c: u32 =
                unsafe { ::core::mem::transmute(tie_high_xpd_bbpll_i2c) };
            tie_high_xpd_bbpll_i2c as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let tie_high_xpd_bbpll: u32 = unsafe { ::core::mem::transmute(tie_high_xpd_bbpll) };
            tie_high_xpd_bbpll as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let tie_high_xpd_xtal: u32 = unsafe { ::core::mem::transmute(tie_high_xpd_xtal) };
            tie_high_xpd_xtal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_imm_sleep_sysclk_reg_t {
    pub __bindgen_anon_1: pmu_imm_sleep_sysclk_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_imm_sleep_sysclk_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_imm_sleep_sysclk_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn update_dig_icg_switch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dig_icg_switch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_icg_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_icg_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_icg_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_icg_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_dig_sysclk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dig_sysclk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        update_dig_icg_switch: u32,
        tie_low_icg_slp_sel: u32,
        tie_high_icg_slp_sel: u32,
        update_dig_sysclk_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let update_dig_icg_switch: u32 =
                unsafe { ::core::mem::transmute(update_dig_icg_switch) };
            update_dig_icg_switch as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let tie_low_icg_slp_sel: u32 = unsafe { ::core::mem::transmute(tie_low_icg_slp_sel) };
            tie_low_icg_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let tie_high_icg_slp_sel: u32 = unsafe { ::core::mem::transmute(tie_high_icg_slp_sel) };
            tie_high_icg_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let update_dig_sysclk_sel: u32 =
                unsafe { ::core::mem::transmute(update_dig_sysclk_sel) };
            update_dig_sysclk_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_imm_hp_func_icg_reg_t {
    pub __bindgen_anon_1: pmu_imm_hp_func_icg_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_imm_hp_func_icg_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_imm_hp_func_icg_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn update_dig_icg_func_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dig_icg_func_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        update_dig_icg_func_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let update_dig_icg_func_en: u32 =
                unsafe { ::core::mem::transmute(update_dig_icg_func_en) };
            update_dig_icg_func_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_imm_hp_apb_icg_reg_t {
    pub __bindgen_anon_1: pmu_imm_hp_apb_icg_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_imm_hp_apb_icg_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_imm_hp_apb_icg_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn update_dig_icg_apb_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dig_icg_apb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        update_dig_icg_apb_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let update_dig_icg_apb_en: u32 =
                unsafe { ::core::mem::transmute(update_dig_icg_apb_en) };
            update_dig_icg_apb_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_imm_modem_icg_reg_t {
    pub __bindgen_anon_1: pmu_imm_modem_icg_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_imm_modem_icg_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_imm_modem_icg_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn update_dig_icg_modem_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dig_icg_modem_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        update_dig_icg_modem_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let update_dig_icg_modem_en: u32 =
                unsafe { ::core::mem::transmute(update_dig_icg_modem_en) };
            update_dig_icg_modem_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_imm_lp_icg_reg_t {
    pub __bindgen_anon_1: pmu_imm_lp_icg_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_imm_lp_icg_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_imm_lp_icg_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_lp_rootclk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_lp_rootclk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_lp_rootclk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_lp_rootclk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        tie_low_lp_rootclk_sel: u32,
        tie_high_lp_rootclk_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let tie_low_lp_rootclk_sel: u32 =
                unsafe { ::core::mem::transmute(tie_low_lp_rootclk_sel) };
            tie_low_lp_rootclk_sel as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let tie_high_lp_rootclk_sel: u32 =
                unsafe { ::core::mem::transmute(tie_high_lp_rootclk_sel) };
            tie_high_lp_rootclk_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_imm_pad_hold_all_reg_t {
    pub __bindgen_anon_1: pmu_imm_pad_hold_all_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_imm_pad_hold_all_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_imm_pad_hold_all_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_lp_pad_hold_all(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_lp_pad_hold_all(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_lp_pad_hold_all(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_lp_pad_hold_all(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_hp_pad_hold_all(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_hp_pad_hold_all(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_hp_pad_hold_all(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_hp_pad_hold_all(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        tie_high_lp_pad_hold_all: u32,
        tie_low_lp_pad_hold_all: u32,
        tie_high_hp_pad_hold_all: u32,
        tie_low_hp_pad_hold_all: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let tie_high_lp_pad_hold_all: u32 =
                unsafe { ::core::mem::transmute(tie_high_lp_pad_hold_all) };
            tie_high_lp_pad_hold_all as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let tie_low_lp_pad_hold_all: u32 =
                unsafe { ::core::mem::transmute(tie_low_lp_pad_hold_all) };
            tie_low_lp_pad_hold_all as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let tie_high_hp_pad_hold_all: u32 =
                unsafe { ::core::mem::transmute(tie_high_hp_pad_hold_all) };
            tie_high_hp_pad_hold_all as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let tie_low_hp_pad_hold_all: u32 =
                unsafe { ::core::mem::transmute(tie_low_hp_pad_hold_all) };
            tie_low_hp_pad_hold_all as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_imm_i2c_isolate_reg_t {
    pub __bindgen_anon_1: pmu_imm_i2c_isolate_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_imm_i2c_isolate_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_imm_i2c_isolate_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_high_i2c_iso_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_high_i2c_iso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_low_i2c_iso_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_low_i2c_iso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        tie_high_i2c_iso_en: u32,
        tie_low_i2c_iso_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let tie_high_i2c_iso_en: u32 = unsafe { ::core::mem::transmute(tie_high_i2c_iso_en) };
            tie_high_i2c_iso_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let tie_low_i2c_iso_en: u32 = unsafe { ::core::mem::transmute(tie_low_i2c_iso_en) };
            tie_low_i2c_iso_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_imm_hw_regmap_t {
    pub clk_power: pmu_imm_hp_clk_power_reg_t,
    pub sleep_sysclk: pmu_imm_sleep_sysclk_reg_t,
    pub hp_func_icg: pmu_imm_hp_func_icg_reg_t,
    pub hp_apb_icg: pmu_imm_hp_apb_icg_reg_t,
    pub modem_icg: pmu_imm_modem_icg_reg_t,
    pub lp_icg: pmu_imm_lp_icg_reg_t,
    pub pad_hold_all: pmu_imm_pad_hold_all_reg_t,
    pub i2c_iso: pmu_imm_i2c_isolate_reg_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_power_wait_timer0_reg_t {
    pub __bindgen_anon_1: pmu_power_wait_timer0_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_power_wait_timer0_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_power_wait_timer0_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn powerdown_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_powerdown_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        powerdown_timer: u32,
        powerup_timer: u32,
        wait_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 9u8, {
            let powerdown_timer: u32 = unsafe { ::core::mem::transmute(powerdown_timer) };
            powerdown_timer as u64
        });
        __bindgen_bitfield_unit.set(14usize, 9u8, {
            let powerup_timer: u32 = unsafe { ::core::mem::transmute(powerup_timer) };
            powerup_timer as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let wait_timer: u32 = unsafe { ::core::mem::transmute(wait_timer) };
            wait_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_power_wait_timer1_reg_t {
    pub __bindgen_anon_1: pmu_power_wait_timer1_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_power_wait_timer1_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_power_wait_timer1_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn powerdown_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_powerdown_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        powerdown_timer: u32,
        powerup_timer: u32,
        wait_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let powerdown_timer: u32 = unsafe { ::core::mem::transmute(powerdown_timer) };
            powerdown_timer as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let powerup_timer: u32 = unsafe { ::core::mem::transmute(powerup_timer) };
            powerup_timer as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let wait_timer: u32 = unsafe { ::core::mem::transmute(wait_timer) };
            wait_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_power_domain_cntl_reg_t {
    pub __bindgen_anon_1: pmu_power_domain_cntl_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_power_domain_cntl_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_power_domain_cntl_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn force_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_no_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_no_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_no_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_no_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_pd_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_reset: u32,
        force_iso: u32,
        force_pu: u32,
        force_no_reset: u32,
        force_no_iso: u32,
        force_pd: u32,
        mask: u32,
        reserved0: u32,
        pd_mask: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_reset: u32 = unsafe { ::core::mem::transmute(force_reset) };
            force_reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let force_iso: u32 = unsafe { ::core::mem::transmute(force_iso) };
            force_iso as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let force_pu: u32 = unsafe { ::core::mem::transmute(force_pu) };
            force_pu as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let force_no_reset: u32 = unsafe { ::core::mem::transmute(force_no_reset) };
            force_no_reset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let force_no_iso: u32 = unsafe { ::core::mem::transmute(force_no_iso) };
            force_no_iso as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let force_pd: u32 = unsafe { ::core::mem::transmute(force_pd) };
            force_pd as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let mask: u32 = unsafe { ::core::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(11usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let pd_mask: u32 = unsafe { ::core::mem::transmute(pd_mask) };
            pd_mask as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_power_memory_cntl_reg_t {
    pub __bindgen_anon_1: pmu_power_memory_cntl_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_power_memory_cntl_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_power_memory_cntl_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn force_hp_mem_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_force_hp_mem_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn force_hp_mem_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_force_hp_mem_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn force_hp_mem_no_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_force_hp_mem_no_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn force_hp_mem_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_force_hp_mem_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_hp_mem_iso: u32,
        force_hp_mem_pd: u32,
        reserved0: u32,
        force_hp_mem_no_iso: u32,
        force_hp_mem_pu: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let force_hp_mem_iso: u32 = unsafe { ::core::mem::transmute(force_hp_mem_iso) };
            force_hp_mem_iso as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let force_hp_mem_pd: u32 = unsafe { ::core::mem::transmute(force_hp_mem_pd) };
            force_hp_mem_pd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let force_hp_mem_no_iso: u32 = unsafe { ::core::mem::transmute(force_hp_mem_no_iso) };
            force_hp_mem_no_iso as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let force_hp_mem_pu: u32 = unsafe { ::core::mem::transmute(force_hp_mem_pu) };
            force_hp_mem_pu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_power_memory_mask_reg_t {
    pub __bindgen_anon_1: pmu_power_memory_mask_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_power_memory_mask_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_power_memory_mask_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn mem2_pd_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mem2_pd_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem1_pd_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mem1_pd_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem0_pd_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mem0_pd_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mem2_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mem2_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem1_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mem1_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem0_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mem0_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mem2_pd_mask: u32,
        mem1_pd_mask: u32,
        mem0_pd_mask: u32,
        reserved0: u32,
        mem2_mask: u32,
        mem1_mask: u32,
        mem0_mask: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mem2_pd_mask: u32 = unsafe { ::core::mem::transmute(mem2_pd_mask) };
            mem2_pd_mask as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let mem1_pd_mask: u32 = unsafe { ::core::mem::transmute(mem1_pd_mask) };
            mem1_pd_mask as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let mem0_pd_mask: u32 = unsafe { ::core::mem::transmute(mem0_pd_mask) };
            mem0_pd_mask as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let mem2_mask: u32 = unsafe { ::core::mem::transmute(mem2_mask) };
            mem2_mask as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let mem1_mask: u32 = unsafe { ::core::mem::transmute(mem1_mask) };
            mem1_mask as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let mem0_mask: u32 = unsafe { ::core::mem::transmute(mem0_mask) };
            mem0_mask as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_power_hp_pad_reg_t {
    pub __bindgen_anon_1: pmu_power_hp_pad_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_power_hp_pad_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_power_hp_pad_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn force_hp_pad_no_iso_all(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_hp_pad_no_iso_all(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_hp_pad_iso_all(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_hp_pad_iso_all(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_hp_pad_no_iso_all: u32,
        force_hp_pad_iso_all: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_hp_pad_no_iso_all: u32 =
                unsafe { ::core::mem::transmute(force_hp_pad_no_iso_all) };
            force_hp_pad_no_iso_all as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let force_hp_pad_iso_all: u32 = unsafe { ::core::mem::transmute(force_hp_pad_iso_all) };
            force_hp_pad_iso_all as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_power_vdd_spi_cntl_reg_t {
    pub __bindgen_anon_1: pmu_power_vdd_spi_cntl_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_power_vdd_spi_cntl_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_power_vdd_spi_cntl_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn pwr_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_pwr_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn pwr_sw(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pwr_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pwr_sel_sw(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pwr_sel_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pwr_wait: u32,
        pwr_sw: u32,
        pwr_sel_sw: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 11u8, {
            let pwr_wait: u32 = unsafe { ::core::mem::transmute(pwr_wait) };
            pwr_wait as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let pwr_sw: u32 = unsafe { ::core::mem::transmute(pwr_sw) };
            pwr_sw as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pwr_sel_sw: u32 = unsafe { ::core::mem::transmute(pwr_sel_sw) };
            pwr_sel_sw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_power_clk_wait_cntl_reg_t {
    pub __bindgen_anon_1: pmu_power_clk_wait_cntl_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_power_clk_wait_cntl_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_power_clk_wait_cntl_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn wait_xtal_stable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_wait_xtal_stable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_pll_stable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_wait_pll_stable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wait_xtal_stable: u32,
        wait_pll_stable: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let wait_xtal_stable: u32 = unsafe { ::core::mem::transmute(wait_xtal_stable) };
            wait_xtal_stable as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let wait_pll_stable: u32 = unsafe { ::core::mem::transmute(wait_pll_stable) };
            wait_pll_stable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_power_hw_regmap_t {
    pub wait_timer0: pmu_power_wait_timer0_reg_t,
    pub wait_timer1: pmu_power_wait_timer1_reg_t,
    pub hp_pd: [pmu_power_domain_cntl_reg_t; 5usize],
    pub lp_peri: pmu_power_domain_cntl_reg_t,
    pub mem_cntl: pmu_power_memory_cntl_reg_t,
    pub mem_mask: pmu_power_memory_mask_reg_t,
    pub hp_pad: pmu_power_hp_pad_reg_t,
    pub vdd_spi: pmu_power_vdd_spi_cntl_reg_t,
    pub clk_wait: pmu_power_clk_wait_cntl_reg_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_slp_wakeup_cntl0_reg_t {
    pub __bindgen_anon_1: pmu_slp_wakeup_cntl0_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_slp_wakeup_cntl0_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_slp_wakeup_cntl0_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_req(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_req(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, sleep_req: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sleep_req: u32 = unsafe { ::core::mem::transmute(sleep_req) };
            sleep_req as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_slp_wakeup_cntl1_reg_t {
    pub __bindgen_anon_1: pmu_slp_wakeup_cntl1_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_slp_wakeup_cntl1_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_slp_wakeup_cntl1_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn sleep_reject_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_reject_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sleep_reject_ena: u32,
        slp_reject_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let sleep_reject_ena: u32 = unsafe { ::core::mem::transmute(sleep_reject_ena) };
            sleep_reject_ena as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let slp_reject_en: u32 = unsafe { ::core::mem::transmute(slp_reject_en) };
            slp_reject_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_slp_wakeup_cntl3_reg_t {
    pub __bindgen_anon_1: pmu_slp_wakeup_cntl3_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_slp_wakeup_cntl3_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_slp_wakeup_cntl3_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn lp_min_slp_val(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lp_min_slp_val(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_min_slp_val(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_hp_min_slp_val(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_prt_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_prt_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lp_min_slp_val: u32,
        hp_min_slp_val: u32,
        sleep_prt_sel: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let lp_min_slp_val: u32 = unsafe { ::core::mem::transmute(lp_min_slp_val) };
            lp_min_slp_val as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let hp_min_slp_val: u32 = unsafe { ::core::mem::transmute(hp_min_slp_val) };
            hp_min_slp_val as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let sleep_prt_sel: u32 = unsafe { ::core::mem::transmute(sleep_prt_sel) };
            sleep_prt_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_slp_wakeup_cntl4_reg_t {
    pub __bindgen_anon_1: pmu_slp_wakeup_cntl4_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_slp_wakeup_cntl4_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_slp_wakeup_cntl4_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject_cause_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject_cause_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        slp_reject_cause_clr: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let slp_reject_cause_clr: u32 = unsafe { ::core::mem::transmute(slp_reject_cause_clr) };
            slp_reject_cause_clr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_slp_wakeup_cntl5_reg_t {
    pub __bindgen_anon_1: pmu_slp_wakeup_cntl5_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_slp_wakeup_cntl5_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_slp_wakeup_cntl5_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn modem_wait_target(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_modem_wait_target(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_ana_wait_target(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lp_ana_wait_target(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        modem_wait_target: u32,
        reserved0: u32,
        lp_ana_wait_target: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let modem_wait_target: u32 = unsafe { ::core::mem::transmute(modem_wait_target) };
            modem_wait_target as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let lp_ana_wait_target: u32 = unsafe { ::core::mem::transmute(lp_ana_wait_target) };
            lp_ana_wait_target as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_slp_wakeup_cntl6_reg_t {
    pub __bindgen_anon_1: pmu_slp_wakeup_cntl6_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_slp_wakeup_cntl6_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_slp_wakeup_cntl6_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn soc_wakeup_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_soc_wakeup_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn soc_wakeup_wait_cfg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_soc_wakeup_wait_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        soc_wakeup_wait: u32,
        reserved0: u32,
        soc_wakeup_wait_cfg: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let soc_wakeup_wait: u32 = unsafe { ::core::mem::transmute(soc_wakeup_wait) };
            soc_wakeup_wait as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let soc_wakeup_wait_cfg: u32 = unsafe { ::core::mem::transmute(soc_wakeup_wait_cfg) };
            soc_wakeup_wait_cfg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_slp_wakeup_cntl7_reg_t {
    pub __bindgen_anon_1: pmu_slp_wakeup_cntl7_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_slp_wakeup_cntl7_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_slp_wakeup_cntl7_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_wait_target(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ana_wait_target(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ana_wait_target: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let ana_wait_target: u32 = unsafe { ::core::mem::transmute(ana_wait_target) };
            ana_wait_target as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_wakeup_hw_regmap_t {
    pub cntl0: pmu_slp_wakeup_cntl0_reg_t,
    pub cntl1: pmu_slp_wakeup_cntl1_reg_t,
    pub cntl2: u32,
    pub cntl3: pmu_slp_wakeup_cntl3_reg_t,
    pub cntl4: pmu_slp_wakeup_cntl4_reg_t,
    pub cntl5: pmu_slp_wakeup_cntl5_reg_t,
    pub cntl6: pmu_slp_wakeup_cntl6_reg_t,
    pub cntl7: pmu_slp_wakeup_cntl7_reg_t,
    pub status0: u32,
    pub status1: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_clk_poweron_reg_t {
    pub __bindgen_anon_1: pmu_hp_clk_poweron_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_clk_poweron_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_clk_poweron_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn i2c_por_wait_target(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_por_wait_target(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        i2c_por_wait_target: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let i2c_por_wait_target: u32 = unsafe { ::core::mem::transmute(i2c_por_wait_target) };
            i2c_por_wait_target as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_clk_cntl_reg_t {
    pub __bindgen_anon_1: pmu_hp_clk_cntl_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_clk_cntl_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_clk_cntl_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn modify_icg_cntl_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_modify_icg_cntl_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn switch_icg_cntl_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_switch_icg_cntl_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        modify_icg_cntl_wait: u32,
        switch_icg_cntl_wait: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let modify_icg_cntl_wait: u32 = unsafe { ::core::mem::transmute(modify_icg_cntl_wait) };
            modify_icg_cntl_wait as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let switch_icg_cntl_wait: u32 = unsafe { ::core::mem::transmute(switch_icg_cntl_wait) };
            switch_icg_cntl_wait as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_por_status_reg_t {
    pub __bindgen_anon_1: pmu_por_status_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_por_status_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_por_status_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn por_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_por_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, por_done: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let por_done: u32 = unsafe { ::core::mem::transmute(por_done) };
            por_done as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_rf_pwc_reg_t {
    pub __bindgen_anon_1: pmu_rf_pwc_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_rf_pwc_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_rf_pwc_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn perif_i2c_rstb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_perif_i2c_rstb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_perif_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_perif_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_txrf_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_txrf_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_rfrx_pbus(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_rfrx_pbus(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_ckgen_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_ckgen_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_pll_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_pll_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        perif_i2c_rstb: u32,
        xpd_perif_i2c: u32,
        xpd_txrf_i2c: u32,
        xpd_rfrx_pbus: u32,
        xpd_ckgen_i2c: u32,
        xpd_pll_i2c: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let perif_i2c_rstb: u32 = unsafe { ::core::mem::transmute(perif_i2c_rstb) };
            perif_i2c_rstb as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let xpd_perif_i2c: u32 = unsafe { ::core::mem::transmute(xpd_perif_i2c) };
            xpd_perif_i2c as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let xpd_txrf_i2c: u32 = unsafe { ::core::mem::transmute(xpd_txrf_i2c) };
            xpd_txrf_i2c as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let xpd_rfrx_pbus: u32 = unsafe { ::core::mem::transmute(xpd_rfrx_pbus) };
            xpd_rfrx_pbus as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let xpd_ckgen_i2c: u32 = unsafe { ::core::mem::transmute(xpd_ckgen_i2c) };
            xpd_ckgen_i2c as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_pll_i2c: u32 = unsafe { ::core::mem::transmute(xpd_pll_i2c) };
            xpd_pll_i2c as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_backup_cfg_reg_t {
    pub __bindgen_anon_1: pmu_backup_cfg_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_backup_cfg_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_backup_cfg_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn backup_sysclk_nodiv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_backup_sysclk_nodiv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        backup_sysclk_nodiv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let backup_sysclk_nodiv: u32 = unsafe { ::core::mem::transmute(backup_sysclk_nodiv) };
            backup_sysclk_nodiv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_intr_reg_t {
    pub __bindgen_anon_1: pmu_hp_intr_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_intr_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_intr_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_cpu_exc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lp_cpu_exc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        lp_cpu_exc: u32,
        sdio_idle: u32,
        sw: u32,
        reject: u32,
        wakeup: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let lp_cpu_exc: u32 = unsafe { ::core::mem::transmute(lp_cpu_exc) };
            lp_cpu_exc as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sw: u32 = unsafe { ::core::mem::transmute(sw) };
            sw as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let reject: u32 = unsafe { ::core::mem::transmute(reject) };
            reject as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let wakeup: u32 = unsafe { ::core::mem::transmute(wakeup) };
            wakeup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_ext_hw_regmap_t {
    pub clk_poweron: pmu_hp_clk_poweron_reg_t,
    pub clk_cntl: pmu_hp_clk_cntl_reg_t,
    pub por_status: pmu_por_status_reg_t,
    pub rf_pwc: pmu_rf_pwc_reg_t,
    pub backup_cfg: pmu_backup_cfg_reg_t,
    pub int_raw: pmu_hp_intr_reg_t,
    pub int_st: pmu_hp_intr_reg_t,
    pub int_ena: pmu_hp_intr_reg_t,
    pub int_clr: pmu_hp_intr_reg_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_intr_reg_t {
    pub __bindgen_anon_1: pmu_lp_intr_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_intr_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_intr_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_cpu_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lp_cpu_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_switch_active_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modem_switch_active_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_switch_active_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_switch_active_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_switch_modem_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_switch_modem_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_switch_sleep_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modem_switch_sleep_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active_swtich_sleep_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_swtich_sleep_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_switch_active_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modem_switch_active_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_switch_active_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_switch_active_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_switch_modem_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_switch_modem_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_switch_sleep_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modem_switch_sleep_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active_switch_sleep_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_switch_sleep_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_trigger(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_trigger(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        lp_cpu_wakeup: u32,
        modem_switch_active_end: u32,
        sleep_switch_active_end: u32,
        sleep_switch_modem_end: u32,
        modem_switch_sleep_end: u32,
        active_swtich_sleep_end: u32,
        modem_switch_active_start: u32,
        sleep_switch_active_start: u32,
        sleep_switch_modem_start: u32,
        modem_switch_sleep_start: u32,
        active_switch_sleep_start: u32,
        sw_trigger: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let lp_cpu_wakeup: u32 = unsafe { ::core::mem::transmute(lp_cpu_wakeup) };
            lp_cpu_wakeup as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let modem_switch_active_end: u32 =
                unsafe { ::core::mem::transmute(modem_switch_active_end) };
            modem_switch_active_end as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let sleep_switch_active_end: u32 =
                unsafe { ::core::mem::transmute(sleep_switch_active_end) };
            sleep_switch_active_end as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let sleep_switch_modem_end: u32 =
                unsafe { ::core::mem::transmute(sleep_switch_modem_end) };
            sleep_switch_modem_end as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let modem_switch_sleep_end: u32 =
                unsafe { ::core::mem::transmute(modem_switch_sleep_end) };
            modem_switch_sleep_end as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let active_swtich_sleep_end: u32 =
                unsafe { ::core::mem::transmute(active_swtich_sleep_end) };
            active_swtich_sleep_end as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let modem_switch_active_start: u32 =
                unsafe { ::core::mem::transmute(modem_switch_active_start) };
            modem_switch_active_start as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let sleep_switch_active_start: u32 =
                unsafe { ::core::mem::transmute(sleep_switch_active_start) };
            sleep_switch_active_start as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sleep_switch_modem_start: u32 =
                unsafe { ::core::mem::transmute(sleep_switch_modem_start) };
            sleep_switch_modem_start as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let modem_switch_sleep_start: u32 =
                unsafe { ::core::mem::transmute(modem_switch_sleep_start) };
            modem_switch_sleep_start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let active_switch_sleep_start: u32 =
                unsafe { ::core::mem::transmute(active_switch_sleep_start) };
            active_switch_sleep_start as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sw_trigger: u32 = unsafe { ::core::mem::transmute(sw_trigger) };
            sw_trigger as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_cpu_pwr0_reg_t {
    pub __bindgen_anon_1: pmu_lp_cpu_pwr0_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_cpu_pwr0_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_cpu_pwr0_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn waiti_rdy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waiti_rdy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stall_rdy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stall_rdy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn force_stall(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_stall(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_waiti_flag_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_waiti_flag_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_stall_flag_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_stall_flag_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_stall_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_slp_stall_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_stall_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_stall_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reset_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reset_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_bypass_intr_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_bypass_intr_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        waiti_rdy: u32,
        stall_rdy: u32,
        reserved0: u32,
        force_stall: u32,
        slp_waiti_flag_en: u32,
        slp_stall_flag_en: u32,
        slp_stall_wait: u32,
        slp_stall_en: u32,
        slp_reset_en: u32,
        slp_bypass_intr_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let waiti_rdy: u32 = unsafe { ::core::mem::transmute(waiti_rdy) };
            waiti_rdy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let stall_rdy: u32 = unsafe { ::core::mem::transmute(stall_rdy) };
            stall_rdy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let force_stall: u32 = unsafe { ::core::mem::transmute(force_stall) };
            force_stall as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let slp_waiti_flag_en: u32 = unsafe { ::core::mem::transmute(slp_waiti_flag_en) };
            slp_waiti_flag_en as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let slp_stall_flag_en: u32 = unsafe { ::core::mem::transmute(slp_stall_flag_en) };
            slp_stall_flag_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 8u8, {
            let slp_stall_wait: u32 = unsafe { ::core::mem::transmute(slp_stall_wait) };
            slp_stall_wait as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let slp_stall_en: u32 = unsafe { ::core::mem::transmute(slp_stall_en) };
            slp_stall_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let slp_reset_en: u32 = unsafe { ::core::mem::transmute(slp_reset_en) };
            slp_reset_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let slp_bypass_intr_en: u32 = unsafe { ::core::mem::transmute(slp_bypass_intr_en) };
            slp_bypass_intr_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_cpu_pwr1_reg_t {
    pub __bindgen_anon_1: pmu_lp_cpu_pwr1_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_cpu_pwr1_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_cpu_pwr1_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn wakeup_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_req(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_req(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wakeup_en: u32,
        reserved0: u32,
        sleep_req: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let wakeup_en: u32 = unsafe { ::core::mem::transmute(wakeup_en) };
            wakeup_en as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sleep_req: u32 = unsafe { ::core::mem::transmute(sleep_req) };
            sleep_req as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_lp_ext_hw_regmap_t {
    pub int_raw: pmu_lp_intr_reg_t,
    pub int_st: pmu_lp_intr_reg_t,
    pub int_ena: pmu_lp_intr_reg_t,
    pub int_clr: pmu_lp_intr_reg_t,
    pub pwr0: pmu_lp_cpu_pwr0_reg_t,
    pub pwr1: pmu_lp_cpu_pwr1_reg_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_dev_t {
    pub hp_sys: [pmu_hp_hw_regmap_t; 3usize],
    pub lp_sys: [pmu_lp_hw_regmap_t; 2usize],
    pub imm: pmu_imm_hw_regmap_t,
    pub power: pmu_power_hw_regmap_t,
    pub wakeup: pmu_wakeup_hw_regmap_t,
    pub hp_ext: pmu_hp_ext_hw_regmap_t,
    pub lp_ext: pmu_lp_ext_hw_regmap_t,
    pub hp_lp_cpu_comm: pmu_dev_t__bindgen_ty_1,
    pub hp_regulator_cfg: pmu_dev_t__bindgen_ty_2,
    pub main_state: pmu_dev_t__bindgen_ty_3,
    pub pwr_state: pmu_dev_t__bindgen_ty_4,
    pub clk_state0: pmu_dev_t__bindgen_ty_5,
    pub clk_state1: u32,
    pub clk_state2: u32,
    pub vdd_spi_status: pmu_dev_t__bindgen_ty_6,
    pub reserved: [u32; 150usize],
    pub date: pmu_dev_t__bindgen_ty_7,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_dev_t__bindgen_ty_1 {
    pub __bindgen_anon_1: pmu_dev_t__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_dev_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_dev_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_trigger_hp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lp_trigger_hp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_trigger_lp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hp_trigger_lp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        lp_trigger_hp: u32,
        hp_trigger_lp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lp_trigger_hp: u32 = unsafe { ::core::mem::transmute(lp_trigger_hp) };
            lp_trigger_hp as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let hp_trigger_lp: u32 = unsafe { ::core::mem::transmute(hp_trigger_lp) };
            hp_trigger_lp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_dev_t__bindgen_ty_2 {
    pub __bindgen_anon_1: pmu_dev_t__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_dev_t__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_dev_t__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_regulator_en_cal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_regulator_en_cal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dig_regulator_en_cal: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dig_regulator_en_cal: u32 = unsafe { ::core::mem::transmute(dig_regulator_en_cal) };
            dig_regulator_en_cal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_dev_t__bindgen_ty_3 {
    pub __bindgen_anon_1: pmu_dev_t__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_dev_t__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_dev_t__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn last_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_last_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn target_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_target_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn current_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_current_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        last_st: u32,
        target_st: u32,
        current_st: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 7u8, {
            let last_st: u32 = unsafe { ::core::mem::transmute(last_st) };
            last_st as u64
        });
        __bindgen_bitfield_unit.set(18usize, 7u8, {
            let target_st: u32 = unsafe { ::core::mem::transmute(target_st) };
            target_st as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let current_st: u32 = unsafe { ::core::mem::transmute(current_st) };
            current_st as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_dev_t__bindgen_ty_4 {
    pub __bindgen_anon_1: pmu_dev_t__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_dev_t__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_dev_t__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn backup_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_backup_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_pwr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_lp_pwr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_pwr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_hp_pwr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        backup_st: u32,
        lp_pwr_st: u32,
        hp_pwr_st: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 13u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let backup_st: u32 = unsafe { ::core::mem::transmute(backup_st) };
            backup_st as u64
        });
        __bindgen_bitfield_unit.set(18usize, 5u8, {
            let lp_pwr_st: u32 = unsafe { ::core::mem::transmute(lp_pwr_st) };
            lp_pwr_st as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let hp_pwr_st: u32 = unsafe { ::core::mem::transmute(hp_pwr_st) };
            hp_pwr_st as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_dev_t__bindgen_ty_5 {
    pub __bindgen_anon_1: pmu_dev_t__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_dev_t__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_dev_t__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn stable_xpd_bbpll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stable_xpd_bbpll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stable_xpd_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stable_xpd_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn sysclk_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sysclk_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sysclk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sysclk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sysclk_nodiv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sysclk_nodiv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icg_sysclk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icg_sysclk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icg_modem_switch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icg_modem_switch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icg_modem_code(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_icg_modem_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn icg_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icg_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icg_global_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icg_global_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icg_global_pll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icg_global_pll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_i2c_iso_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ana_i2c_iso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_i2c_retention(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ana_i2c_retention(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_xpd_bb_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ana_xpd_bb_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_xpd_bbpll_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ana_xpd_bbpll_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_xpd_bbpll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ana_xpd_bbpll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_xpd_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ana_xpd_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        stable_xpd_bbpll: u32,
        stable_xpd_xtal: u32,
        reserved0: u32,
        sysclk_slp_sel: u32,
        sysclk_sel: u32,
        sysclk_nodiv: u32,
        icg_sysclk_en: u32,
        icg_modem_switch: u32,
        icg_modem_code: u32,
        icg_slp_sel: u32,
        icg_global_xtal: u32,
        icg_global_pll: u32,
        ana_i2c_iso_en: u32,
        ana_i2c_retention: u32,
        ana_xpd_bb_i2c: u32,
        ana_xpd_bbpll_i2c: u32,
        ana_xpd_bbpll: u32,
        ana_xpd_xtal: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let stable_xpd_bbpll: u32 = unsafe { ::core::mem::transmute(stable_xpd_bbpll) };
            stable_xpd_bbpll as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let stable_xpd_xtal: u32 = unsafe { ::core::mem::transmute(stable_xpd_xtal) };
            stable_xpd_xtal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 13u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sysclk_slp_sel: u32 = unsafe { ::core::mem::transmute(sysclk_slp_sel) };
            sysclk_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let sysclk_sel: u32 = unsafe { ::core::mem::transmute(sysclk_sel) };
            sysclk_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sysclk_nodiv: u32 = unsafe { ::core::mem::transmute(sysclk_nodiv) };
            sysclk_nodiv as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let icg_sysclk_en: u32 = unsafe { ::core::mem::transmute(icg_sysclk_en) };
            icg_sysclk_en as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let icg_modem_switch: u32 = unsafe { ::core::mem::transmute(icg_modem_switch) };
            icg_modem_switch as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let icg_modem_code: u32 = unsafe { ::core::mem::transmute(icg_modem_code) };
            icg_modem_code as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let icg_slp_sel: u32 = unsafe { ::core::mem::transmute(icg_slp_sel) };
            icg_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let icg_global_xtal: u32 = unsafe { ::core::mem::transmute(icg_global_xtal) };
            icg_global_xtal as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let icg_global_pll: u32 = unsafe { ::core::mem::transmute(icg_global_pll) };
            icg_global_pll as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ana_i2c_iso_en: u32 = unsafe { ::core::mem::transmute(ana_i2c_iso_en) };
            ana_i2c_iso_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let ana_i2c_retention: u32 = unsafe { ::core::mem::transmute(ana_i2c_retention) };
            ana_i2c_retention as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ana_xpd_bb_i2c: u32 = unsafe { ::core::mem::transmute(ana_xpd_bb_i2c) };
            ana_xpd_bb_i2c as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ana_xpd_bbpll_i2c: u32 = unsafe { ::core::mem::transmute(ana_xpd_bbpll_i2c) };
            ana_xpd_bbpll_i2c as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ana_xpd_bbpll: u32 = unsafe { ::core::mem::transmute(ana_xpd_bbpll) };
            ana_xpd_bbpll as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ana_xpd_xtal: u32 = unsafe { ::core::mem::transmute(ana_xpd_xtal) };
            ana_xpd_xtal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_dev_t__bindgen_ty_6 {
    pub __bindgen_anon_1: pmu_dev_t__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_dev_t__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_dev_t__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn stable_vdd_spi_pwr_drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stable_vdd_spi_pwr_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        stable_vdd_spi_pwr_drv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let stable_vdd_spi_pwr_drv: u32 =
                unsafe { ::core::mem::transmute(stable_vdd_spi_pwr_drv) };
            stable_vdd_spi_pwr_drv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_dev_t__bindgen_ty_7 {
    pub __bindgen_anon_1: pmu_dev_t__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_dev_t__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_dev_t__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn pmu_date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_pmu_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(pmu_date: u32, clk_en: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let pmu_date: u32 = unsafe { ::core::mem::transmute(pmu_date) };
            pmu_date as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut PMU: pmu_dev_t;
}
#[doc = "< PMU in HP_ACTIVE mode"]
pub const pmu_hp_mode_t_PMU_MODE_HP_ACTIVE: pmu_hp_mode_t = 0;
#[doc = "< PMU in HP_MODEM mode"]
pub const pmu_hp_mode_t_PMU_MODE_HP_MODEM: pmu_hp_mode_t = 1;
#[doc = "< PMU in HP_SLEEP mode"]
pub const pmu_hp_mode_t_PMU_MODE_HP_SLEEP: pmu_hp_mode_t = 2;
pub const pmu_hp_mode_t_PMU_MODE_HP_MAX: pmu_hp_mode_t = 3;
#[doc = " @brief PMU modes of HP system"]
pub type pmu_hp_mode_t = crate::c_types::c_uint;
#[doc = "< PMU in LP_ACTIVE mode"]
pub const pmu_lp_mode_t_PMU_MODE_LP_ACTIVE: pmu_lp_mode_t = 0;
#[doc = "< PMU in LP_SLEEP mode"]
pub const pmu_lp_mode_t_PMU_MODE_LP_SLEEP: pmu_lp_mode_t = 1;
pub const pmu_lp_mode_t_PMU_MODE_LP_MAX: pmu_lp_mode_t = 2;
#[doc = " @brief PMU modes of LP system"]
pub type pmu_lp_mode_t = crate::c_types::c_uint;
#[doc = "< Power domain of digital top"]
pub const pmu_hp_power_domain_t_PMU_HP_PD_TOP: pmu_hp_power_domain_t = 0;
#[doc = "< Power domain of always-on"]
pub const pmu_hp_power_domain_t_PMU_HP_PD_HP_AON: pmu_hp_power_domain_t = 1;
#[doc = "< Power domain of HP CPU"]
pub const pmu_hp_power_domain_t_PMU_HP_PD_CPU: pmu_hp_power_domain_t = 2;
#[doc = "< Reserved power domain"]
pub const pmu_hp_power_domain_t_PMU_HP_PD_RESERVED: pmu_hp_power_domain_t = 3;
#[doc = "< Power domain of WIFI"]
pub const pmu_hp_power_domain_t_PMU_HP_PD_WIFI: pmu_hp_power_domain_t = 4;
pub type pmu_hp_power_domain_t = crate::c_types::c_uint;
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
        arg3: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const crate::c_types::c_void,
        arg2: *mut crate::c_types::c_void,
        arg3: crate::c_types::c_uint,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut crate::c_types::c_void, arg2: crate::c_types::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut crate::c_types::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ffsl(arg1: crate::c_types::c_long) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ffsll(arg1: crate::c_types::c_longlong) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fls(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn flsl(arg1: crate::c_types::c_long) -> crate::c_types::c_int;
}
extern "C" {
    pub fn flsll(arg1: crate::c_types::c_longlong) -> crate::c_types::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: locale_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const crate::c_types::c_void,
        arg2: crate::c_types::c_int,
        arg3: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
        arg3: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
        arg3: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
        arg3: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut crate::c_types::c_void,
        arg2: crate::c_types::c_int,
        arg3: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn strerror(arg1: crate::c_types::c_int) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const crate::c_types::c_char) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: locale_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: crate::c_types::c_int, arg2: locale_t) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: crate::c_types::c_int,
        arg4: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const crate::c_types::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn strsignal(__signo: crate::c_types::c_int) -> *mut crate::c_types::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hal_context_t {
    pub dev: *mut pmu_dev_t,
}
extern "C" {
    pub fn pmu_hal_hp_set_digital_power_up_wait_cycle(
        hal: *mut pmu_hal_context_t,
        power_supply_wait_cycle: u32,
        power_up_wait_cycle: u32,
    );
}
extern "C" {
    pub fn pmu_hal_hp_get_digital_power_up_wait_cycle(hal: *mut pmu_hal_context_t) -> u32;
}
extern "C" {
    pub fn pmu_hal_lp_set_digital_power_up_wait_cycle(
        hal: *mut pmu_hal_context_t,
        power_supply_wait_cycle: u32,
        power_up_wait_cycle: u32,
    );
}
extern "C" {
    pub fn pmu_hal_lp_get_digital_power_up_wait_cycle(hal: *mut pmu_hal_context_t) -> u32;
}
extern "C" {
    pub fn pmu_hal_hp_set_sleep_active_backup_enable(hal: *mut pmu_hal_context_t);
}
extern "C" {
    pub fn pmu_hal_hp_set_sleep_active_backup_disable(hal: *mut pmu_hal_context_t);
}
extern "C" {
    pub fn pmu_hal_hp_set_sleep_modem_backup_enable(hal: *mut pmu_hal_context_t);
}
extern "C" {
    pub fn pmu_hal_hp_set_sleep_modem_backup_disable(hal: *mut pmu_hal_context_t);
}
extern "C" {
    pub fn pmu_hal_hp_set_modem_active_backup_enable(hal: *mut pmu_hal_context_t);
}
extern "C" {
    pub fn pmu_hal_hp_set_modem_active_backup_disable(hal: *mut pmu_hal_context_t);
}
extern "C" {
    pub fn get_act_hp_dbias() -> u32;
}
extern "C" {
    pub fn get_act_lp_dbias() -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_system_power_param_t {
    pub dig_power: pmu_hp_dig_power_reg_t,
    pub clk_power: pmu_hp_clk_power_reg_t,
    pub xtal: pmu_hp_xtal_reg_t,
}
extern "C" {
    pub fn pmu_hp_system_power_param_default(
        mode: pmu_hp_mode_t,
    ) -> *const pmu_hp_system_power_param_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_system_clock_param_t {
    pub icg_func: u32,
    pub icg_apb: u32,
    pub icg_modem: pmu_hp_icg_modem_reg_t,
    pub sysclk: pmu_hp_sysclk_reg_t,
}
extern "C" {
    pub fn pmu_hp_system_clock_param_default(
        mode: pmu_hp_mode_t,
    ) -> *const pmu_hp_system_clock_param_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_system_digital_param_t {
    pub syscntl: pmu_hp_sys_cntl_reg_t,
}
extern "C" {
    pub fn pmu_hp_system_digital_param_default(
        mode: pmu_hp_mode_t,
    ) -> *const pmu_hp_system_digital_param_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_system_analog_param_t {
    pub bias: pmu_hp_bias_reg_t,
    pub regulator0: pmu_hp_regulator0_reg_t,
    pub regulator1: pmu_hp_regulator1_reg_t,
}
extern "C" {
    pub fn pmu_hp_system_analog_param_default(
        mode: pmu_hp_mode_t,
    ) -> *const pmu_hp_system_analog_param_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_system_retention_param_t {
    pub retention: pmu_hp_backup_reg_t,
    pub backup_clk: u32,
}
extern "C" {
    pub fn pmu_hp_system_retention_param_default(
        mode: pmu_hp_mode_t,
    ) -> *const pmu_hp_system_retention_param_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_lp_system_power_param_t {
    pub dig_power: pmu_lp_dig_power_reg_t,
    pub clk_power: pmu_lp_clk_power_reg_t,
    pub xtal: pmu_lp_xtal_reg_t,
}
extern "C" {
    pub fn pmu_lp_system_power_param_default(
        mode: pmu_lp_mode_t,
    ) -> *const pmu_lp_system_power_param_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_lp_system_analog_param_t {
    pub bias: pmu_lp_bias_reg_t,
    pub regulator0: pmu_lp_regulator0_reg_t,
    pub regulator1: pmu_lp_regulator1_reg_t,
}
extern "C" {
    pub fn pmu_lp_system_analog_param_default(
        mode: pmu_lp_mode_t,
    ) -> *const pmu_lp_system_analog_param_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_power_t {
    pub __bindgen_anon_1: pmu_hp_power_t__bindgen_ty_1,
    pub __bindgen_anon_2: pmu_hp_power_t__bindgen_ty_2,
    pub __bindgen_anon_3: pmu_hp_power_t__bindgen_ty_3,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_power_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_power_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn vdd_spi_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vdd_spi_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_dslp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_dslp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mem_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aon_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aon_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn top_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_top_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        vdd_spi_pd_en: u32,
        mem_dslp: u32,
        mem_pd_en: u32,
        wifi_pd_en: u32,
        reserved1: u32,
        cpu_pd_en: u32,
        aon_pd_en: u32,
        top_pd_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 21u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let vdd_spi_pd_en: u32 = unsafe { ::core::mem::transmute(vdd_spi_pd_en) };
            vdd_spi_pd_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let mem_dslp: u32 = unsafe { ::core::mem::transmute(mem_dslp) };
            mem_dslp as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let mem_pd_en: u32 = unsafe { ::core::mem::transmute(mem_pd_en) };
            mem_pd_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let wifi_pd_en: u32 = unsafe { ::core::mem::transmute(wifi_pd_en) };
            wifi_pd_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let cpu_pd_en: u32 = unsafe { ::core::mem::transmute(cpu_pd_en) };
            cpu_pd_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let aon_pd_en: u32 = unsafe { ::core::mem::transmute(aon_pd_en) };
            aon_pd_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let top_pd_en: u32 = unsafe { ::core::mem::transmute(top_pd_en) };
            top_pd_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_power_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_power_t__bindgen_ty_2 {
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_iso_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_iso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_retention(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_retention(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bb_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bb_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bbpll_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bbpll_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bbpll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bbpll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved2: u32,
        i2c_iso_en: u32,
        i2c_retention: u32,
        xpd_bb_i2c: u32,
        xpd_bbpll_i2c: u32,
        xpd_bbpll: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let i2c_iso_en: u32 = unsafe { ::core::mem::transmute(i2c_iso_en) };
            i2c_iso_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let i2c_retention: u32 = unsafe { ::core::mem::transmute(i2c_retention) };
            i2c_retention as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let xpd_bb_i2c: u32 = unsafe { ::core::mem::transmute(xpd_bb_i2c) };
            xpd_bb_i2c as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let xpd_bbpll_i2c: u32 = unsafe { ::core::mem::transmute(xpd_bbpll_i2c) };
            xpd_bbpll_i2c as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let xpd_bbpll: u32 = unsafe { ::core::mem::transmute(xpd_bbpll) };
            xpd_bbpll as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_power_t__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_power_t__bindgen_ty_3 {
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved4: u32, xpd_xtal: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_xtal: u32 = unsafe { ::core::mem::transmute(xpd_xtal) };
            xpd_xtal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_lp_power_t {
    pub __bindgen_anon_1: pmu_lp_power_t__bindgen_ty_1,
    pub __bindgen_anon_2: pmu_lp_power_t__bindgen_ty_2,
    pub __bindgen_anon_3: pmu_lp_power_t__bindgen_ty_3,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_power_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_power_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_dslp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_dslp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn peri_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_peri_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        mem_dslp: u32,
        peri_pd_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let mem_dslp: u32 = unsafe { ::core::mem::transmute(mem_dslp) };
            mem_dslp as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let peri_pd_en: u32 = unsafe { ::core::mem::transmute(peri_pd_en) };
            peri_pd_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_power_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_power_t__bindgen_ty_2 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_rc32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_rc32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_fosc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_fosc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_osc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_osc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: u32,
        xpd_xtal32k: u32,
        xpd_rc32k: u32,
        xpd_fosc: u32,
        pd_osc: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let xpd_xtal32k: u32 = unsafe { ::core::mem::transmute(xpd_xtal32k) };
            xpd_xtal32k as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let xpd_rc32k: u32 = unsafe { ::core::mem::transmute(xpd_rc32k) };
            xpd_rc32k as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let xpd_fosc: u32 = unsafe { ::core::mem::transmute(xpd_fosc) };
            xpd_fosc as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pd_osc: u32 = unsafe { ::core::mem::transmute(pd_osc) };
            pd_osc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_power_t__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_power_t__bindgen_ty_3 {
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved2: u32, xpd_xtal: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_xtal: u32 = unsafe { ::core::mem::transmute(xpd_xtal) };
            xpd_xtal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_analog_t {
    pub __bindgen_anon_1: pmu_hp_analog_t__bindgen_ty_1,
    pub __bindgen_anon_2: pmu_hp_analog_t__bindgen_ty_2,
    pub __bindgen_anon_3: pmu_hp_analog_t__bindgen_ty_3,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_analog_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_analog_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbg_atten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dbg_atten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_cur(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_cur(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_sleep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_sleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        xpd_bias: u32,
        dbg_atten: u32,
        pd_cur: u32,
        bias_sleep: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let xpd_bias: u32 = unsafe { ::core::mem::transmute(xpd_bias) };
            xpd_bias as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let dbg_atten: u32 = unsafe { ::core::mem::transmute(dbg_atten) };
            dbg_atten as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let pd_cur: u32 = unsafe { ::core::mem::transmute(pd_cur) };
            pd_cur as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bias_sleep: u32 = unsafe { ::core::mem::transmute(bias_sleep) };
            bias_sleep as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_analog_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_analog_t__bindgen_ty_2 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_mem_xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_mem_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_logic_xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_logic_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_mem_dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_slp_mem_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_logic_dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_slp_logic_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: u32,
        slp_mem_xpd: u32,
        slp_logic_xpd: u32,
        xpd: u32,
        slp_mem_dbias: u32,
        slp_logic_dbias: u32,
        dbias: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slp_mem_xpd: u32 = unsafe { ::core::mem::transmute(slp_mem_xpd) };
            slp_mem_xpd as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slp_logic_xpd: u32 = unsafe { ::core::mem::transmute(slp_logic_xpd) };
            slp_logic_xpd as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let xpd: u32 = unsafe { ::core::mem::transmute(xpd) };
            xpd as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let slp_mem_dbias: u32 = unsafe { ::core::mem::transmute(slp_mem_dbias) };
            slp_mem_dbias as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let slp_logic_dbias: u32 = unsafe { ::core::mem::transmute(slp_logic_dbias) };
            slp_logic_dbias as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let dbias: u32 = unsafe { ::core::mem::transmute(dbias) };
            dbias as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_hp_analog_t__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_hp_analog_t__bindgen_ty_3 {
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn drv_b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_drv_b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved2: u32, drv_b: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let drv_b: u32 = unsafe { ::core::mem::transmute(drv_b) };
            drv_b as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_lp_analog_t {
    pub __bindgen_anon_1: pmu_lp_analog_t__bindgen_ty_1,
    pub __bindgen_anon_2: pmu_lp_analog_t__bindgen_ty_2,
    pub __bindgen_anon_3: pmu_lp_analog_t__bindgen_ty_3,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_analog_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_analog_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbg_atten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dbg_atten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_cur(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_cur(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_sleep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_sleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        xpd_bias: u32,
        dbg_atten: u32,
        pd_cur: u32,
        bias_sleep: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let xpd_bias: u32 = unsafe { ::core::mem::transmute(xpd_bias) };
            xpd_bias as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let dbg_atten: u32 = unsafe { ::core::mem::transmute(dbg_atten) };
            dbg_atten as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let pd_cur: u32 = unsafe { ::core::mem::transmute(pd_cur) };
            pd_cur as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bias_sleep: u32 = unsafe { ::core::mem::transmute(bias_sleep) };
            bias_sleep as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_analog_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_analog_t__bindgen_ty_2 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_slp_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dbias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_dbias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: u32,
        slp_xpd: u32,
        xpd: u32,
        slp_dbias: u32,
        dbias: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 21u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let slp_xpd: u32 = unsafe { ::core::mem::transmute(slp_xpd) };
            slp_xpd as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let xpd: u32 = unsafe { ::core::mem::transmute(xpd) };
            xpd as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let slp_dbias: u32 = unsafe { ::core::mem::transmute(slp_dbias) };
            slp_dbias as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let dbias: u32 = unsafe { ::core::mem::transmute(dbias) };
            dbias as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct pmu_lp_analog_t__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pmu_lp_analog_t__bindgen_ty_3 {
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn drv_b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_drv_b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved2: u32, drv_b: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let drv_b: u32 = unsafe { ::core::mem::transmute(drv_b) };
            drv_b as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_param_t {
    pub modem_wakeup_wait_cycle: u32,
    pub analog_wait_target_cycle: u16,
    pub digital_power_down_wait_cycle: u16,
    pub digital_power_supply_wait_cycle: u16,
    pub digital_power_up_wait_cycle: u16,
    pub pll_stable_wait_cycle: u16,
    pub modify_icg_cntl_wait_cycle: u8,
    pub switch_icg_cntl_wait_cycle: u8,
    pub min_slp_slow_clk_cycle: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_lp_param_t {
    pub digital_power_supply_wait_cycle: u16,
    pub min_slp_slow_clk_cycle: u8,
    pub analog_wait_target_cycle: u8,
    pub digital_power_down_wait_cycle: u8,
    pub digital_power_up_wait_cycle: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_hp_lp_param_t {
    pub __bindgen_anon_1: pmu_hp_lp_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmu_hp_lp_param_t__bindgen_ty_1 {
    pub xtal_stable_wait_slow_clk_cycle: u16,
    pub xtal_stable_wait_cycle: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_power_config_t {
    pub hp_sys: pmu_sleep_power_config_t__bindgen_ty_1,
    pub lp_sys: [pmu_sleep_power_config_t__bindgen_ty_2; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_power_config_t__bindgen_ty_1 {
    pub dig_power: pmu_hp_power_t,
    pub clk_power: pmu_hp_power_t,
    pub xtal: pmu_hp_power_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_power_config_t__bindgen_ty_2 {
    pub dig_power: pmu_lp_power_t,
    pub clk_power: pmu_lp_power_t,
    pub xtal: pmu_lp_power_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_digital_config_t {
    pub syscntl: pmu_hp_sys_cntl_reg_t,
    pub icg_func: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_analog_config_t {
    pub hp_sys: pmu_sleep_analog_config_t__bindgen_ty_1,
    pub lp_sys: [pmu_sleep_analog_config_t__bindgen_ty_2; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_analog_config_t__bindgen_ty_1 {
    pub analog: pmu_hp_analog_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_analog_config_t__bindgen_ty_2 {
    pub analog: pmu_lp_analog_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_param_config_t {
    pub hp_sys: pmu_hp_param_t,
    pub lp_sys: pmu_lp_param_t,
    pub hp_lp: pmu_hp_lp_param_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_config_t {
    pub power: pmu_sleep_power_config_t,
    pub digital: pmu_sleep_digital_config_t,
    pub analog: pmu_sleep_analog_config_t,
    pub param: pmu_sleep_param_config_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_machine_constant {
    pub lp: pmu_sleep_machine_constant__bindgen_ty_1,
    pub hp: pmu_sleep_machine_constant__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_machine_constant__bindgen_ty_1 {
    pub min_slp_time_us: u16,
    pub wakeup_wait_cycle: u8,
    pub reserved0: u8,
    pub reserved1: u16,
    pub analog_wait_time_us: u16,
    pub xtal_wait_stable_time_us: u16,
    pub clk_switch_cycle: u8,
    pub clk_power_on_wait_cycle: u8,
    pub power_supply_wait_time_us: u16,
    pub power_up_wait_time_us: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_sleep_machine_constant__bindgen_ty_2 {
    pub min_slp_time_us: u16,
    pub clock_domain_sync_time_us: u16,
    pub system_dfs_up_work_time_us: u16,
    pub analog_wait_time_us: u16,
    pub power_supply_wait_time_us: u16,
    pub power_up_wait_time_us: u16,
    pub regdma_s2m_work_time_us: u16,
    pub regdma_s2a_work_time_us: u16,
    pub regdma_m2a_work_time_us: u16,
    pub regdma_a2s_work_time_us: u16,
    pub regdma_rf_on_work_time_us: u16,
    pub regdma_rf_off_work_time_us: u16,
    pub xtal_wait_stable_time_us: u16,
    pub pll_wait_stable_time_us: u16,
}
pub type pmu_sleep_machine_constant_t = pmu_sleep_machine_constant;
pub const pmu_hp_icg_modem_mode_t_PMU_HP_ICG_MODEM_CODE_SLEEP: pmu_hp_icg_modem_mode_t = 0;
pub const pmu_hp_icg_modem_mode_t_PMU_HP_ICG_MODEM_CODE_MODEM: pmu_hp_icg_modem_mode_t = 1;
pub const pmu_hp_icg_modem_mode_t_PMU_HP_ICG_MODEM_CODE_ACTIVE: pmu_hp_icg_modem_mode_t = 2;
#[doc = " @brief PMU ICG modem code of HP system\n @note  This type is required in rtc_clk_init.c when PMU not fully supported"]
pub type pmu_hp_icg_modem_mode_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmu_context_t {
    pub hal: *mut pmu_hal_context_t,
    pub mc: *mut crate::c_types::c_void,
}
extern "C" {
    pub fn PMU_instance() -> *mut pmu_context_t;
}
pub const pmu_sleep_protect_mode_PMU_SLEEP_PROTECT_HP_SLEEP: pmu_sleep_protect_mode = 0;
pub const pmu_sleep_protect_mode_PMU_SLEEP_PROTECT_XTAL: pmu_sleep_protect_mode = 1;
pub const pmu_sleep_protect_mode_PMU_SLEEP_PROTECT_HP_LP_SLEEP: pmu_sleep_protect_mode = 2;
pub const pmu_sleep_protect_mode_PMU_SLEEP_PROTECT_DISABLE: pmu_sleep_protect_mode = 3;
pub type pmu_sleep_protect_mode = crate::c_types::c_uint;
pub use self::pmu_sleep_protect_mode as pmu_sleep_protect_mode_t;
pub const pmu_sleep_regdma_entry_PMU_SLEEP_REGDMA_ENTRY_0: pmu_sleep_regdma_entry = 0;
pub const pmu_sleep_regdma_entry_PMU_SLEEP_REGDMA_ENTRY_1: pmu_sleep_regdma_entry = 1;
pub const pmu_sleep_regdma_entry_PMU_SLEEP_REGDMA_ENTRY_2: pmu_sleep_regdma_entry = 2;
pub const pmu_sleep_regdma_entry_PMU_SLEEP_REGDMA_ENTRY_3: pmu_sleep_regdma_entry = 3;
pub const pmu_sleep_regdma_entry_PMU_SLEEP_REGDMA_ENTRY_MAX: pmu_sleep_regdma_entry = 4;
pub type pmu_sleep_regdma_entry = crate::c_types::c_uint;
pub use self::pmu_sleep_regdma_entry as pmu_sleep_regdma_entry_t;
extern "C" {
    #[doc = " @brief  Enable_regdma_backup."]
    pub fn pmu_sleep_enable_regdma_backup();
}
extern "C" {
    #[doc = " @brief  Disable_regdma_backup."]
    pub fn pmu_sleep_disable_regdma_backup();
}
extern "C" {
    #[doc = " @brief Get sleep PLL enable status\n\n @return true if PLL is enabled by PMU in modem state"]
    pub fn pmu_sleep_pll_already_enabled() -> bool;
}
extern "C" {
    #[doc = " @brief Calculate the LP system hardware time overhead during sleep\n\n @param sleep_flags flags indicates the power domain that will be powered down and the sleep submode\n @param slowclk_period re-calibrated slow clock period\n @param fastclk_period re-calibrated fast clock period\n\n @return hardware time overhead in us"]
    pub fn pmu_sleep_calculate_lp_hw_wait_time(
        sleep_flags: u32,
        slowclk_period: u32,
        fastclk_period: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Calculate the HP system hardware time overhead during sleep\n\n @param sleep_flags flags indicates the power domain that will be powered down and the sleep submode\n @param slowclk_period re-calibrated slow clock period\n @param fastclk_period re-calibrated fast clock period\n\n @return hardware time overhead in us"]
    pub fn pmu_sleep_calculate_hp_hw_wait_time(
        sleep_flags: u32,
        slowclk_period: u32,
        fastclk_period: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Calculate the hardware time overhead during sleep to compensate for sleep time\n\n @param sleep_flags flags indicates the power domain that will be powered down and the sleep submode\n @param slowclk_src slow clock source of pmu\n @param slowclk_period re-calibrated slow clock period\n @param fastclk_period re-calibrated fast clock period\n\n @return hardware time overhead in us"]
    pub fn pmu_sleep_calculate_hw_wait_time(
        sleep_flags: u32,
        slowclk_src: soc_rtc_slow_clk_src_t,
        slowclk_period: u32,
        fastclk_period: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Get default sleep configuration\n @param config pmu_sleep_config instance\n @param sleep_flags flags indicates the power domain that will be powered down and the sleep submode\n @param clk_flags indicates the clock ICG cell that will be ungated\n @param adjustment total software and hardware time overhead\n @param slowclk_src slow clock source of pmu\n @param slowclk_period re-calibrated slow clock period in microseconds,\n                       Q13.19 fixed point format\n @param fastclk_period re-calibrated fast clock period in microseconds,\n                       Q13.19 fixed point format\n @param dslp configuration for deep sleep mode\n\n @return hardware time overhead in us"]
    pub fn pmu_sleep_config_default(
        config: *mut pmu_sleep_config_t,
        sleep_flags: u32,
        clk_flags: u32,
        adjustment: u32,
        slowclk_src: soc_rtc_slow_clk_src_t,
        slowclk_period: u32,
        fastclk_period: u32,
        dslp: bool,
    ) -> *const pmu_sleep_config_t;
}
extern "C" {
    #[doc = " @brief Prepare the chip to enter sleep mode\n\n This function configures various power/analog parameters and lp/lp system configuration\n used in sleep state machines\n\n This function does not actually enter sleep mode; this is done using\n pmu_sleep_start function. Software may do some other actions between\n pmu_sleep_init and pmu_sleep_start, such as set wakeup timer and configure\n wakeup sources.\n\n @param config sleep mode configuration\n\n @param dslp is initialize for deep sleep mode"]
    pub fn pmu_sleep_init(config: *const pmu_sleep_config_t, dslp: bool);
}
extern "C" {
    #[doc = " @brief Enter deep or light sleep mode\n\n This function enters the sleep mode previously configured using pmu_sleep_init\n function. Before entering sleep, software should configure wake up sources\n appropriately (set up GPIO wakeup registers, timer wakeup registers,\n and so on).\n\n If deep sleep mode was configured using pmu_sleep_init, and sleep is not\n rejected by hardware (based on reject_opt flags), this function never returns.\n When the chip wakes up from deep sleep, CPU is reset and execution starts\n from ROM bootloader.\n\n If light sleep mode was configured using pmu_sleep_init, this function\n returns on wakeup, or if sleep is rejected by hardware.\n\n @param wakeup_opt  bit mask wake up reasons to enable (RTC_xxx_TRIG_EN flags\n                    combined with OR)\n @param reject_opt  bit mask of sleep reject reasons, used to\n                    prevent wakeup source set before the sleep request)\n @param lslp_mem_inf_fpu If non-zero then the low power config is restored\n                         immediately on wake. Recommended for light sleep,\n                         has no effect if the system goes into deep sleep.\n\n @return non-zero if sleep was rejected by hardware"]
    pub fn pmu_sleep_start(
        wakeup_opt: u32,
        reject_opt: u32,
        lslp_mem_inf_fpu: u32,
        dslp: bool,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief   Finish sleep process settings and get sleep reject status\n @param   dslp True if sleep requests id deep-sleep\n @return  return sleep reject status"]
    pub fn pmu_sleep_finish(dslp: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Initialize PMU related power/clock/digital parameters and functions"]
    pub fn pmu_init();
}
extern "C" {
    #[doc = " Get the time overhead used by regdma to work on the retention link during the hardware wake-up process\n @return  regdma time cost during hardware wake-up stage in microseconds"]
    pub fn pmu_sleep_get_wakup_retention_cost() -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_test_conf_reg_t {
    pub __bindgen_anon_1: modem_syscon_test_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_test_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_test_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(clk_en: u32, reserved_1: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved_1: u32 = unsafe { ::core::mem::transmute(reserved_1) };
            reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_clk_conf_reg_t {
    pub __bindgen_anon_1: modem_syscon_clk_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_clk_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_clk_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved_0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_data_dump_mux(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_data_dump_mux(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_etm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_etm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_zb_apb_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_zb_apb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_zb_mac_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_zb_mac_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_ecb_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_ecb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_ccm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_ccm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_bah_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_bah_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_apb_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_apb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_ble_timer_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_ble_timer_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_data_dump_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_data_dump_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved_0: u32,
        clk_data_dump_mux: u32,
        clk_etm_en: u32,
        clk_zb_apb_en: u32,
        clk_zb_mac_en: u32,
        clk_modem_sec_ecb_en: u32,
        clk_modem_sec_ccm_en: u32,
        clk_modem_sec_bah_en: u32,
        clk_modem_sec_apb_en: u32,
        clk_modem_sec_en: u32,
        clk_ble_timer_en: u32,
        clk_data_dump_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 21u8, {
            let reserved_0: u32 = unsafe { ::core::mem::transmute(reserved_0) };
            reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let clk_data_dump_mux: u32 = unsafe { ::core::mem::transmute(clk_data_dump_mux) };
            clk_data_dump_mux as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let clk_etm_en: u32 = unsafe { ::core::mem::transmute(clk_etm_en) };
            clk_etm_en as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let clk_zb_apb_en: u32 = unsafe { ::core::mem::transmute(clk_zb_apb_en) };
            clk_zb_apb_en as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let clk_zb_mac_en: u32 = unsafe { ::core::mem::transmute(clk_zb_mac_en) };
            clk_zb_mac_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let clk_modem_sec_ecb_en: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_ecb_en) };
            clk_modem_sec_ecb_en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let clk_modem_sec_ccm_en: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_ccm_en) };
            clk_modem_sec_ccm_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let clk_modem_sec_bah_en: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_bah_en) };
            clk_modem_sec_bah_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let clk_modem_sec_apb_en: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_apb_en) };
            clk_modem_sec_apb_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let clk_modem_sec_en: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_en) };
            clk_modem_sec_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let clk_ble_timer_en: u32 = unsafe { ::core::mem::transmute(clk_ble_timer_en) };
            clk_ble_timer_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let clk_data_dump_en: u32 = unsafe { ::core::mem::transmute(clk_data_dump_en) };
            clk_data_dump_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_clk_conf_force_on_reg_t {
    pub __bindgen_anon_1: modem_syscon_clk_conf_force_on_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_clk_conf_force_on_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_clk_conf_force_on_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved_0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_etm_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_etm_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_zb_apb_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_zb_apb_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_zb_mac_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_zb_mac_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_ecb_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_ecb_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_ccm_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_ccm_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_bah_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_bah_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_apb_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_apb_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_sec_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_sec_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_ble_timer_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_ble_timer_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_data_dump_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_data_dump_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved_0: u32,
        clk_etm_fo: u32,
        clk_zb_apb_fo: u32,
        clk_zb_mac_fo: u32,
        clk_modem_sec_ecb_fo: u32,
        clk_modem_sec_ccm_fo: u32,
        clk_modem_sec_bah_fo: u32,
        clk_modem_sec_apb_fo: u32,
        clk_modem_sec_fo: u32,
        clk_ble_timer_fo: u32,
        clk_data_dump_fo: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let reserved_0: u32 = unsafe { ::core::mem::transmute(reserved_0) };
            reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let clk_etm_fo: u32 = unsafe { ::core::mem::transmute(clk_etm_fo) };
            clk_etm_fo as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let clk_zb_apb_fo: u32 = unsafe { ::core::mem::transmute(clk_zb_apb_fo) };
            clk_zb_apb_fo as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let clk_zb_mac_fo: u32 = unsafe { ::core::mem::transmute(clk_zb_mac_fo) };
            clk_zb_mac_fo as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let clk_modem_sec_ecb_fo: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_ecb_fo) };
            clk_modem_sec_ecb_fo as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let clk_modem_sec_ccm_fo: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_ccm_fo) };
            clk_modem_sec_ccm_fo as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let clk_modem_sec_bah_fo: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_bah_fo) };
            clk_modem_sec_bah_fo as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let clk_modem_sec_apb_fo: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_apb_fo) };
            clk_modem_sec_apb_fo as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let clk_modem_sec_fo: u32 = unsafe { ::core::mem::transmute(clk_modem_sec_fo) };
            clk_modem_sec_fo as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let clk_ble_timer_fo: u32 = unsafe { ::core::mem::transmute(clk_ble_timer_fo) };
            clk_ble_timer_fo as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let clk_data_dump_fo: u32 = unsafe { ::core::mem::transmute(clk_data_dump_fo) };
            clk_data_dump_fo as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_clk_conf_power_st_reg_t {
    pub __bindgen_anon_1: modem_syscon_clk_conf_power_st_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_clk_conf_power_st_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_clk_conf_power_st_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved_0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_zb_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_zb_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_bt_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_bt_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifi_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifi_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_peri_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_peri_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_modem_apb_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_apb_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved_0: u32,
        clk_zb_st_map: u32,
        clk_fe_st_map: u32,
        clk_bt_st_map: u32,
        clk_wifi_st_map: u32,
        clk_modem_peri_st_map: u32,
        clk_modem_apb_st_map: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved_0: u32 = unsafe { ::core::mem::transmute(reserved_0) };
            reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let clk_zb_st_map: u32 = unsafe { ::core::mem::transmute(clk_zb_st_map) };
            clk_zb_st_map as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let clk_fe_st_map: u32 = unsafe { ::core::mem::transmute(clk_fe_st_map) };
            clk_fe_st_map as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let clk_bt_st_map: u32 = unsafe { ::core::mem::transmute(clk_bt_st_map) };
            clk_bt_st_map as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let clk_wifi_st_map: u32 = unsafe { ::core::mem::transmute(clk_wifi_st_map) };
            clk_wifi_st_map as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let clk_modem_peri_st_map: u32 =
                unsafe { ::core::mem::transmute(clk_modem_peri_st_map) };
            clk_modem_peri_st_map as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let clk_modem_apb_st_map: u32 = unsafe { ::core::mem::transmute(clk_modem_apb_st_map) };
            clk_modem_apb_st_map as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_modem_rst_conf_reg_t {
    pub __bindgen_anon_1: modem_syscon_modem_rst_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_modem_rst_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_modem_rst_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved_0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_wifibb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_wifibb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_wifimac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_wifimac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_fe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_fe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_btmac_apb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_btmac_apb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_btmac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_btmac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_btbb_apb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_btbb_apb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_btbb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_btbb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_etm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_etm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_zbmac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_zbmac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_modem_ecb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_modem_ecb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_modem_ccm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_modem_ccm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_modem_bah(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_modem_bah(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_modem_sec(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_modem_sec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_ble_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_ble_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_data_dump(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_data_dump(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved_0: u32,
        rst_wifibb: u32,
        reserved_9: u32,
        rst_wifimac: u32,
        reserved_11: u32,
        rst_fe: u32,
        rst_btmac_apb: u32,
        rst_btmac: u32,
        rst_btbb_apb: u32,
        rst_btbb: u32,
        reserved_19: u32,
        rst_etm: u32,
        reserved_23: u32,
        rst_zbmac: u32,
        rst_modem_ecb: u32,
        rst_modem_ccm: u32,
        rst_modem_bah: u32,
        reserved_28: u32,
        rst_modem_sec: u32,
        rst_ble_timer: u32,
        rst_data_dump: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved_0: u32 = unsafe { ::core::mem::transmute(reserved_0) };
            reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rst_wifibb: u32 = unsafe { ::core::mem::transmute(rst_wifibb) };
            rst_wifibb as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let reserved_9: u32 = unsafe { ::core::mem::transmute(reserved_9) };
            reserved_9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst_wifimac: u32 = unsafe { ::core::mem::transmute(rst_wifimac) };
            rst_wifimac as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let reserved_11: u32 = unsafe { ::core::mem::transmute(reserved_11) };
            reserved_11 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rst_fe: u32 = unsafe { ::core::mem::transmute(rst_fe) };
            rst_fe as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rst_btmac_apb: u32 = unsafe { ::core::mem::transmute(rst_btmac_apb) };
            rst_btmac_apb as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rst_btmac: u32 = unsafe { ::core::mem::transmute(rst_btmac) };
            rst_btmac as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rst_btbb_apb: u32 = unsafe { ::core::mem::transmute(rst_btbb_apb) };
            rst_btbb_apb as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rst_btbb: u32 = unsafe { ::core::mem::transmute(rst_btbb) };
            rst_btbb as u64
        });
        __bindgen_bitfield_unit.set(19usize, 3u8, {
            let reserved_19: u32 = unsafe { ::core::mem::transmute(reserved_19) };
            reserved_19 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rst_etm: u32 = unsafe { ::core::mem::transmute(rst_etm) };
            rst_etm as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let reserved_23: u32 = unsafe { ::core::mem::transmute(reserved_23) };
            reserved_23 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rst_zbmac: u32 = unsafe { ::core::mem::transmute(rst_zbmac) };
            rst_zbmac as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let rst_modem_ecb: u32 = unsafe { ::core::mem::transmute(rst_modem_ecb) };
            rst_modem_ecb as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rst_modem_ccm: u32 = unsafe { ::core::mem::transmute(rst_modem_ccm) };
            rst_modem_ccm as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rst_modem_bah: u32 = unsafe { ::core::mem::transmute(rst_modem_bah) };
            rst_modem_bah as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let reserved_28: u32 = unsafe { ::core::mem::transmute(reserved_28) };
            reserved_28 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let rst_modem_sec: u32 = unsafe { ::core::mem::transmute(rst_modem_sec) };
            rst_modem_sec as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rst_ble_timer: u32 = unsafe { ::core::mem::transmute(rst_ble_timer) };
            rst_ble_timer as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rst_data_dump: u32 = unsafe { ::core::mem::transmute(rst_data_dump) };
            rst_data_dump as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_clk_conf1_reg_t {
    pub __bindgen_anon_1: modem_syscon_clk_conf1_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_clk_conf1_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_clk_conf1_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_wifibb_22m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_22m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_40m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_40m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_44m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_44m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_80m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_80m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_40x_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_40x_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_80x_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_80x_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_40x1_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_40x1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_80x1_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_80x1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_160x1_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_160x1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifimac_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifimac_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifi_apb_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifi_apb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_20m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_20m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_40m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_40m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_80m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_80m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_160m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_160m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_cal_160m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_cal_160m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_apb_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_apb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_bt_apb_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_bt_apb_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_bt_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_bt_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_480m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_480m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_480m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_480m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_anamode_40m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_anamode_40m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_anamode_80m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_anamode_80m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_anamode_160m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_anamode_160m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_wifibb_22m_en: u32,
        clk_wifibb_40m_en: u32,
        clk_wifibb_44m_en: u32,
        clk_wifibb_80m_en: u32,
        clk_wifibb_40x_en: u32,
        clk_wifibb_80x_en: u32,
        clk_wifibb_40x1_en: u32,
        clk_wifibb_80x1_en: u32,
        clk_wifibb_160x1_en: u32,
        clk_wifimac_en: u32,
        clk_wifi_apb_en: u32,
        clk_fe_20m_en: u32,
        clk_fe_40m_en: u32,
        clk_fe_80m_en: u32,
        clk_fe_160m_en: u32,
        clk_fe_cal_160m_en: u32,
        clk_fe_apb_en: u32,
        clk_bt_apb_en: u32,
        clk_bt_en: u32,
        clk_wifibb_480m_en: u32,
        clk_fe_480m_en: u32,
        clk_fe_anamode_40m_en: u32,
        clk_fe_anamode_80m_en: u32,
        clk_fe_anamode_160m_en: u32,
        reserved_24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_wifibb_22m_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_22m_en) };
            clk_wifibb_22m_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_wifibb_40m_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_40m_en) };
            clk_wifibb_40m_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clk_wifibb_44m_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_44m_en) };
            clk_wifibb_44m_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clk_wifibb_80m_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_80m_en) };
            clk_wifibb_80m_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let clk_wifibb_40x_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_40x_en) };
            clk_wifibb_40x_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let clk_wifibb_80x_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_80x_en) };
            clk_wifibb_80x_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let clk_wifibb_40x1_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_40x1_en) };
            clk_wifibb_40x1_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let clk_wifibb_80x1_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_80x1_en) };
            clk_wifibb_80x1_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let clk_wifibb_160x1_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_160x1_en) };
            clk_wifibb_160x1_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let clk_wifimac_en: u32 = unsafe { ::core::mem::transmute(clk_wifimac_en) };
            clk_wifimac_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let clk_wifi_apb_en: u32 = unsafe { ::core::mem::transmute(clk_wifi_apb_en) };
            clk_wifi_apb_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let clk_fe_20m_en: u32 = unsafe { ::core::mem::transmute(clk_fe_20m_en) };
            clk_fe_20m_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let clk_fe_40m_en: u32 = unsafe { ::core::mem::transmute(clk_fe_40m_en) };
            clk_fe_40m_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let clk_fe_80m_en: u32 = unsafe { ::core::mem::transmute(clk_fe_80m_en) };
            clk_fe_80m_en as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let clk_fe_160m_en: u32 = unsafe { ::core::mem::transmute(clk_fe_160m_en) };
            clk_fe_160m_en as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let clk_fe_cal_160m_en: u32 = unsafe { ::core::mem::transmute(clk_fe_cal_160m_en) };
            clk_fe_cal_160m_en as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let clk_fe_apb_en: u32 = unsafe { ::core::mem::transmute(clk_fe_apb_en) };
            clk_fe_apb_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let clk_bt_apb_en: u32 = unsafe { ::core::mem::transmute(clk_bt_apb_en) };
            clk_bt_apb_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let clk_bt_en: u32 = unsafe { ::core::mem::transmute(clk_bt_en) };
            clk_bt_en as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let clk_wifibb_480m_en: u32 = unsafe { ::core::mem::transmute(clk_wifibb_480m_en) };
            clk_wifibb_480m_en as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let clk_fe_480m_en: u32 = unsafe { ::core::mem::transmute(clk_fe_480m_en) };
            clk_fe_480m_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let clk_fe_anamode_40m_en: u32 =
                unsafe { ::core::mem::transmute(clk_fe_anamode_40m_en) };
            clk_fe_anamode_40m_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let clk_fe_anamode_80m_en: u32 =
                unsafe { ::core::mem::transmute(clk_fe_anamode_80m_en) };
            clk_fe_anamode_80m_en as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let clk_fe_anamode_160m_en: u32 =
                unsafe { ::core::mem::transmute(clk_fe_anamode_160m_en) };
            clk_fe_anamode_160m_en as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved_24: u32 = unsafe { ::core::mem::transmute(reserved_24) };
            reserved_24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_clk_conf1_force_on_reg_t {
    pub __bindgen_anon_1: modem_syscon_clk_conf1_force_on_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_clk_conf1_force_on_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_clk_conf1_force_on_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_wifibb_22m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_22m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_40m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_40m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_44m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_44m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_80m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_80m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_40x_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_40x_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_80x_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_80x_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_40x1_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_40x1_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_80x1_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_80x1_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_160x1_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_160x1_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifimac_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifimac_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifi_apb_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifi_apb_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_20m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_20m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_40m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_40m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_80m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_80m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_160m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_160m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_cal_160m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_cal_160m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_apb_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_apb_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_bt_apb_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_bt_apb_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_bt_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_bt_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifibb_480m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifibb_480m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_480m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_480m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_anamode_40m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_anamode_40m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_anamode_80m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_anamode_80m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_fe_anamode_160m_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_fe_anamode_160m_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_wifibb_22m_fo: u32,
        clk_wifibb_40m_fo: u32,
        clk_wifibb_44m_fo: u32,
        clk_wifibb_80m_fo: u32,
        clk_wifibb_40x_fo: u32,
        clk_wifibb_80x_fo: u32,
        clk_wifibb_40x1_fo: u32,
        clk_wifibb_80x1_fo: u32,
        clk_wifibb_160x1_fo: u32,
        clk_wifimac_fo: u32,
        clk_wifi_apb_fo: u32,
        clk_fe_20m_fo: u32,
        clk_fe_40m_fo: u32,
        clk_fe_80m_fo: u32,
        clk_fe_160m_fo: u32,
        clk_fe_cal_160m_fo: u32,
        clk_fe_apb_fo: u32,
        clk_bt_apb_fo: u32,
        clk_bt_fo: u32,
        clk_wifibb_480m_fo: u32,
        clk_fe_480m_fo: u32,
        clk_fe_anamode_40m_fo: u32,
        clk_fe_anamode_80m_fo: u32,
        clk_fe_anamode_160m_fo: u32,
        reserved_24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_wifibb_22m_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_22m_fo) };
            clk_wifibb_22m_fo as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_wifibb_40m_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_40m_fo) };
            clk_wifibb_40m_fo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clk_wifibb_44m_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_44m_fo) };
            clk_wifibb_44m_fo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clk_wifibb_80m_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_80m_fo) };
            clk_wifibb_80m_fo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let clk_wifibb_40x_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_40x_fo) };
            clk_wifibb_40x_fo as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let clk_wifibb_80x_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_80x_fo) };
            clk_wifibb_80x_fo as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let clk_wifibb_40x1_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_40x1_fo) };
            clk_wifibb_40x1_fo as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let clk_wifibb_80x1_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_80x1_fo) };
            clk_wifibb_80x1_fo as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let clk_wifibb_160x1_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_160x1_fo) };
            clk_wifibb_160x1_fo as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let clk_wifimac_fo: u32 = unsafe { ::core::mem::transmute(clk_wifimac_fo) };
            clk_wifimac_fo as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let clk_wifi_apb_fo: u32 = unsafe { ::core::mem::transmute(clk_wifi_apb_fo) };
            clk_wifi_apb_fo as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let clk_fe_20m_fo: u32 = unsafe { ::core::mem::transmute(clk_fe_20m_fo) };
            clk_fe_20m_fo as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let clk_fe_40m_fo: u32 = unsafe { ::core::mem::transmute(clk_fe_40m_fo) };
            clk_fe_40m_fo as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let clk_fe_80m_fo: u32 = unsafe { ::core::mem::transmute(clk_fe_80m_fo) };
            clk_fe_80m_fo as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let clk_fe_160m_fo: u32 = unsafe { ::core::mem::transmute(clk_fe_160m_fo) };
            clk_fe_160m_fo as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let clk_fe_cal_160m_fo: u32 = unsafe { ::core::mem::transmute(clk_fe_cal_160m_fo) };
            clk_fe_cal_160m_fo as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let clk_fe_apb_fo: u32 = unsafe { ::core::mem::transmute(clk_fe_apb_fo) };
            clk_fe_apb_fo as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let clk_bt_apb_fo: u32 = unsafe { ::core::mem::transmute(clk_bt_apb_fo) };
            clk_bt_apb_fo as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let clk_bt_fo: u32 = unsafe { ::core::mem::transmute(clk_bt_fo) };
            clk_bt_fo as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let clk_wifibb_480m_fo: u32 = unsafe { ::core::mem::transmute(clk_wifibb_480m_fo) };
            clk_wifibb_480m_fo as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let clk_fe_480m_fo: u32 = unsafe { ::core::mem::transmute(clk_fe_480m_fo) };
            clk_fe_480m_fo as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let clk_fe_anamode_40m_fo: u32 =
                unsafe { ::core::mem::transmute(clk_fe_anamode_40m_fo) };
            clk_fe_anamode_40m_fo as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let clk_fe_anamode_80m_fo: u32 =
                unsafe { ::core::mem::transmute(clk_fe_anamode_80m_fo) };
            clk_fe_anamode_80m_fo as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let clk_fe_anamode_160m_fo: u32 =
                unsafe { ::core::mem::transmute(clk_fe_anamode_160m_fo) };
            clk_fe_anamode_160m_fo as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved_24: u32 = unsafe { ::core::mem::transmute(reserved_24) };
            reserved_24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_wifi_bb_cfg_reg_t {
    pub __bindgen_anon_1: modem_syscon_wifi_bb_cfg_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_wifi_bb_cfg_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_wifi_bb_cfg_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn wifi_bb_cfg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_bb_cfg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(wifi_bb_cfg: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let wifi_bb_cfg: u32 = unsafe { ::core::mem::transmute(wifi_bb_cfg) };
            wifi_bb_cfg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_mem_conf_reg_t {
    pub __bindgen_anon_1: modem_syscon_mem_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_mem_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_mem_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn modem_mem_wp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_modem_mem_wp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_mem_wa(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_modem_mem_wa(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_mem_ra(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_modem_mem_ra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        modem_mem_wp: u32,
        modem_mem_wa: u32,
        modem_mem_ra: u32,
        reserved_8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let modem_mem_wp: u32 = unsafe { ::core::mem::transmute(modem_mem_wp) };
            modem_mem_wp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let modem_mem_wa: u32 = unsafe { ::core::mem::transmute(modem_mem_wa) };
            modem_mem_wa as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let modem_mem_ra: u32 = unsafe { ::core::mem::transmute(modem_mem_ra) };
            modem_mem_ra as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved_8: u32 = unsafe { ::core::mem::transmute(reserved_8) };
            reserved_8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_syscon_date_reg_t {
    pub __bindgen_anon_1: modem_syscon_date_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_syscon_date_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_syscon_date_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved_28: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved_28: u32 = unsafe { ::core::mem::transmute(reserved_28) };
            reserved_28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct modem_syscon_dev_t {
    pub test_conf: modem_syscon_test_conf_reg_t,
    pub clk_conf: modem_syscon_clk_conf_reg_t,
    pub clk_conf_force_on: modem_syscon_clk_conf_force_on_reg_t,
    pub clk_conf_power_st: modem_syscon_clk_conf_power_st_reg_t,
    pub modem_rst_conf: modem_syscon_modem_rst_conf_reg_t,
    pub clk_conf1: modem_syscon_clk_conf1_reg_t,
    pub clk_conf1_force_on: modem_syscon_clk_conf1_force_on_reg_t,
    pub wifi_bb_cfg: modem_syscon_wifi_bb_cfg_reg_t,
    pub mem_conf: modem_syscon_mem_conf_reg_t,
    pub date: modem_syscon_date_reg_t,
}
extern "C" {
    pub static mut MODEM_SYSCON: modem_syscon_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_test_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_test_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_test_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_test_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_debug_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_debug_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_en: u32,
        clk_debug_ena: u32,
        reserved_2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_debug_ena: u32 = unsafe { ::core::mem::transmute(clk_debug_ena) };
            clk_debug_ena as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved_2: u32 = unsafe { ::core::mem::transmute(reserved_2) };
            reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_lp_timer_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_lp_timer_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_lp_timer_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_lp_timer_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_lp_timer_sel_osc_slow(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_lp_timer_sel_osc_slow(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_lp_timer_sel_osc_fast(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_lp_timer_sel_osc_fast(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_lp_timer_sel_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_lp_timer_sel_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_lp_timer_sel_xtal32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_lp_timer_sel_xtal32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_lp_timer_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_clk_lp_timer_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_lp_timer_sel_osc_slow: u32,
        clk_lp_timer_sel_osc_fast: u32,
        clk_lp_timer_sel_xtal: u32,
        clk_lp_timer_sel_xtal32k: u32,
        clk_lp_timer_div_num: u32,
        reserved_16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_lp_timer_sel_osc_slow: u32 =
                unsafe { ::core::mem::transmute(clk_lp_timer_sel_osc_slow) };
            clk_lp_timer_sel_osc_slow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_lp_timer_sel_osc_fast: u32 =
                unsafe { ::core::mem::transmute(clk_lp_timer_sel_osc_fast) };
            clk_lp_timer_sel_osc_fast as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clk_lp_timer_sel_xtal: u32 =
                unsafe { ::core::mem::transmute(clk_lp_timer_sel_xtal) };
            clk_lp_timer_sel_xtal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clk_lp_timer_sel_xtal32k: u32 =
                unsafe { ::core::mem::transmute(clk_lp_timer_sel_xtal32k) };
            clk_lp_timer_sel_xtal32k as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let clk_lp_timer_div_num: u32 = unsafe { ::core::mem::transmute(clk_lp_timer_div_num) };
            clk_lp_timer_div_num as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved_16: u32 = unsafe { ::core::mem::transmute(reserved_16) };
            reserved_16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_coex_lp_clk_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_coex_lp_clk_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_coex_lp_clk_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_coex_lp_clk_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_coex_lp_sel_osc_slow(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_coex_lp_sel_osc_slow(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_coex_lp_sel_osc_fast(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_coex_lp_sel_osc_fast(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_coex_lp_sel_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_coex_lp_sel_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_coex_lp_sel_xtal32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_coex_lp_sel_xtal32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_coex_lp_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_clk_coex_lp_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_coex_lp_sel_osc_slow: u32,
        clk_coex_lp_sel_osc_fast: u32,
        clk_coex_lp_sel_xtal: u32,
        clk_coex_lp_sel_xtal32k: u32,
        clk_coex_lp_div_num: u32,
        reserved_16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_coex_lp_sel_osc_slow: u32 =
                unsafe { ::core::mem::transmute(clk_coex_lp_sel_osc_slow) };
            clk_coex_lp_sel_osc_slow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_coex_lp_sel_osc_fast: u32 =
                unsafe { ::core::mem::transmute(clk_coex_lp_sel_osc_fast) };
            clk_coex_lp_sel_osc_fast as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clk_coex_lp_sel_xtal: u32 = unsafe { ::core::mem::transmute(clk_coex_lp_sel_xtal) };
            clk_coex_lp_sel_xtal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clk_coex_lp_sel_xtal32k: u32 =
                unsafe { ::core::mem::transmute(clk_coex_lp_sel_xtal32k) };
            clk_coex_lp_sel_xtal32k as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let clk_coex_lp_div_num: u32 = unsafe { ::core::mem::transmute(clk_coex_lp_div_num) };
            clk_coex_lp_div_num as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved_16: u32 = unsafe { ::core::mem::transmute(reserved_16) };
            reserved_16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_wifi_lp_clk_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_wifi_lp_clk_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_wifi_lp_clk_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_wifi_lp_clk_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_wifipwr_lp_sel_osc_slow(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifipwr_lp_sel_osc_slow(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifipwr_lp_sel_osc_fast(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifipwr_lp_sel_osc_fast(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifipwr_lp_sel_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifipwr_lp_sel_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifipwr_lp_sel_xtal32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifipwr_lp_sel_xtal32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifipwr_lp_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifipwr_lp_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_wifipwr_lp_sel_osc_slow: u32,
        clk_wifipwr_lp_sel_osc_fast: u32,
        clk_wifipwr_lp_sel_xtal: u32,
        clk_wifipwr_lp_sel_xtal32k: u32,
        clk_wifipwr_lp_div_num: u32,
        reserved_16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_wifipwr_lp_sel_osc_slow: u32 =
                unsafe { ::core::mem::transmute(clk_wifipwr_lp_sel_osc_slow) };
            clk_wifipwr_lp_sel_osc_slow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_wifipwr_lp_sel_osc_fast: u32 =
                unsafe { ::core::mem::transmute(clk_wifipwr_lp_sel_osc_fast) };
            clk_wifipwr_lp_sel_osc_fast as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clk_wifipwr_lp_sel_xtal: u32 =
                unsafe { ::core::mem::transmute(clk_wifipwr_lp_sel_xtal) };
            clk_wifipwr_lp_sel_xtal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clk_wifipwr_lp_sel_xtal32k: u32 =
                unsafe { ::core::mem::transmute(clk_wifipwr_lp_sel_xtal32k) };
            clk_wifipwr_lp_sel_xtal32k as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let clk_wifipwr_lp_div_num: u32 =
                unsafe { ::core::mem::transmute(clk_wifipwr_lp_div_num) };
            clk_wifipwr_lp_div_num as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved_16: u32 = unsafe { ::core::mem::transmute(reserved_16) };
            reserved_16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_i2c_mst_clk_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_i2c_mst_clk_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_i2c_mst_clk_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_i2c_mst_clk_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_i2c_mst_sel_160m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_i2c_mst_sel_160m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_i2c_mst_sel_160m: u32,
        reserved_1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_i2c_mst_sel_160m: u32 = unsafe { ::core::mem::transmute(clk_i2c_mst_sel_160m) };
            clk_i2c_mst_sel_160m as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved_1: u32 = unsafe { ::core::mem::transmute(reserved_1) };
            reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_modem_32k_clk_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_modem_32k_clk_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_modem_32k_clk_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_modem_32k_clk_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_modem_32k_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_clk_modem_32k_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_modem_32k_sel: u32,
        reserved_2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let clk_modem_32k_sel: u32 = unsafe { ::core::mem::transmute(clk_modem_32k_sel) };
            clk_modem_32k_sel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved_2: u32 = unsafe { ::core::mem::transmute(reserved_2) };
            reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_clk_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_clk_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_clk_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_clk_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_wifipwr_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifipwr_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_coex_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_coex_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_i2c_mst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_i2c_mst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_lp_timer_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_lp_timer_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_wifipwr_en: u32,
        clk_coex_en: u32,
        clk_i2c_mst_en: u32,
        clk_lp_timer_en: u32,
        reserved_4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_wifipwr_en: u32 = unsafe { ::core::mem::transmute(clk_wifipwr_en) };
            clk_wifipwr_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_coex_en: u32 = unsafe { ::core::mem::transmute(clk_coex_en) };
            clk_coex_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clk_i2c_mst_en: u32 = unsafe { ::core::mem::transmute(clk_i2c_mst_en) };
            clk_i2c_mst_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clk_lp_timer_en: u32 = unsafe { ::core::mem::transmute(clk_lp_timer_en) };
            clk_lp_timer_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved_4: u32 = unsafe { ::core::mem::transmute(reserved_4) };
            reserved_4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_clk_conf_force_on_reg_t {
    pub __bindgen_anon_1: modem_lpcon_clk_conf_force_on_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_clk_conf_force_on_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_clk_conf_force_on_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_wifipwr_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifipwr_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_coex_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_coex_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_i2c_mst_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_i2c_mst_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_lp_timer_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_lp_timer_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_bcmem_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_bcmem_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_i2c_mst_mem_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_i2c_mst_mem_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_chan_freq_mem_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_chan_freq_mem_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_pbus_mem_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_pbus_mem_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_agc_mem_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_agc_mem_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_dc_mem_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_dc_mem_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clk_wifipwr_fo: u32,
        clk_coex_fo: u32,
        clk_i2c_mst_fo: u32,
        clk_lp_timer_fo: u32,
        clk_bcmem_fo: u32,
        clk_i2c_mst_mem_fo: u32,
        clk_chan_freq_mem_fo: u32,
        clk_pbus_mem_fo: u32,
        clk_agc_mem_fo: u32,
        clk_dc_mem_fo: u32,
        reserved_10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_wifipwr_fo: u32 = unsafe { ::core::mem::transmute(clk_wifipwr_fo) };
            clk_wifipwr_fo as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clk_coex_fo: u32 = unsafe { ::core::mem::transmute(clk_coex_fo) };
            clk_coex_fo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let clk_i2c_mst_fo: u32 = unsafe { ::core::mem::transmute(clk_i2c_mst_fo) };
            clk_i2c_mst_fo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clk_lp_timer_fo: u32 = unsafe { ::core::mem::transmute(clk_lp_timer_fo) };
            clk_lp_timer_fo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let clk_bcmem_fo: u32 = unsafe { ::core::mem::transmute(clk_bcmem_fo) };
            clk_bcmem_fo as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let clk_i2c_mst_mem_fo: u32 = unsafe { ::core::mem::transmute(clk_i2c_mst_mem_fo) };
            clk_i2c_mst_mem_fo as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let clk_chan_freq_mem_fo: u32 = unsafe { ::core::mem::transmute(clk_chan_freq_mem_fo) };
            clk_chan_freq_mem_fo as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let clk_pbus_mem_fo: u32 = unsafe { ::core::mem::transmute(clk_pbus_mem_fo) };
            clk_pbus_mem_fo as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let clk_agc_mem_fo: u32 = unsafe { ::core::mem::transmute(clk_agc_mem_fo) };
            clk_agc_mem_fo as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let clk_dc_mem_fo: u32 = unsafe { ::core::mem::transmute(clk_dc_mem_fo) };
            clk_dc_mem_fo as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved_10: u32 = unsafe { ::core::mem::transmute(reserved_10) };
            reserved_10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_clk_conf_power_st_reg_t {
    pub __bindgen_anon_1: modem_lpcon_clk_conf_power_st_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_clk_conf_power_st_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_clk_conf_power_st_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved_0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_wifipwr_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_wifipwr_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_coex_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_coex_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_i2c_mst_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_i2c_mst_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_lp_apb_st_map(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_clk_lp_apb_st_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved_0: u32,
        clk_wifipwr_st_map: u32,
        clk_coex_st_map: u32,
        clk_i2c_mst_st_map: u32,
        clk_lp_apb_st_map: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved_0: u32 = unsafe { ::core::mem::transmute(reserved_0) };
            reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let clk_wifipwr_st_map: u32 = unsafe { ::core::mem::transmute(clk_wifipwr_st_map) };
            clk_wifipwr_st_map as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let clk_coex_st_map: u32 = unsafe { ::core::mem::transmute(clk_coex_st_map) };
            clk_coex_st_map as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let clk_i2c_mst_st_map: u32 = unsafe { ::core::mem::transmute(clk_i2c_mst_st_map) };
            clk_i2c_mst_st_map as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let clk_lp_apb_st_map: u32 = unsafe { ::core::mem::transmute(clk_lp_apb_st_map) };
            clk_lp_apb_st_map as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_rst_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_rst_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_rst_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_rst_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn rst_wifipwr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_wifipwr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_coex(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_coex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_i2c_mst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_i2c_mst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_lp_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_lp_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rst_wifipwr: u32,
        rst_coex: u32,
        rst_i2c_mst: u32,
        rst_lp_timer: u32,
        reserved_4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rst_wifipwr: u32 = unsafe { ::core::mem::transmute(rst_wifipwr) };
            rst_wifipwr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rst_coex: u32 = unsafe { ::core::mem::transmute(rst_coex) };
            rst_coex as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rst_i2c_mst: u32 = unsafe { ::core::mem::transmute(rst_i2c_mst) };
            rst_i2c_mst as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rst_lp_timer: u32 = unsafe { ::core::mem::transmute(rst_lp_timer) };
            rst_lp_timer as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved_4: u32 = unsafe { ::core::mem::transmute(reserved_4) };
            reserved_4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_mem_conf_reg_t {
    pub __bindgen_anon_1: modem_lpcon_mem_conf_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_mem_conf_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_mem_conf_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn dc_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dc_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn agc_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_agc_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn agc_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_agc_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pbus_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pbus_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pbus_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pbus_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bc_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bc_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bc_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bc_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_mst_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_mst_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_mst_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_mst_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chan_freq_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chan_freq_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chan_freq_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chan_freq_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_pwr_mem_wp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_modem_pwr_mem_wp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_pwr_mem_wa(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_modem_pwr_mem_wa(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn modem_pwr_mem_ra(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_modem_pwr_mem_ra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dc_mem_force_pu: u32,
        dc_mem_force_pd: u32,
        agc_mem_force_pu: u32,
        agc_mem_force_pd: u32,
        pbus_mem_force_pu: u32,
        pbus_mem_force_pd: u32,
        bc_mem_force_pu: u32,
        bc_mem_force_pd: u32,
        i2c_mst_mem_force_pu: u32,
        i2c_mst_mem_force_pd: u32,
        chan_freq_mem_force_pu: u32,
        chan_freq_mem_force_pd: u32,
        modem_pwr_mem_wp: u32,
        modem_pwr_mem_wa: u32,
        modem_pwr_mem_ra: u32,
        reserved_20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dc_mem_force_pu: u32 = unsafe { ::core::mem::transmute(dc_mem_force_pu) };
            dc_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dc_mem_force_pd: u32 = unsafe { ::core::mem::transmute(dc_mem_force_pd) };
            dc_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let agc_mem_force_pu: u32 = unsafe { ::core::mem::transmute(agc_mem_force_pu) };
            agc_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let agc_mem_force_pd: u32 = unsafe { ::core::mem::transmute(agc_mem_force_pd) };
            agc_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pbus_mem_force_pu: u32 = unsafe { ::core::mem::transmute(pbus_mem_force_pu) };
            pbus_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pbus_mem_force_pd: u32 = unsafe { ::core::mem::transmute(pbus_mem_force_pd) };
            pbus_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bc_mem_force_pu: u32 = unsafe { ::core::mem::transmute(bc_mem_force_pu) };
            bc_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bc_mem_force_pd: u32 = unsafe { ::core::mem::transmute(bc_mem_force_pd) };
            bc_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let i2c_mst_mem_force_pu: u32 = unsafe { ::core::mem::transmute(i2c_mst_mem_force_pu) };
            i2c_mst_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let i2c_mst_mem_force_pd: u32 = unsafe { ::core::mem::transmute(i2c_mst_mem_force_pd) };
            i2c_mst_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let chan_freq_mem_force_pu: u32 =
                unsafe { ::core::mem::transmute(chan_freq_mem_force_pu) };
            chan_freq_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let chan_freq_mem_force_pd: u32 =
                unsafe { ::core::mem::transmute(chan_freq_mem_force_pd) };
            chan_freq_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let modem_pwr_mem_wp: u32 = unsafe { ::core::mem::transmute(modem_pwr_mem_wp) };
            modem_pwr_mem_wp as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let modem_pwr_mem_wa: u32 = unsafe { ::core::mem::transmute(modem_pwr_mem_wa) };
            modem_pwr_mem_wa as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let modem_pwr_mem_ra: u32 = unsafe { ::core::mem::transmute(modem_pwr_mem_ra) };
            modem_pwr_mem_ra as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved_20: u32 = unsafe { ::core::mem::transmute(reserved_20) };
            reserved_20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union modem_lpcon_date_reg_t {
    pub __bindgen_anon_1: modem_lpcon_date_reg_t__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct modem_lpcon_date_reg_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl modem_lpcon_date_reg_t__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved_28: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved_28: u32 = unsafe { ::core::mem::transmute(reserved_28) };
            reserved_28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct modem_lpcon_dev_t {
    pub test_conf: modem_lpcon_test_conf_reg_t,
    pub lp_timer_conf: modem_lpcon_lp_timer_conf_reg_t,
    pub coex_lp_clk_conf: modem_lpcon_coex_lp_clk_conf_reg_t,
    pub wifi_lp_clk_conf: modem_lpcon_wifi_lp_clk_conf_reg_t,
    pub i2c_mst_clk_conf: modem_lpcon_i2c_mst_clk_conf_reg_t,
    pub modem_32k_clk_conf: modem_lpcon_modem_32k_clk_conf_reg_t,
    pub clk_conf: modem_lpcon_clk_conf_reg_t,
    pub clk_conf_force_on: modem_lpcon_clk_conf_force_on_reg_t,
    pub clk_conf_power_st: modem_lpcon_clk_conf_power_st_reg_t,
    pub rst_conf: modem_lpcon_rst_conf_reg_t,
    pub mem_conf: modem_lpcon_mem_conf_reg_t,
    pub date: modem_lpcon_date_reg_t,
}
extern "C" {
    pub static mut MODEM_LPCON: modem_lpcon_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct modem_clock_hal_context_t {
    pub syscon_dev: *mut modem_syscon_dev_t,
    pub lpcon_dev: *mut modem_lpcon_dev_t,
}
extern "C" {
    pub fn modem_clock_hal_set_clock_domain_icg_bitmap(
        hal: *mut modem_clock_hal_context_t,
        domain: modem_clock_domain_t,
        bitmap: u32,
    );
}
extern "C" {
    pub fn modem_clock_hal_get_clock_domain_icg_bitmap(
        hal: *mut modem_clock_hal_context_t,
        domain: modem_clock_domain_t,
    ) -> u32;
}
extern "C" {
    pub fn modem_clock_hal_enable_modem_common_fe_clock(
        hal: *mut modem_clock_hal_context_t,
        enable: bool,
    );
}
extern "C" {
    pub fn modem_clock_hal_enable_modem_private_fe_clock(
        hal: *mut modem_clock_hal_context_t,
        enable: bool,
    );
}
extern "C" {
    pub fn modem_clock_hal_set_ble_rtc_timer_divisor_value(
        hal: *mut modem_clock_hal_context_t,
        divider: u32,
    );
}
extern "C" {
    pub fn modem_clock_hal_enable_ble_rtc_timer_clock(
        hal: *mut modem_clock_hal_context_t,
        enable: bool,
    );
}
extern "C" {
    pub fn modem_clock_hal_select_ble_rtc_timer_lpclk_source(
        hal: *mut modem_clock_hal_context_t,
        src: modem_clock_lpclk_src_t,
    );
}
extern "C" {
    pub fn modem_clock_hal_deselect_all_ble_rtc_timer_lpclk_source(
        hal: *mut modem_clock_hal_context_t,
    );
}
extern "C" {
    pub fn modem_clock_hal_select_coex_lpclk_source(
        hal: *mut modem_clock_hal_context_t,
        src: modem_clock_lpclk_src_t,
    );
}
extern "C" {
    pub fn modem_clock_hal_deselect_all_coex_lpclk_source(hal: *mut modem_clock_hal_context_t);
}
extern "C" {
    pub fn modem_clock_hal_select_wifi_lpclk_source(
        hal: *mut modem_clock_hal_context_t,
        src: modem_clock_lpclk_src_t,
    );
}
extern "C" {
    pub fn modem_clock_hal_deselect_all_wifi_lpclk_source(hal: *mut modem_clock_hal_context_t);
}
extern "C" {
    pub fn modem_clock_hal_enable_wifipwr_clock(hal: *mut modem_clock_hal_context_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Enable the clock of modem module\n\n Solve the clock dependency between modem modules, For example, the wifi\n module depends on the wifi mac, wifi baseband and FE, when wifi module\n clock is enabled, the wifi MAC, baseband and FE clocks will be enabled\n\n This interface and modem_clock_module_disable will jointly maintain the\n ref_cnt of each device clock source. The ref_cnt indicates how many modules\n are relying on the clock source. Each enable ops will add 1 to the ref_cnt of\n the clock source that the module depends on, and only when the ref_cnt of\n the module is from 0 to 1 will the clock enable be actually configured.\n\n !!! Do not use the hal/ll layer interface to configure the clock for the\n consistency of the hardware state maintained in the driver and the hardware\n actual state.\n\n @param module  modem module"]
    pub fn modem_clock_module_enable(module: periph_module_t);
}
extern "C" {
    #[doc = " @brief Disable the clock of modem module\n\n This interface and modem_clock_module_enable will jointly maintain the ref_cnt\n of each device clock source. The ref_cnt indicates how many modules are relying\n on the clock source. Each disable ops will minus 1 to the ref_cnt of the clock\n source that the module depends on, and only when the ref_cnt of the module is\n from 1 to 0 will the clock disable be actually configured.\n\n !!! Do not use the hal/ll layer interface to configure the clock for the\n consistency of the hardware state maintained in the driver and the hardware\n actual state.\n\n @param module  modem module"]
    pub fn modem_clock_module_disable(module: periph_module_t);
}
extern "C" {
    #[doc = " @brief Reset the mac of modem module\n\n @param module  modem module, must be one of\n    PERIPH_WIFI_MODULE / PERIPH_BT_MODULE /PERIPH_IEEE802154_MODULE"]
    pub fn modem_clock_module_mac_reset(module: periph_module_t);
}
extern "C" {
    #[doc = " @brief Enable modem clock domain clock gate to gate it's output\n\n @param domain modem module clock domain\n @param mode   PMU HP system ACTIVE, MODEM and SLEEP state\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the argument value are not correct"]
    pub fn modem_clock_domain_clk_gate_enable(
        domain: modem_clock_domain_t,
        mode: pmu_hp_icg_modem_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable modem clock domain clock gate to ungate it's output\n\n @param domain modem module clock domain\n @param mode   PMU HP system ACTIVE, MODEM and SLEEP state\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the argument value are not correct"]
    pub fn modem_clock_domain_clk_gate_disable(
        domain: modem_clock_domain_t,
        mode: pmu_hp_icg_modem_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Select the modem module lowpower clock source and configure the clock divider\n\n @param module  modem module\n @param src     lowpower clock source\n @param divider divider value to lowpower clock source"]
    pub fn modem_clock_select_lp_clock_source(
        module: periph_module_t,
        src: modem_clock_lpclk_src_t,
        divider: u32,
    );
}
extern "C" {
    #[doc = " @brief Disable lowpower clock source selection\n @param module  modem module"]
    pub fn modem_clock_deselect_lp_clock_source(module: periph_module_t);
}
extern "C" {
    #[doc = " @brief Disable all modem module's lowpower clock source selection"]
    pub fn modem_clock_deselect_all_module_lp_clock_source();
}
extern "C" {
    #[doc = " @brief Reset wifi mac"]
    pub fn modem_clock_wifi_mac_reset();
}
extern "C" {
    #[doc = " @brief Enable clock registers which shared by both modem and ADC. Need a ref count to enable/disable them\n\n @param enable true: enable; false: disable"]
    pub fn modem_clock_shared_enable(enable: bool);
}
#[doc = "< Bluetooth is not running"]
pub const esp_bt_mode_t_ESP_BT_MODE_IDLE: esp_bt_mode_t = 0;
#[doc = "< Run BLE mode"]
pub const esp_bt_mode_t_ESP_BT_MODE_BLE: esp_bt_mode_t = 1;
#[doc = "< Run Classic BT mode"]
pub const esp_bt_mode_t_ESP_BT_MODE_CLASSIC_BT: esp_bt_mode_t = 2;
#[doc = "< Run dual mode"]
pub const esp_bt_mode_t_ESP_BT_MODE_BTDM: esp_bt_mode_t = 3;
#[doc = " @brief Bluetooth mode for controller enable/disable."]
pub type esp_bt_mode_t = crate::c_types::c_uint;
#[doc = "< Controller is in idle state"]
pub const esp_bt_controller_status_t_ESP_BT_CONTROLLER_STATUS_IDLE: esp_bt_controller_status_t = 0;
#[doc = "< Controller is in initialising state"]
pub const esp_bt_controller_status_t_ESP_BT_CONTROLLER_STATUS_INITED: esp_bt_controller_status_t =
    1;
#[doc = "< Controller is in enabled state"]
pub const esp_bt_controller_status_t_ESP_BT_CONTROLLER_STATUS_ENABLED: esp_bt_controller_status_t =
    2;
#[doc = "< Controller is in disabled state"]
pub const esp_bt_controller_status_t_ESP_BT_CONTROLLER_STATUS_NUM: esp_bt_controller_status_t = 3;
#[doc = " @brief Bluetooth controller enable/disable/initialised/de-initialised status."]
pub type esp_bt_controller_status_t = crate::c_types::c_uint;
#[doc = "< For connection handle 0"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL0: esp_ble_power_type_t = 0;
#[doc = "< For connection handle 1"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL1: esp_ble_power_type_t = 1;
#[doc = "< For connection handle 2"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL2: esp_ble_power_type_t = 2;
#[doc = "< For connection handle 3"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL3: esp_ble_power_type_t = 3;
#[doc = "< For connection handle 4"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL4: esp_ble_power_type_t = 4;
#[doc = "< For connection handle 5"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL5: esp_ble_power_type_t = 5;
#[doc = "< For connection handle 6"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL6: esp_ble_power_type_t = 6;
#[doc = "< For connection handle 7"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL7: esp_ble_power_type_t = 7;
#[doc = "< For connection handle 8"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL8: esp_ble_power_type_t = 8;
#[doc = "< For advertising"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_ADV: esp_ble_power_type_t = 9;
#[doc = "< For scan"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_SCAN: esp_ble_power_type_t = 10;
#[doc = "< For default, if not set other, it will use default value"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_DEFAULT: esp_ble_power_type_t = 11;
#[doc = "< TYPE numbers"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_NUM: esp_ble_power_type_t = 12;
#[doc = " @brief BLE tx power type\n        ESP_BLE_PWR_TYPE_CONN_HDL0-8: for each connection, and only be set after connection completed.\n                                      when disconnect, the correspond TX power is not effected.\n        ESP_BLE_PWR_TYPE_ADV : for advertising/scan response.\n        ESP_BLE_PWR_TYPE_SCAN : for scan.\n        ESP_BLE_PWR_TYPE_DEFAULT : if each connection's TX power is not set, it will use this default value.\n                                   if neither in scan mode nor in adv mode, it will use this default value.\n        If none of power type is set, system will use ESP_PWR_LVL_P3 as default for ADV/SCAN/CONN0-9."]
pub type esp_ble_power_type_t = crate::c_types::c_uint;
#[doc = "< Corresponding to -15dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N15: esp_power_level_t = 3;
#[doc = "< Corresponding to -12dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N12: esp_power_level_t = 4;
#[doc = "< Corresponding to  -9dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N9: esp_power_level_t = 5;
#[doc = "< Corresponding to  -6dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N6: esp_power_level_t = 6;
#[doc = "< Corresponding to  -3dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N3: esp_power_level_t = 7;
#[doc = "< Corresponding to   0dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N0: esp_power_level_t = 8;
#[doc = "< Corresponding to  +3dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P3: esp_power_level_t = 9;
#[doc = "< Corresponding to  +6dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P6: esp_power_level_t = 10;
#[doc = "< Corresponding to  +9dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P9: esp_power_level_t = 11;
#[doc = "< Corresponding to  +12dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P12: esp_power_level_t = 12;
#[doc = "< Corresponding to  +15dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P15: esp_power_level_t = 13;
#[doc = "< Corresponding to  +18dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P18: esp_power_level_t = 14;
#[doc = "< Corresponding to  +20dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P20: esp_power_level_t = 15;
#[doc = "< Indicates an invalid value"]
pub const esp_power_level_t_ESP_PWR_LVL_INVALID: esp_power_level_t = 255;
#[doc = " @brief Bluetooth TX power level(index), it's just a index corresponding to power(dbm)."]
pub type esp_power_level_t = crate::c_types::c_uint;
pub const esp_ble_enhanced_power_type_t_ESP_BLE_ENHANCED_PWR_TYPE_DEFAULT:
    esp_ble_enhanced_power_type_t = 0;
pub const esp_ble_enhanced_power_type_t_ESP_BLE_ENHANCED_PWR_TYPE_ADV:
    esp_ble_enhanced_power_type_t = 1;
pub const esp_ble_enhanced_power_type_t_ESP_BLE_ENHANCED_PWR_TYPE_SCAN:
    esp_ble_enhanced_power_type_t = 2;
pub const esp_ble_enhanced_power_type_t_ESP_BLE_ENHANCED_PWR_TYPE_INIT:
    esp_ble_enhanced_power_type_t = 3;
pub const esp_ble_enhanced_power_type_t_ESP_BLE_ENHANCED_PWR_TYPE_CONN:
    esp_ble_enhanced_power_type_t = 4;
pub const esp_ble_enhanced_power_type_t_ESP_BLE_ENHANCED_PWR_TYPE_MAX:
    esp_ble_enhanced_power_type_t = 5;
#[doc = " @brief The enhanced type of which tx power, could set Advertising/Connection/Default and etc."]
pub type esp_ble_enhanced_power_type_t = crate::c_types::c_uint;
pub const esp_ble_log_buf_t_ESP_BLE_LOG_BUF_HCI: esp_ble_log_buf_t = 2;
pub const esp_ble_log_buf_t_ESP_BLE_LOG_BUF_CONTROLLER: esp_ble_log_buf_t = 5;
#[doc = " @brief Select buffers"]
pub type esp_ble_log_buf_t = crate::c_types::c_uint;
#[doc = " @brief Address type and address value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_ble_addr_t {
    #[doc = "< Type of the Bluetooth address (public, random, etc.)"]
    pub type_: u8,
    #[doc = "< Array containing the 6-byte Bluetooth address value"]
    pub val: [u8; 6usize],
}
extern "C" {
    #[doc = " @brief  Set BLE TX power\n         Connection Tx power should only be set after connection created.\n @param  power_type : The type of which tx power, could set Advertising/Connection/Default and etc\n @param  power_level: Power level(index) corresponding to absolute value(dbm)\n @return              ESP_OK - success, other - failed"]
    pub fn esp_ble_tx_power_set(
        power_type: esp_ble_power_type_t,
        power_level: esp_power_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get BLE TX power\n         Connection Tx power should only be get after connection created.\n @param  power_type : The type of which tx power, could set Advertising/Connection/Default and etc\n @return             >= 0 - Power level, < 0 - Invalid"]
    pub fn esp_ble_tx_power_get(power_type: esp_ble_power_type_t) -> esp_power_level_t;
}
extern "C" {
    #[doc = " @brief  ENHANCED API for Setting BLE TX power\n         Connection Tx power should only be set after connection created.\n @param  power_type : The enhanced type of which tx power, could set Advertising/Connection/Default and etc.\n @param  handle : The handle of Advertising or Connection and the value 0 for other enhanced power types.\n @param  power_level: Power level(index) corresponding to absolute value(dbm)\n @return              ESP_OK - success, other - failed"]
    pub fn esp_ble_tx_power_set_enhanced(
        power_type: esp_ble_enhanced_power_type_t,
        handle: u16,
        power_level: esp_power_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  ENHANCED API of Getting BLE TX power\n         Connection Tx power should only be get after connection created.\n @param  power_type : The enhanced type of which tx power, could set Advertising/Connection/Default and etc\n @param  handle : The handle of Advertising or Connection and the value 0 for other enhanced power types.\n @return             >= 0 - Power level, < 0 - Invalid"]
    pub fn esp_ble_tx_power_get_enhanced(
        power_type: esp_ble_enhanced_power_type_t,
        handle: u16,
    ) -> esp_power_level_t;
}
#[doc = " @brief Controller config options, depend on config mask.\n        Config mask indicate which functions enabled, this means\n        some options or parameters of some functions enabled by config mask."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_bt_controller_config_t {
    #[doc = "< Configuration version"]
    pub config_version: u32,
    #[doc = "< Size of the BLE resolving list"]
    pub ble_ll_resolv_list_size: u16,
    #[doc = "< Number of high priority HCI event buffers"]
    pub ble_hci_evt_hi_buf_count: u16,
    #[doc = "< Number of low priority HCI event buffers"]
    pub ble_hci_evt_lo_buf_count: u16,
    #[doc = "< Number of entries in the BLE sync list"]
    pub ble_ll_sync_list_cnt: u8,
    #[doc = "< Number of BLE sync instances"]
    pub ble_ll_sync_cnt: u8,
    #[doc = "< Size of the BLE response duplicate list"]
    pub ble_ll_rsp_dup_list_count: u16,
    #[doc = "< Size of the BLE advertising duplicate list"]
    pub ble_ll_adv_dup_list_count: u16,
    #[doc = "< BLE transmit power in dBm"]
    pub ble_ll_tx_pwr_dbm: u8,
    #[doc = "< RTC (Real-Time Clock) frequency"]
    pub rtc_freq: u64,
    #[doc = "< BLE sleep clock accuracy in ppm"]
    pub ble_ll_sca: u16,
    #[doc = "< Number of BLE scanning physical layers"]
    pub ble_ll_scan_phy_number: u8,
    #[doc = "< BLE connection default authentication payload timeout"]
    pub ble_ll_conn_def_auth_pyld_tmo: u16,
    #[doc = "< BLE link layer jitter in microseconds"]
    pub ble_ll_jitter_usecs: u8,
    #[doc = "< BLE scheduler maximum advertising PDU duration in microseconds"]
    pub ble_ll_sched_max_adv_pdu_usecs: u16,
    #[doc = "< BLE scheduler maximum direct advertising duration in microseconds"]
    pub ble_ll_sched_direct_adv_max_usecs: u16,
    #[doc = "< BLE scheduler maximum advertising duration in microseconds"]
    pub ble_ll_sched_adv_max_usecs: u16,
    #[doc = "< Maximum length of BLE scan response data"]
    pub ble_scan_rsp_data_max_len: u16,
    #[doc = "< Number of BLE LL configuration HCI command packets"]
    pub ble_ll_cfg_num_hci_cmd_pkts: u8,
    #[doc = "< BLE link layer controller process timeout in milliseconds"]
    pub ble_ll_ctrl_proc_timeout_ms: u32,
    #[doc = "< Maximum number of concurrent BLE connections"]
    pub nimble_max_connections: u16,
    #[doc = "< Size of the BLE whitelist"]
    pub ble_whitelist_size: u8,
    #[doc = "< Size of the BLE ACL data buffer"]
    pub ble_acl_buf_size: u16,
    #[doc = "< Number of BLE ACL data buffers"]
    pub ble_acl_buf_count: u16,
    #[doc = "< Size of the BLE HCI event buffer"]
    pub ble_hci_evt_buf_size: u16,
    #[doc = "< Number of BLE multi-advertising instances"]
    pub ble_multi_adv_instances: u16,
    #[doc = "< Maximum size of BLE extended advertising data"]
    pub ble_ext_adv_max_size: u16,
    #[doc = "< Controller task stack size"]
    pub controller_task_stack_size: u16,
    #[doc = "< Controller task priority"]
    pub controller_task_prio: u8,
    #[doc = "< CPU core on which the controller runs"]
    pub controller_run_cpu: u8,
    #[doc = "< Enable quality assurance (QA) testing"]
    pub enable_qa_test: u8,
    #[doc = "< Enable Bluetooth Qualification Test (BQB) testing"]
    pub enable_bqb_test: u8,
    #[doc = "< Enable Transmit Clear Channel Assessment (TX CCA)"]
    pub enable_tx_cca: u8,
    #[doc = "< RSSI threshold for Transmit Clear Channel Assessment (CCA)"]
    pub cca_rssi_thresh: u8,
    #[doc = "< Enable sleep mode"]
    pub sleep_en: u8,
    #[doc = "< PHY coded transmission and reception time limit for coexistence"]
    pub coex_phy_coded_tx_rx_time_limit: u8,
    #[doc = "< Disable scan backoff"]
    pub dis_scan_backoff: u8,
    #[doc = "< Enable BLE scan classify filter"]
    pub ble_scan_classify_filter_enable: u8,
    #[doc = "< CCA drop mode"]
    pub cca_drop_mode: u8,
    #[doc = "< CCA low transmit power"]
    pub cca_low_tx_pwr: i8,
    #[doc = "< Main crystal frequency"]
    pub main_xtal_freq: u8,
    #[doc = "< Controller configuration version number"]
    pub version_num: u32,
    #[doc = "< CPU frequency in megahertz (MHz)"]
    pub cpu_freq_mhz: u8,
    #[doc = "< Ignore the whitelist for direct advertising"]
    pub ignore_wl_for_direct_adv: u8,
    #[doc = "< Enable power control"]
    pub enable_pcl: u8,
    #[doc = "< Select CSA#2"]
    pub csa2_select: u8,
    #[doc = "< Enable CSR"]
    pub enable_csr: u8,
    #[doc = "< True if adds a verification step for the Access Address within the CONNECT_IND PDU; false otherwise. Configurable in menuconfig"]
    pub ble_aa_check: u8,
    #[doc = "< Flag indicating whether the Controller disconnects after Instant Passed (0x28) error occurs. Configurable in menuconfig.\n- The Controller does not disconnect after Instant Passed (0x28) by default."]
    pub ble_llcp_disc_flag: u8,
    #[doc = "< The value of upperlimitmax is 2^n, The maximum value is 256"]
    pub scan_backoff_upperlimitmax: u16,
    #[doc = "< Enable / disable BLE channel assessment. Configurable in menuconfig.\n- 0 - Disable\n- 1 - Enable (default)"]
    pub ble_chan_ass_en: u8,
    #[doc = "< Enable / disable auxiliary packets when the extended ADV data length is zero. Configurable in menuconfig.\n- 0 - Disable (default)\n- 1 - Enable"]
    pub ble_data_lenth_zero_aux: u8,
    #[doc = "< VHCI mode is enabled"]
    pub vhci_enabled: u8,
    #[doc = "< Enable boundary check for internal memory."]
    pub ptr_check_enabled: u8,
    #[doc = "< The options for Extended advertising sending."]
    pub ble_adv_tx_options: u8,
    #[doc = "< The option to skip non-fatal state checks and perform extra handling for fatal checks."]
    pub skip_unnecessary_checks_en: u8,
    #[doc = "< The option for fast transmission of connection data\n- 0 - Disable\n- 1 - Enable (default)"]
    pub fast_conn_data_tx_en: u8,
    #[doc = "< BLE transmit power (in dBm) used for BLE advertising on channel 39."]
    pub ch39_txpwr: i8,
    #[doc = "< BLE adv state machine reserve count number"]
    pub adv_rsv_cnt: u8,
    #[doc = "< BLE conn state machine reserve count number"]
    pub conn_rsv_cnt: u8,
    #[doc = "< Magic number for configuration validation"]
    pub config_magic: u32,
}
extern "C" {
    #[doc = " @brief       Initialize BT controller to allocate task and other resource.\n              This function should be called only once, before any other BT functions are called.\n @param  cfg: Initial configuration of BT controller.\n @return      ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_init(cfg: *mut esp_bt_controller_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get BT controller is initialised/de-initialised/enabled/disabled\n @return status value"]
    pub fn esp_bt_controller_get_status() -> esp_bt_controller_status_t;
}
extern "C" {
    #[doc = " @brief  De-initialize BT controller to free resource and delete task.\n         You should stop advertising and scanning, as well as\n         disconnect all existing connections before de-initializing BT controller.\n\n This function should be called only once, after any other BT functions are called.\n This function is not whole completed, esp_bt_controller_init cannot called after this function.\n @return  ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable BT controller.\n               Due to a known issue, you cannot call esp_bt_controller_enable() a second time\n               to change the controller mode dynamically. To change controller mode, call\n               esp_bt_controller_disable() and then call esp_bt_controller_enable() with the new mode.\n @param mode : the mode(BLE/BT/BTDM) to enable. For compatible of API, retain this argument.\n @return       ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_enable(mode: esp_bt_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable BT controller\n @return       ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_disable() -> esp_err_t;
}
#[doc = " @brief esp_vhci_host_callback\n  used for vhci call host function to notify what host need to do"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_vhci_host_callback {
    #[doc = "< callback used to notify that the host can send packet to controller"]
    pub notify_host_send_available: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "< callback used to notify that the controller has a packet to send to the host"]
    pub notify_host_recv: ::core::option::Option<
        unsafe extern "C" fn(data: *mut u8, len: u16) -> crate::c_types::c_int,
    >,
}
#[doc = " @brief esp_vhci_host_callback\n  used for vhci call host function to notify what host need to do"]
pub type esp_vhci_host_callback_t = esp_vhci_host_callback;
extern "C" {
    #[doc = " @brief esp_vhci_host_check_send_available\n  used for check actively if the host can send packet to controller or not.\n  @return true for ready to send, false means cannot send packet"]
    pub fn esp_vhci_host_check_send_available() -> bool;
}
extern "C" {
    #[doc = " @brief esp_vhci_host_send_packet\n host send packet to controller\n\n Should not call this function from within a critical section\n or when the scheduler is suspended.\n\n @param data the packet point\n @param len the packet length"]
    pub fn esp_vhci_host_send_packet(data: *mut u8, len: u16);
}
extern "C" {
    #[doc = " @brief esp_vhci_host_register_callback\n register the vhci reference callback\n struct defined by vhci_host_callback structure.\n @param callback esp_vhci_host_callback type variable\n @return ESP_OK - success, ESP_FAIL - failed"]
    pub fn esp_vhci_host_register_callback(callback: *const esp_vhci_host_callback_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief esp_bt_controller_mem_release\n release the controller memory as per the mode\n\n This function releases the BSS, data and other sections of the controller to heap. The total size is about 70k bytes.\n\n esp_bt_controller_mem_release(mode) should be called only before esp_bt_controller_init()\n or after esp_bt_controller_deinit().\n\n Note that once BT controller memory is released, the process cannot be reversed. It means you cannot use the bluetooth\n mode which you have released by this function.\n\n If your firmware will later upgrade the Bluetooth controller mode (BLE -> BT Classic or disabled -> enabled)\n then do not call this function.\n\n If the app calls esp_bt_controller_enable(ESP_BT_MODE_BLE) to use BLE only then it is safe to call\n esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT) at initialization time to free unused BT Classic memory.\n\n If the mode is ESP_BT_MODE_BTDM, then it may be useful to call API esp_bt_mem_release(ESP_BT_MODE_BTDM) instead,\n which internally calls esp_bt_controller_mem_release(ESP_BT_MODE_BTDM) and additionally releases the BSS and data\n consumed by the BT/BLE host stack to heap. For more details about usage please refer to the documentation of\n esp_bt_mem_release() function\n\n @param mode : the mode want to release memory\n @return ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_mem_release(mode: esp_bt_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief esp_bt_mem_release\n release controller memory and BSS and data section of the BT/BLE host stack as per the mode\n\n This function first releases controller memory by internally calling esp_bt_controller_mem_release().\n Additionally, if the mode is set to ESP_BT_MODE_BTDM, it also releases the BSS and data consumed by the BT/BLE host stack to heap\n\n Note that once BT memory is released, the process cannot be reversed. It means you cannot use the bluetooth\n mode which you have released by this function.\n\n If your firmware will later upgrade the Bluetooth controller mode (BLE -> BT Classic or disabled -> enabled)\n then do not call this function.\n\n If you never intend to use bluetooth in a current boot-up cycle, you can call esp_bt_mem_release(ESP_BT_MODE_BTDM)\n before esp_bt_controller_init or after esp_bt_controller_deinit.\n\n For example, if a user only uses bluetooth for setting the WiFi configuration, and does not use bluetooth in the rest of the product operation\".\n In such cases, after receiving the WiFi configuration, you can disable/deinit bluetooth and release its memory.\n Below is the sequence of APIs to be called for such scenarios:\n\n      esp_bluedroid_disable();\n      esp_bluedroid_deinit();\n      esp_bt_controller_disable();\n      esp_bt_controller_deinit();\n      esp_bt_mem_release(ESP_BT_MODE_BTDM);\n\n @param mode : the mode whose memory is to be released\n @return ESP_OK - success, other - failed"]
    pub fn esp_bt_mem_release(mode: esp_bt_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns random static address or -1 if not present.\n @return ESP_OK - success, other - failed"]
    pub fn esp_ble_hw_get_static_addr(addr: *mut esp_ble_addr_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn esp_bt_get_lpclk_src() -> modem_clock_lpclk_src_t;
}
extern "C" {
    pub fn esp_bt_set_lpclk_src(clk_src: modem_clock_lpclk_src_t);
}
extern "C" {
    pub fn esp_bt_get_lpclk_freq() -> u32;
}
extern "C" {
    pub fn esp_bt_set_lpclk_freq(clk_freq: u32);
}
#[doc = "< Prefer to WiFi, WiFi will have more opportunity to use RF"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_WIFI: esp_coex_prefer_t = 0;
#[doc = "< Prefer to bluetooth, bluetooth will have more opportunity to use RF"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_BT: esp_coex_prefer_t = 1;
#[doc = "< Do balance of WiFi and bluetooth"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_BALANCE: esp_coex_prefer_t = 2;
#[doc = "< Prefer value numbers"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_NUM: esp_coex_prefer_t = 3;
#[doc = " @brief coex prefer value"]
pub type esp_coex_prefer_t = crate::c_types::c_uint;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_1: external_coex_wire_t = 0;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_2: external_coex_wire_t = 1;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_3: external_coex_wire_t = 2;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_4: external_coex_wire_t = 3;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_NUM: external_coex_wire_t = 4;
pub type external_coex_wire_t = crate::c_types::c_uint;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_WIFI: esp_coex_status_type_t = 0;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_BLE: esp_coex_status_type_t = 1;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_BT: esp_coex_status_type_t = 2;
#[doc = " @brief coex status type"]
pub type esp_coex_status_type_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief Get software coexist version string\n\n @return : version string"]
    pub fn esp_coex_version_get() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @deprecated Use esp_coex_status_bit_set() and esp_coex_status_bit_clear() instead.\n  Set coexist preference of performance\n  For example, if prefer to bluetooth, then it will make A2DP(play audio via classic bt)\n  more smooth while wifi is running something.\n  If prefer to wifi, it will do similar things as prefer to bluetooth.\n  Default, it prefer to balance.\n\n  @param prefer : the prefer enumeration value\n  @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_preference_set(prefer: esp_coex_prefer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set coex schm status\n @param type : WIFI/BLE/BT\n @param status : WIFI/BLE/BT STATUS\n @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_status_bit_set(type_: esp_coex_status_type_t, status: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear coex schm status\n @param type : WIFI/BLE/BT\n @param status : WIFI/BLE/BT STATUS\n @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_status_bit_clear(type_: esp_coex_status_type_t, status: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable Wi-Fi and 802.15.4 coexistence.\n @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_wifi_i154_enable() -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct coex_adapter_funcs_t {
    pub _version: i32,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create: ::core::option::Option<
        unsafe extern "C" fn(max: u32, init: u32) -> *mut crate::c_types::c_void,
    >,
    pub _semphr_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void)>,
    pub _semphr_take_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            semphr: *mut crate::c_types::c_void,
            hptw: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _semphr_give_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            semphr: *mut crate::c_types::c_void,
            hptw: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut crate::c_types::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void) -> i32>,
    pub _is_in_isr: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut crate::c_types::c_void)>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _env_is_chip: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _timer_disarm:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut crate::c_types::c_void)>,
    pub _timer_done:
        ::core::option::Option<unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut crate::c_types::c_void,
            pfunction: *mut crate::c_types::c_void,
            parg: *mut crate::c_types::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void, us: u32, repeat: bool),
    >,
    pub _debug_matrix_init: ::core::option::Option<
        unsafe extern "C" fn(
            event: crate::c_types::c_int,
            signal: crate::c_types::c_int,
            rev: bool,
        ) -> crate::c_types::c_int,
    >,
    pub _xtal_freq_get: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _magic: i32,
}
extern "C" {
    pub static mut g_coex_adapter_funcs: coex_adapter_funcs_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct coex_version_t {
    pub major: u8,
    pub minor: u8,
    pub patch: u8,
}
pub const coex_prefer_t_COEX_PREFER_WIFI: coex_prefer_t = 0;
pub const coex_prefer_t_COEX_PREFER_BT: coex_prefer_t = 1;
pub const coex_prefer_t_COEX_PREFER_BALANCE: coex_prefer_t = 2;
pub const coex_prefer_t_COEX_PREFER_NUM: coex_prefer_t = 3;
pub type coex_prefer_t = crate::c_types::c_uint;
pub const coex_schm_callback_type_t_COEX_SCHM_CALLBACK_TYPE_WIFI: coex_schm_callback_type_t = 0;
pub const coex_schm_callback_type_t_COEX_SCHM_CALLBACK_TYPE_BT: coex_schm_callback_type_t = 1;
pub const coex_schm_callback_type_t_COEX_SCHM_CALLBACK_TYPE_I154: coex_schm_callback_type_t = 2;
pub type coex_schm_callback_type_t = crate::c_types::c_uint;
pub const coex_schm_st_type_t_COEX_SCHM_ST_TYPE_WIFI: coex_schm_st_type_t = 0;
pub const coex_schm_st_type_t_COEX_SCHM_ST_TYPE_BLE: coex_schm_st_type_t = 1;
pub const coex_schm_st_type_t_COEX_SCHM_ST_TYPE_BT: coex_schm_st_type_t = 2;
pub type coex_schm_st_type_t = crate::c_types::c_uint;
pub type coex_func_cb_t =
    ::core::option::Option<unsafe extern "C" fn(event: u32, sched_cnt: crate::c_types::c_int)>;
pub type coex_set_lpclk_source_callback_t =
    ::core::option::Option<unsafe extern "C" fn() -> esp_err_t>;
pub type coex_wifi_channel_change_cb_t =
    ::core::option::Option<unsafe extern "C" fn(primary: u8, secondary: u8)>;
extern "C" {
    #[doc = " @brief Pre-Init software coexist\n        extern function for internal use.\n\n @return Init ok or failed."]
    pub fn coex_pre_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Init software coexist\n        extern function for internal use.\n\n @return Init ok or failed."]
    pub fn coex_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-init software coexist\n        extern function for internal use."]
    pub fn coex_deinit();
}
extern "C" {
    #[doc = " @brief Enable software coexist\n        extern function for internal use.\n\n @return Enable ok or failed."]
    pub fn coex_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable software coexist\n        extern function for internal use."]
    pub fn coex_disable();
}
extern "C" {
    #[doc = " @brief Get software coexist version string\n        extern function for internal use.\n @return : version string"]
    pub fn coex_version_get() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief Get software coexist version value\n        extern function for internal use.\n @param ptr_version : points to version structure\n @return : ESP_OK - success, other - failed"]
    pub fn coex_version_get_value(ptr_version: *mut coex_version_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Coexist performance preference set from libbt.a\n        extern function for internal use.\n\n  @param prefer : the prefer enumeration value\n  @return : ESP_OK - success, other - failed"]
    pub fn coex_preference_set(prefer: coex_prefer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get software coexist status.\n\n @param bitmap : bitmap of the module getting status.\n @return : software coexist status"]
    pub fn coex_status_get(bitmap: u8) -> u32;
}
extern "C" {
    #[doc = " @brief WiFi requests coexistence.\n\n  @param event : WiFi event\n  @param latency : WiFi will request coexistence after latency\n  @param duration : duration for WiFi to request coexistence\n  @return : 0 - success, other - failed"]
    pub fn coex_wifi_request(event: u32, latency: u32, duration: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief WiFi release coexistence.\n\n  @param event : WiFi event\n  @return : 0 - success, other - failed"]
    pub fn coex_wifi_release(event: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Set WiFi channel to coexistence module.\n\n  @param primary : WiFi primary channel\n  @param secondary : WiFi secondary channel\n  @return : 0 - success, other - failed"]
    pub fn coex_wifi_channel_set(primary: u8, secondary: u8) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get WiFi channel from coexistence module.\n\n  @param primary : pointer to value of WiFi primary channel\n  @param secondary : pointer to value of WiFi secondary channel\n  @return : 0 - success, other - failed"]
    pub fn coex_wifi_channel_get(primary: *mut u8, secondary: *mut u8) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Register application callback function to Wi-Fi update low power clock module.\n\n @param callback : Wi-Fi update low power clock callback function"]
    pub fn coex_wifi_register_update_lpclk_callback(callback: coex_set_lpclk_source_callback_t);
}
extern "C" {
    #[doc = " @brief Bluetooth requests coexistence\n\n  @param event : Bluetooth event\n  @param latency : Bluetooth will request coexistence after latency\n  @param duration : duration for Bluetooth to request coexistence\n  @return : 0 - success, other - failed"]
    pub fn coex_bt_request(event: u32, latency: u32, duration: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Bluetooth release coexistence.\n\n  @param event : Bluetooth event\n  @return : 0 - success, other - failed"]
    pub fn coex_bt_release(event: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Bluetooth registers callback function to receive notification when Wi-Fi channel changes\n\n  @param callback: callback function registered to coexistence module\n  @return : 0 - success, other - failed"]
    pub fn coex_register_wifi_channel_change_callback(
        callback: coex_wifi_channel_change_cb_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Update low power clock interval"]
    pub fn coex_update_lpclk_interval();
}
extern "C" {
    #[doc = " @brief Get coexistence event duration.\n\n  @param event : Coexistence event\n  @param duration: Coexistence event duration\n  @return : 0 - success, other - failed"]
    pub fn coex_event_duration_get(event: u32, duration: *mut u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get coexistence event priority.\n\n  @param event : Coexistence event\n  @param pti: Coexistence event priority\n  @return : 0 - success, other - failed"]
    pub fn coex_pti_get(event: u32, pti: *mut u8) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Clear coexistence status.\n\n  @param type : Coexistence status type\n  @param status: Coexistence status"]
    pub fn coex_schm_status_bit_clear(type_: u32, status: u32);
}
extern "C" {
    #[doc = " @brief Set coexistence status.\n\n  @param type : Coexistence status type\n  @param status: Coexistence status"]
    pub fn coex_schm_status_bit_set(type_: u32, status: u32);
}
extern "C" {
    #[doc = " @brief Set coexistence scheme interval.\n\n  @param interval : Coexistence scheme interval\n  @return : 0 - success, other - failed"]
    pub fn coex_schm_interval_set(interval: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get coexistence scheme interval.\n\n  @return : Coexistence scheme interval"]
    pub fn coex_schm_interval_get() -> u32;
}
extern "C" {
    #[doc = " @brief Get current coexistence scheme period.\n\n  @return : Coexistence scheme period"]
    pub fn coex_schm_curr_period_get() -> u8;
}
extern "C" {
    #[doc = " @brief Get current coexistence scheme phase.\n\n  @return : Coexistence scheme phase"]
    pub fn coex_schm_curr_phase_get() -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief Set current coexistence scheme phase index.\n\n  @param idx : Coexistence scheme phase index\n  @return : 0 - success, other - failed"]
    pub fn coex_schm_curr_phase_idx_set(idx: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get current coexistence scheme phase index.\n\n  @return : Coexistence scheme phase index"]
    pub fn coex_schm_curr_phase_idx_get() -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Register WiFi callback for coexistence starts.\n\n  @param cb : WiFi callback\n  @return : 0 - success, other - failed"]
    pub fn coex_register_start_cb(
        cb: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Restart current coexistence scheme.\n\n  @return : 0 - success, other - failed"]
    pub fn coex_schm_process_restart() -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Register callback for coexistence scheme.\n\n  @param type : callback type\n  @param callback : callback\n  @return : 0 - success, other - failed"]
    pub fn coex_schm_register_callback(
        type_: coex_schm_callback_type_t,
        callback: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Register coexistence adapter functions.\n\n  @param funcs : coexistence adapter functions\n  @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_adapter_register(funcs: *mut coex_adapter_funcs_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get coexistence scheme phase by phase index.\n\n @param     phase_idx    Coexistence phase index\n\n @return    Coexistence scheme phase"]
    pub fn coex_schm_get_phase_by_idx(
        phase_idx: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the coexistence adapter header files in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_coex_adapter_funcs_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
pub const ieee802154_coex_event_t_IEEE802154_HIGH: ieee802154_coex_event_t = 1;
pub const ieee802154_coex_event_t_IEEE802154_MIDDLE: ieee802154_coex_event_t = 2;
pub const ieee802154_coex_event_t_IEEE802154_LOW: ieee802154_coex_event_t = 3;
pub const ieee802154_coex_event_t_IEEE802154_IDLE: ieee802154_coex_event_t = 4;
pub const ieee802154_coex_event_t_IEEE802154_EVENT_MAX: ieee802154_coex_event_t = 5;
pub type ieee802154_coex_event_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_ieee802154_coex_config_t {
    pub idle: ieee802154_coex_event_t,
    pub txrx: ieee802154_coex_event_t,
    pub txrx_at: ieee802154_coex_event_t,
}
extern "C" {
    pub fn esp_coex_ieee802154_txrx_pti_set(event: ieee802154_coex_event_t);
}
extern "C" {
    pub fn esp_coex_ieee802154_ack_pti_set(event: ieee802154_coex_event_t);
}
extern "C" {
    pub fn esp_coex_ieee802154_coex_break_notify();
}
extern "C" {
    pub fn esp_coex_ieee802154_extcoex_tx_stage();
}
extern "C" {
    pub fn esp_coex_ieee802154_extcoex_rx_stage();
}
#[doc = "< Send ESPNOW data successfully"]
pub const esp_now_send_status_t_ESP_NOW_SEND_SUCCESS: esp_now_send_status_t = 0;
#[doc = "< Send ESPNOW data fail"]
pub const esp_now_send_status_t_ESP_NOW_SEND_FAIL: esp_now_send_status_t = 1;
#[doc = " @brief Status of sending ESPNOW data ."]
pub type esp_now_send_status_t = crate::c_types::c_uint;
#[doc = " @brief ESPNOW peer information parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_peer_info {
    #[doc = "< ESPNOW peer MAC address that is also the MAC address of station or softap"]
    pub peer_addr: [u8; 6usize],
    #[doc = "< ESPNOW peer local master key that is used to encrypt data"]
    pub lmk: [u8; 16usize],
    #[doc = "< Wi-Fi channel that peer uses to send/receive ESPNOW data. If the value is 0,\nuse the current channel which station or softap is on. Otherwise, it must be\nset as the channel that station or softap is on."]
    pub channel: u8,
    #[doc = "< Wi-Fi interface that peer uses to send/receive ESPNOW data"]
    pub ifidx: wifi_interface_t,
    #[doc = "< ESPNOW data that this peer sends/receives is encrypted or not"]
    pub encrypt: bool,
    #[doc = "< ESPNOW peer private data"]
    pub priv_: *mut crate::c_types::c_void,
}
#[doc = " @brief ESPNOW peer information parameters."]
pub type esp_now_peer_info_t = esp_now_peer_info;
#[doc = " @brief Number of ESPNOW peers which exist currently."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_peer_num {
    #[doc = "< Total number of ESPNOW peers, maximum value is ESP_NOW_MAX_TOTAL_PEER_NUM"]
    pub total_num: crate::c_types::c_int,
    #[doc = "< Number of encrypted ESPNOW peers, maximum value is ESP_NOW_MAX_ENCRYPT_PEER_NUM"]
    pub encrypt_num: crate::c_types::c_int,
}
#[doc = " @brief Number of ESPNOW peers which exist currently."]
pub type esp_now_peer_num_t = esp_now_peer_num;
#[doc = " @brief ESPNOW receive packet information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_recv_info {
    #[doc = "< Source address of ESPNOW packet"]
    pub src_addr: *mut u8,
    #[doc = "< Destination address of ESPNOW packet"]
    pub des_addr: *mut u8,
    #[doc = "< Rx control info of ESPNOW packet"]
    pub rx_ctrl: *mut wifi_pkt_rx_ctrl_t,
}
#[doc = " @brief ESPNOW receive packet information"]
pub type esp_now_recv_info_t = esp_now_recv_info;
#[doc = " @brief ESPNOW sending packet information"]
pub type esp_now_send_info_t = wifi_tx_info_t;
#[doc = " @brief ESPNOW rate config"]
pub type esp_now_rate_config_t = wifi_tx_rate_config_t;
#[doc = " @brief     Callback function of receiving ESPNOW data\n @param     esp_now_info received ESPNOW packet information\n @param     data received data\n @param     data_len length of received data\n @attention esp_now_info is a local variable，it can only be used in the callback."]
pub type esp_now_recv_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        esp_now_info: *const esp_now_recv_info_t,
        data: *const u8,
        data_len: crate::c_types::c_int,
    ),
>;
#[doc = " @brief     Callback function of sending ESPNOW data\n @param     tx_info Sending information for ESPNOW data\n @param     status status of sending ESPNOW data (succeed or fail). This is will be removed later, since the tx_info->tx_status also works."]
pub type esp_now_send_cb_t = ::core::option::Option<
    unsafe extern "C" fn(tx_info: *const esp_now_send_info_t, status: esp_now_send_status_t),
>;
extern "C" {
    #[doc = " @brief     Initialize ESPNOW function\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_INTERNAL : Internal error"]
    pub fn esp_now_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize ESPNOW function\n\n @return\n          - ESP_OK : succeed"]
    pub fn esp_now_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the version of ESPNOW. Currently, ESPNOW supports two versions: v1.0 and v2.0.\n\n            The v2.0 devices are capable of receiving packets from both v2.0 and v1.0 devices. In contrast, v1.0 devices can only receive packets from other v1.0 devices.\n            However, v1.0 devices can receive v2.0 packets if the packet length is less than or equal to ESP_NOW_MAX_IE_DATA_LEN.\n            For packets exceeding this length, the v1.0 devices will either truncate the data to the first ESP_NOW_MAX_IE_DATA_LEN bytes or discard the packet entirely.\n            For detailed behavior, please refer to the documentation corresponding to the specific IDF version.\n\n @param     version  ESPNOW version\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_version(version: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of receiving ESPNOW data\n\n @param     cb  callback function of receiving ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_recv_cb(cb: esp_now_recv_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of receiving ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_recv_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of sending ESPNOW data\n\n @param     cb  callback function of sending ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_send_cb(cb: esp_now_send_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of sending ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_send_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send ESPNOW data\n\n @attention 1. If peer_addr is not NULL, send data to the peer whose MAC address matches peer_addr\n @attention 2. If peer_addr is NULL, send data to all of the peers that are added to the peer list\n @attention 3. The maximum length of data must be less than ESP_NOW_MAX_DATA_LEN\n @attention 4. The buffer pointed to by data argument does not need to be valid after esp_now_send returns\n\n @param     peer_addr  peer MAC address\n @param     data  data to send\n @param     len  length of data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_INTERNAL : internal error\n          - ESP_ERR_ESPNOW_NO_MEM : out of memory, when this happens, you can delay a while before sending the next data\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found\n          - ESP_ERR_ESPNOW_IF : current Wi-Fi interface doesn't match that of peer\n          - ESP_ERR_ESPNOW_CHAN: current Wi-Fi channel doesn't match that of peer"]
    pub fn esp_now_send(peer_addr: *const u8, data: *const u8, len: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Add a peer to peer list\n\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_FULL : peer list is full\n          - ESP_ERR_ESPNOW_NO_MEM : out of memory\n          - ESP_ERR_ESPNOW_EXIST : peer has existed"]
    pub fn esp_now_add_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Delete a peer from peer list\n\n @param     peer_addr  peer MAC address\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_del_peer(peer_addr: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Modify a peer\n\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_FULL : peer list is full"]
    pub fn esp_now_mod_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config ESPNOW rate of specified interface\n\n @deprecated please use esp_now_set_peer_rate_config() instead.\n\n @attention  1. This API should be called after esp_wifi_start().\n @attention  2. This API only work when not use Wi-Fi 6 and esp_now_set_peer_rate_config() not called.\n\n @param      ifx  Interface to be configured.\n @param      rate Phy rate to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_espnow_rate(ifx: wifi_interface_t, rate: wifi_phy_rate_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set ESPNOW rate config for each peer\n\n @attention  1. This API should be called after esp_wifi_start() and esp_now_init().\n\n @param      peer_addr  peer MAC address\n @param      config rate config to be configured.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_set_peer_rate_config(
        peer_addr: *const u8,
        config: *mut esp_now_rate_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get a peer whose MAC address matches peer_addr from peer list\n\n @param     peer_addr  peer MAC address\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_get_peer(peer_addr: *const u8, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Fetch a peer from peer list. Only return the peer which address is unicast, for the multicast/broadcast address, the function will ignore and try to find the next in the peer list.\n\n @param     from_head  fetch from head of list or not\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_fetch_peer(from_head: bool, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Peer exists or not\n\n @param     peer_addr  peer MAC address\n\n @return\n          - true : peer exists\n          - false : peer not exists"]
    pub fn esp_now_is_peer_exist(peer_addr: *const u8) -> bool;
}
extern "C" {
    #[doc = " @brief     Get the number of peers\n\n @param     num  number of peers\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_peer_num(num: *mut esp_now_peer_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the primary master key\n\n @param     pmk  primary master key\n\n @attention 1. primary master key is used to encrypt local master key\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_set_pmk(pmk: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set wake window for esp_now to wake up in interval unit\n\n @param     window  Milliseconds would the chip keep waked each interval, from 0 to 65535.\n\n @attention 1. This configuration could work at connected status.\n               When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status.\n @attention 2. Default value is the maximum.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_set_wake_window(window: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the OUI (Organization Identifier) in the vendor-specific element for ESPNOW.\n\n @param     oui  The oui should occupy 3 bytes. If the oui is NULL, then use the default value (0x18fe34).\n\n @return\n          - ESP_OK : succeed"]
    pub fn esp_now_set_user_oui(oui: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the OUI (Organization Identifier) in the vendor-specific element for ESPNOW.\n\n @param     oui  user configured OUI.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_user_oui(oui: *mut u8) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_adpt {
    pub _address: u8,
}
pub type __builtin_va_list = *mut crate::c_types::c_void;

unsafe impl Sync for wifi_init_config_t {}
unsafe impl Sync for wifi_osi_funcs_t {}
