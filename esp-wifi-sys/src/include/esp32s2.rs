/* automatically generated by rust-bindgen 0.66.1 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NANO_MALLOC: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_BACKWARD_BINARY_COMPAT: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const CONFIG_SOC_ADC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DAC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TWAI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CP_DMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEDICATED_GPIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORTS_SECURE_DL_MODE: u32 = 1;
pub const CONFIG_SOC_ULP_FSM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RISCV_COPROC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_USB_OTG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PCNT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PHY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ULP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CCOMP_TIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD: u32 = 1;
pub const CONFIG_SOC_EFUSE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TEMP_SENSOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CACHE_SUPPORT_WRAP: u32 = 1;
pub const CONFIG_SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_SLOW_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PSRAM_DMA_CAPABLE: u32 = 1;
pub const CONFIG_SOC_XT_WDT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPSPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_HMAC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DIG_SIGN_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMPROT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TOUCH_SENSOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BOD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_TREE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPU_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WDT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_FLASH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RNG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LIGHT_SLEEP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEEP_SLEEP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LP_PERIPH_SHARE_INTERRUPT: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const CONFIG_SOC_ADC_RTC_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_ARBITER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_IIR_FILTER_UNIT_BINDED: u32 = 1;
pub const CONFIG_SOC_ADC_MONITOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_MAX_CHANNEL_NUM: u32 = 10;
pub const CONFIG_SOC_ADC_ATTEN_NUM: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_PATT_LEN_MAX: u32 = 32;
pub const CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_RESULT_BYTES: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_MONITOR_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 83333;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 611;
pub const CONFIG_SOC_ADC_RTC_MIN_BITWIDTH: u32 = 13;
pub const CONFIG_SOC_ADC_RTC_MAX_BITWIDTH: u32 = 13;
pub const CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_SHARED_POWER: u32 = 1;
pub const CONFIG_SOC_BROWNOUT_RESET_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CACHE_WRITEBACK_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CP_DMA_MAX_BUFFER_SIZE: u32 = 4095;
pub const CONFIG_SOC_CPU_CORES_NUM: u32 = 1;
pub const CONFIG_SOC_CPU_INTR_NUM: u32 = 32;
pub const CONFIG_SOC_CPU_BREAKPOINTS_NUM: u32 = 2;
pub const CONFIG_SOC_CPU_WATCHPOINTS_NUM: u32 = 2;
pub const CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE: u32 = 64;
pub const CONFIG_SOC_DAC_CHAN_NUM: u32 = 2;
pub const CONFIG_SOC_DAC_RESOLUTION: u32 = 8;
pub const CONFIG_SOC_GPIO_PORT: u32 = 1;
pub const CONFIG_SOC_GPIO_PIN_COUNT: u32 = 47;
pub const CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER: u32 = 1;
pub const CONFIG_SOC_GPIO_FILTER_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_RTC_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD: u32 = 1;
pub const CONFIG_SOC_GPIO_VALID_GPIO_MASK: u64 = 140737488355327;
pub const CONFIG_SOC_GPIO_IN_RANGE_MAX: u32 = 46;
pub const CONFIG_SOC_GPIO_OUT_RANGE_MAX: u32 = 45;
pub const CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u64 = 140737421246464;
pub const CONFIG_SOC_GPIO_CLOCKOUT_BY_IO_MUX: u32 = 1;
pub const CONFIG_SOC_GPIO_CLOCKOUT_CHANNEL_NUM: u32 = 3;
pub const CONFIG_SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP: u32 = 1;
pub const CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_GPIO_ALLOW_REG_ACCESS: u32 = 1;
pub const CONFIG_SOC_DEDIC_GPIO_HAS_INTERRUPT: u32 = 1;
pub const CONFIG_SOC_DEDIC_GPIO_OUT_AUTO_ENABLE: u32 = 1;
pub const CONFIG_SOC_I2C_NUM: u32 = 2;
pub const CONFIG_SOC_HP_I2C_NUM: u32 = 2;
pub const CONFIG_SOC_I2C_FIFO_LEN: u32 = 32;
pub const CONFIG_SOC_I2C_CMD_REG_NUM: u32 = 16;
pub const CONFIG_SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const CONFIG_SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_REF_TICK: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_I2S_NUM: u32 = 1;
pub const CONFIG_SOC_I2S_HW_VERSION_1: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_APLL: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PLL_F160M: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_DMA_EQUAL: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_LCD_CAMERA: u32 = 1;
pub const CONFIG_SOC_I2S_MAX_DATA_WIDTH: u32 = 24;
pub const CONFIG_SOC_I2S_APLL_MIN_FREQ: u32 = 250000000;
pub const CONFIG_SOC_I2S_APLL_MAX_FREQ: u32 = 500000000;
pub const CONFIG_SOC_I2S_APLL_MIN_RATE: u32 = 10675;
pub const CONFIG_SOC_I2S_LCD_I80_VARIANT: u32 = 1;
pub const CONFIG_SOC_LCD_I80_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LCD_I80_BUSES: u32 = 1;
pub const CONFIG_SOC_LCD_I80_BUS_WIDTH: u32 = 24;
pub const CONFIG_SOC_LEDC_HAS_TIMER_SPECIFIC_MUX: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_APB_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_REF_TICK: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_TIMER_NUM: u32 = 4;
pub const CONFIG_SOC_LEDC_CHANNEL_NUM: u32 = 8;
pub const CONFIG_SOC_LEDC_TIMER_BIT_WIDTH: u32 = 14;
pub const CONFIG_SOC_LEDC_SUPPORT_FADE_STOP: u32 = 1;
pub const CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM: u32 = 5;
pub const CONFIG_SOC_MMU_PERIPH_NUM: u32 = 1;
pub const CONFIG_SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const CONFIG_SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const CONFIG_SOC_PCNT_GROUPS: u32 = 1;
pub const CONFIG_SOC_PCNT_UNITS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_PCNT_CHANNELS_PER_UNIT: u32 = 2;
pub const CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT: u32 = 2;
pub const CONFIG_SOC_RMT_GROUPS: u32 = 1;
pub const CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_RMT_CHANNELS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 64;
pub const CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_REF_TICK: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_RMT_CHANNEL_CLK_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_RTCIO_PIN_COUNT: u32 = 22;
pub const CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_HOLD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_WAKE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LP_IO_CLOCK_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_SDM_GROUPS: u32 = 1;
pub const CONFIG_SOC_SDM_CHANNELS_PER_GROUP: u32 = 8;
pub const CONFIG_SOC_SDM_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_SPI_HD_BOTH_INOUT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_NUM: u32 = 3;
pub const CONFIG_SOC_SPI_DMA_CHAN_NUM: u32 = 3;
pub const CONFIG_SOC_SPI_MAX_CS_NUM: u32 = 6;
pub const CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 72;
pub const CONFIG_SOC_SPI_MAX_PRE_DIVIDER: u32 = 8192;
pub const CONFIG_SOC_SPI_SUPPORT_DDRCLK: u32 = 1;
pub const CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CD_SIG: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_APB: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_SUPPORT_CONTROL_DUMMY_OUT: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_OCT: u32 = 1;
pub const CONFIG_SOC_SPI_SCT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_SCT_REG_NUM: u32 = 27;
pub const CONFIG_SOC_SPI_SCT_BUFFER_NUM_MAX: u32 = 1;
pub const CONFIG_SOC_SPI_SCT_CONF_BITLEN_MAX: u32 = 8388605;
pub const CONFIG_SOC_MEMSPI_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_26M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_COUNTER_NUM: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_ALARM_NUM: u32 = 3;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO: u32 = 32;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI: u32 = 32;
pub const CONFIG_SOC_TIMER_GROUPS: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 64;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 4;
pub const CONFIG_SOC_LP_TIMER_BIT_WIDTH_LO: u32 = 32;
pub const CONFIG_SOC_LP_TIMER_BIT_WIDTH_HI: u32 = 16;
pub const CONFIG_SOC_TOUCH_SENSOR_VERSION: u32 = 2;
pub const CONFIG_SOC_TOUCH_SENSOR_NUM: u32 = 15;
pub const CONFIG_SOC_TOUCH_MIN_CHAN_ID: u32 = 1;
pub const CONFIG_SOC_TOUCH_MAX_CHAN_ID: u32 = 14;
pub const CONFIG_SOC_TOUCH_SUPPORT_BENCHMARK: u32 = 1;
pub const CONFIG_SOC_TOUCH_SUPPORT_SLEEP_WAKEUP: u32 = 1;
pub const CONFIG_SOC_TOUCH_SUPPORT_WATERPROOF: u32 = 1;
pub const CONFIG_SOC_TOUCH_SUPPORT_PROX_SENSING: u32 = 1;
pub const CONFIG_SOC_TOUCH_SUPPORT_DENOISE_CHAN: u32 = 1;
pub const CONFIG_SOC_TOUCH_PROXIMITY_CHANNEL_NUM: u32 = 3;
pub const CONFIG_SOC_TOUCH_SAMPLE_CFG_NUM: u32 = 1;
pub const CONFIG_SOC_TWAI_CONTROLLER_NUM: u32 = 1;
pub const CONFIG_SOC_TWAI_MASK_FILTER_NUM: u32 = 1;
pub const CONFIG_SOC_TWAI_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TWAI_BRP_MIN: u32 = 2;
pub const CONFIG_SOC_TWAI_BRP_MAX: u32 = 32768;
pub const CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS: u32 = 1;
pub const CONFIG_SOC_UART_NUM: u32 = 2;
pub const CONFIG_SOC_UART_HP_NUM: u32 = 2;
pub const CONFIG_SOC_UART_SUPPORT_WAKEUP_INT: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_APB_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_REF_TICK: u32 = 1;
pub const CONFIG_SOC_UART_FIFO_LEN: u32 = 128;
pub const CONFIG_SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const CONFIG_SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE: u32 = 1;
pub const CONFIG_SOC_SPIRAM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPIRAM_XIP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_USB_OTG_PERIPH_NUM: u32 = 1;
pub const CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE: u32 = 3968;
pub const CONFIG_SOC_SHA_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_RESUME: u32 = 1;
pub const CONFIG_SOC_SHA_CRYPTO_DMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA224: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA384: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512_224: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512_256: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512_T: u32 = 1;
pub const CONFIG_SOC_MPI_MEM_BLOCKS_NUM: u32 = 4;
pub const CONFIG_SOC_MPI_OPERATIONS_NUM: u32 = 3;
pub const CONFIG_SOC_RSA_MAX_BIT_LEN: u32 = 4096;
pub const CONFIG_SOC_AES_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_GCM: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DOWNLOAD_DCACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_HARD_DIS_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_SOFT_DIS_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_BOOT_REMAP: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_LEGACY_SPI_BOOT: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_ICACHE: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_V2_RSA: u32 = 1;
pub const CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 3;
pub const CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: u32 = 1;
pub const CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 64;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_OPTIONS: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_256: u32 = 1;
pub const CONFIG_SOC_MEMPROT_CPU_PREFETCH_PAD_SIZE: u32 = 16;
pub const CONFIG_SOC_MEMPROT_MEM_ALIGN_SIZE: u32 = 4;
pub const CONFIG_SOC_AES_CRYPTO_DMA: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_192: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 21;
pub const CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH: u32 = 12;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_WRAP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT0_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_TOUCH_SENSOR_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_WIFI_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RTC_FAST_MEM_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RTC_SLOW_MEM_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RC_FAST_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD: u32 = 1;
pub const CONFIG_SOC_CONFIGURABLE_VDDSDIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PM_MODEM_PD_BY_SW: u32 = 1;
pub const CONFIG_SOC_CLK_APLL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_RC_FAST_D256_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_SLOW_CLK_SUPPORT_RC_FAST_D256: u32 = 1;
pub const CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION: u32 = 1;
pub const CONFIG_SOC_CLK_XTAL32K_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_LP_FAST_SUPPORT_XTAL_D4: u32 = 1;
pub const CONFIG_SOC_COEX_HW_PTI: u32 = 1;
pub const CONFIG_SOC_EXTERNAL_COEX_LEADER_TX_LINE: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC: u32 = 1;
pub const CONFIG_SOC_WIFI_HW_TSF: u32 = 1;
pub const CONFIG_SOC_WIFI_FTM_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORT_VARIABLE_BEACON_WINDOW: u32 = 1;
pub const CONFIG_SOC_WIFI_NAN_SUPPORT: u32 = 1;
pub const CONFIG_SOC_ULP_HAS_ADC: u32 = 1;
pub const CONFIG_IDF_CMAKE: u32 = 1;
pub const CONFIG_IDF_TOOLCHAIN: &[u8; 4] = b"gcc\0";
pub const CONFIG_IDF_TOOLCHAIN_GCC: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH_XTENSA: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH: &[u8; 7] = b"xtensa\0";
pub const CONFIG_IDF_TARGET: &[u8; 8] = b"esp32s2\0";
pub const CONFIG_IDF_INIT_VERSION: &[u8; 6] = b"5.5.1\0";
pub const CONFIG_IDF_TARGET_ESP32S2: u32 = 1;
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 2;
pub const CONFIG_APP_BUILD_TYPE_APP_2NDBOOT: u32 = 1;
pub const CONFIG_APP_BUILD_GENERATE_BINARIES: u32 = 1;
pub const CONFIG_APP_BUILD_BOOTLOADER: u32 = 1;
pub const CONFIG_APP_BUILD_USE_FLASH_SECTIONS: u32 = 1;
pub const CONFIG_APP_REPRODUCIBLE_BUILD: u32 = 1;
pub const CONFIG_BOOTLOADER_PROJECT_VER: u32 = 1;
pub const CONFIG_BOOTLOADER_OFFSET_IN_FLASH: u32 = 4096;
pub const CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_VERSION_1: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_VERSION: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_INFO: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_LOG_TIMESTAMP_SOURCE_CPU_TICKS: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_MODE_TEXT_EN: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_MODE_TEXT: u32 = 1;
pub const CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT: u32 = 1;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_BOOTLOADER_RESERVE_RTC_SIZE: u32 = 0;
pub const CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED: u32 = 1;
pub const CONFIG_SECURE_BOOT_V2_PREFERRED: u32 = 1;
pub const CONFIG_SECURE_ROM_DL_MODE_ENABLED: u32 = 1;
pub const CONFIG_APP_RETRIEVE_LEN_ELF_SHA: u32 = 9;
pub const CONFIG_ESP_ROM_HAS_CRC_LE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_MZ_CRC32: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_UART_BUF_SWITCH: u32 = 1;
pub const CONFIG_ESP_ROM_NEEDS_SWSETUP_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_REGI2C_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB_NANO_FORMAT: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB_32BIT_TIME: u32 = 1;
pub const CONFIG_ESP_ROM_USB_OTG_NUM: u32 = 3;
pub const CONFIG_ESP_ROM_HAS_FLASH_COUNT_PAGES_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SW_FLOAT: u32 = 1;
pub const CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM: i32 = -1;
pub const CONFIG_ESP_ROM_SUPPORT_DEEP_SLEEP_WAKEUP_STUB: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_VPRINTF_FUNC: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_OUTPUT_TO_CHANNELS_FUNC: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_OUTPUT_PUTC_FUNC: u32 = 1;
pub const CONFIG_ESP_ROM_CONSOLE_OUTPUT_SECONDARY: u32 = 1;
pub const CONFIG_BOOT_ROM_LOG_ALWAYS_ON: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &[u8; 4] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_80M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &[u8; 4] = b"80m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &[u8; 4] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &[u8; 14] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &[u8; 11] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &[u8; 15] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &[u8; 25] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT: u32 = 1;
pub const CONFIG_COMPILER_ASSERT_NDEBUG_EVALUATE: u32 = 1;
pub const CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT: u32 = 1;
pub const CONFIG_COMPILER_HIDE_PATHS_MACROS: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_COMPILER_DISABLE_DEFAULT_ERRORS: u32 = 1;
pub const CONFIG_COMPILER_RT_LIB_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_RT_LIB_NAME: &[u8; 4] = b"gcc\0";
pub const CONFIG_COMPILER_ORPHAN_SECTIONS_WARNING: u32 = 1;
pub const CONFIG_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_UART_NONE: u32 = 1;
pub const CONFIG_APPTRACE_UART_TASK_PRIO: u32 = 1;
pub const CONFIG_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_TWAI_ERRATA_FIX_LISTEN_ONLY_DOM: u32 = 1;
pub const CONFIG_ADC_DISABLE_DAC: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 256;
pub const CONFIG_ESP_TLS_USING_MBEDTLS: u32 = 1;
pub const CONFIG_ESP_TLS_USE_DS_PERIPHERAL: u32 = 1;
pub const CONFIG_ESP_TLS_DYN_BUF_STRATEGY_SUPPORTED: u32 = 1;
pub const CONFIG_ADC_DISABLE_DAC_OUTPUT: u32 = 1;
pub const CONFIG_ESP_COEX_ENABLED: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_GPTIMER_OBJ_CACHE_SAFE: u32 = 1;
pub const CONFIG_I2C_MASTER_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_RMT_ENCODER_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_RMT_TX_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_RMT_RX_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_RMT_OBJ_CACHE_SAFE: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_ETH_ENABLED: u32 = 1;
pub const CONFIG_ETH_USE_SPI_ETHERNET: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_ENABLED: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_SUPPORT_TASKS: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_MAX_TASKS: u32 = 32;
pub const CONFIG_ESPHID_TASK_SIZE_BT: u32 = 2048;
pub const CONFIG_ESPHID_TASK_SIZE_BLE: u32 = 4096;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_ESP_HTTP_CLIENT_EVENT_POST_TIMEOUT: u32 = 2000;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 1024;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_HTTPD_PURGE_BUF_LEN: u32 = 32;
pub const CONFIG_HTTPD_SERVER_EVENT_POST_TIMEOUT: u32 = 2000;
pub const CONFIG_ESP_HTTPS_OTA_EVENT_POST_TIMEOUT: u32 = 2000;
pub const CONFIG_ESP_HTTPS_SERVER_EVENT_POST_TIMEOUT: u32 = 2000;
pub const CONFIG_ESP32S2_REV_MIN_0: u32 = 1;
pub const CONFIG_ESP32S2_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP32S2_REV_MAX_FULL: u32 = 199;
pub const CONFIG_ESP_REV_MAX_FULL: u32 = 199;
pub const CONFIG_ESP_EFUSE_BLOCK_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP_EFUSE_BLOCK_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP: u32 = 1;
pub const CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_TWO: u32 = 1;
pub const CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES: u32 = 2;
pub const CONFIG_ESP32S2_UNIVERSAL_MAC_ADDRESSES_TWO: u32 = 1;
pub const CONFIG_ESP32S2_UNIVERSAL_MAC_ADDRESSES: u32 = 2;
pub const CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_RTC_BUS_ISO_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY: u32 = 0;
pub const CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS: u32 = 1;
pub const CONFIG_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_RTC_CLK_CAL_CYCLES: u32 = 576;
pub const CONFIG_ESP_PERIPH_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_REGI2C_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_XTAL_FREQ: u32 = 40;
pub const CONFIG_ESP_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP_BROWNOUT_USE_INTR: u32 = 1;
pub const CONFIG_ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_INTR_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_ESP_NETIF_TCPIP_LWIP: u32 = 1;
pub const CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API: u32 = 1;
pub const CONFIG_ESP_NETIF_REPORT_DATA_TRAFFIC: u32 = 1;
pub const CONFIG_ESP_PHY_ENABLED: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_RF_CAL_PARTIAL: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_MODE: u32 = 0;
pub const CONFIG_ESP_PHY_PLL_TRACK_PERIOD_MS: u32 = 1000;
pub const CONFIG_ESP_PHY_IRAM_OPT: u32 = 1;
pub const CONFIG_PM_SLEEP_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_PM_SLP_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_ROM_PRINT_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP32S2_INSTRUCTION_CACHE_8KB: u32 = 1;
pub const CONFIG_ESP32S2_INSTRUCTION_CACHE_SIZE: u32 = 8192;
pub const CONFIG_ESP32S2_INSTRUCTION_CACHE_LINE_32B: u32 = 1;
pub const CONFIG_ESP32S2_DATA_CACHE_8KB: u32 = 1;
pub const CONFIG_ESP32S2_DATA_CACHE_SIZE: u32 = 8192;
pub const CONFIG_ESP32S2_DATA_CACHE_LINE_32B: u32 = 1;
pub const CONFIG_ESP32S2_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_ESP_SYSTEM_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS: u32 = 0;
pub const CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_MEMPROT_FEATURE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_TASK_WDT_EN: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_INIT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4: u32 = 1;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_ESP_TIMER_IN_IRAM: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_TIMER_INTERRUPT_LEVEL: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_TIMER_IMPL_SYSTIMER: u32 = 1;
pub const CONFIG_ESP_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER: u32 = 1;
pub const CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF: u32 = 0;
pub const CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM_DEF: u32 = 5;
pub const CONFIG_ESP_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_MIN_ACTIVE_TIME: u32 = 50;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_MAX_ACTIVE_TIME: u32 = 10;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_WAIT_BROADCAST_DATA_TIME: u32 = 15;
pub const CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE: u32 = 1;
pub const CONFIG_ESP_WIFI_GMAC_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM: u32 = 7;
pub const CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT: u32 = 1;
pub const CONFIG_ESP_COREDUMP_ENABLE_TO_NONE: u32 = 1;
pub const CONFIG_FATFS_VOLUME_COUNT: u32 = 2;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_SECTOR_4096: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FATFS_USE_STRFUNC_NONE: u32 = 1;
pub const CONFIG_FATFS_VFS_FSTAT_BLKSIZE: u32 = 0;
pub const CONFIG_FATFS_LINK_LOCK: u32 = 1;
pub const CONFIG_FATFS_DONT_TRUST_FREE_CLUSTER_CNT: u32 = 0;
pub const CONFIG_FATFS_DONT_TRUST_LAST_ALLOC: u32 = 0;
pub const CONFIG_FREERTOS_UNICORE: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_OPTIMIZED_SCHEDULER: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_USE_TIMERS: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME: &[u8; 8] = b"Tmr Svc\0";
pub const CONFIG_FREERTOS_TIMER_TASK_NO_AFFINITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_SERVICE_TASK_CORE_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 1;
pub const CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_TICK_SUPPORT_CORETIMER: u32 = 1;
pub const CONFIG_FREERTOS_CORETIMER_0: u32 = 1;
pub const CONFIG_FREERTOS_SYSTICK_USES_CCOUNT: u32 = 1;
pub const CONFIG_FREERTOS_PORT: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const CONFIG_FREERTOS_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT: u32 = 1;
pub const CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH: u32 = 1;
pub const CONFIG_FREERTOS_NUMBER_OF_CORES: u32 = 1;
pub const CONFIG_FREERTOS_IN_IRAM: u32 = 1;
pub const CONFIG_HAL_ASSERTION_EQUALS_SYSTEM: u32 = 1;
pub const CONFIG_HAL_DEFAULT_ASSERTION_LEVEL: u32 = 1;
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_HEAP_TRACING_OFF: u32 = 1;
pub const CONFIG_LOG_VERSION_1: u32 = 1;
pub const CONFIG_LOG_VERSION: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT: u32 = 1;
pub const CONFIG_LOG_MAXIMUM_LEVEL: u32 = 3;
pub const CONFIG_LOG_DYNAMIC_LEVEL_CONTROL: u32 = 1;
pub const CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_AND_LINKED_LIST: u32 = 1;
pub const CONFIG_LOG_TAG_LEVEL_CACHE_BINARY_MIN_HEAP: u32 = 1;
pub const CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_SIZE: u32 = 31;
pub const CONFIG_LOG_TIMESTAMP_SOURCE_RTOS: u32 = 1;
pub const CONFIG_LOG_MODE_TEXT_EN: u32 = 1;
pub const CONFIG_LOG_MODE_TEXT: u32 = 1;
pub const CONFIG_LOG_IN_IRAM: u32 = 1;
pub const CONFIG_LWIP_ENABLE: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &[u8; 10] = b"espressif\0";
pub const CONFIG_LWIP_TCPIP_TASK_PRIO: u32 = 18;
pub const CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 1;
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_ND6: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_IP_DEFAULT_TTL: u32 = 64;
pub const CONFIG_LWIP_IP4_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP6_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP_REASS_MAX_PBUFS: u32 = 10;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_ESP_MLDV6_REPORT: u32 = 1;
pub const CONFIG_LWIP_MLDV6_TMR_INTERVAL: u32 = 40;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID: u32 = 1;
pub const CONFIG_LWIP_DHCP_OPTIONS_LEN: u32 = 69;
pub const CONFIG_LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const CONFIG_LWIP_DHCP_COARSE_TIMER_SECS: u32 = 1;
pub const CONFIG_LWIP_DHCPS: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_DHCPS_STATIC_ENTRIES: u32 = 1;
pub const CONFIG_LWIP_DHCPS_ADD_DNS: u32 = 1;
pub const CONFIG_LWIP_IPV4: u32 = 1;
pub const CONFIG_LWIP_IPV6: u32 = 1;
pub const CONFIG_LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION: u32 = 1;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1440;
pub const CONFIG_LWIP_TCP_TMR_INTERVAL: u32 = 250;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 5760;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5760;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OOSEQ_TIMEOUT: u32 = 6;
pub const CONFIG_LWIP_TCP_OOSEQ_MAX_PBUFS: u32 = 4;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_TCP_RTO_TIME: u32 = 1500;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS: u32 = 5;
pub const CONFIG_LWIP_IPV6_ND6_NUM_PREFIXES: u32 = 5;
pub const CONFIG_LWIP_IPV6_ND6_NUM_ROUTERS: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_DESTINATIONS: u32 = 10;
pub const CONFIG_LWIP_ICMP: u32 = 1;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_SNTP_MAX_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_LWIP_SNTP_STARTUP_DELAY: u32 = 1;
pub const CONFIG_LWIP_SNTP_MAXIMUM_STARTUP_DELAY: u32 = 5000;
pub const CONFIG_LWIP_DNS_MAX_HOST_IP: u32 = 1;
pub const CONFIG_LWIP_DNS_MAX_SERVERS: u32 = 3;
pub const CONFIG_LWIP_BRIDGEIF_MAX_PORTS: u32 = 7;
pub const CONFIG_LWIP_ESP_LWIP_ASSERT: u32 = 1;
pub const CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_ROUTE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_ND6_GET_GW_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_INPUT_DEFAULT: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE: u32 = 1;
pub const CONFIG_MBEDTLS_PKCS7_C: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS: u32 = 200;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_MBEDTLS_AES_USE_INTERRUPT: u32 = 1;
pub const CONFIG_MBEDTLS_AES_INTERRUPT_LEVEL: u32 = 0;
pub const CONFIG_MBEDTLS_HARDWARE_GCM: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_SUPPORT_NON_AES_CIPHER: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_MPI: u32 = 1;
pub const CONFIG_MBEDTLS_MPI_USE_INTERRUPT: u32 = 1;
pub const CONFIG_MBEDTLS_MPI_INTERRUPT_LEVEL: u32 = 0;
pub const CONFIG_MBEDTLS_ROM_MD5: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_DETERMINISTIC: u32 = 1;
pub const CONFIG_MBEDTLS_SHA512_C: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_PK_PARSE_EC_EXTENDED: u32 = 1;
pub const CONFIG_MBEDTLS_PK_PARSE_EC_COMPRESSED: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MBEDTLS_ERROR_STRINGS: u32 = 1;
pub const CONFIG_MBEDTLS_FS_IO: u32 = 1;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_LIBC_NEWLIB: u32 = 1;
pub const CONFIG_LIBC_MISC_IN_IRAM: u32 = 1;
pub const CONFIG_LIBC_LOCKS_PLACE_IN_IRAM: u32 = 1;
pub const CONFIG_LIBC_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_LIBC_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_LIBC_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_PATCH_VERSION: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8] = b"pthread\0";
pub const CONFIG_MMU_PAGE_SIZE_64KB: u32 = 1;
pub const CONFIG_MMU_PAGE_MODE: &[u8; 5] = b"64KB\0";
pub const CONFIG_MMU_PAGE_SIZE: u32 = 65536;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC: u32 = 1;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET: u32 = 1;
pub const CONFIG_SPI_FLASH_SUSPEND_TSUS_VAL_US: u32 = 50;
pub const CONFIG_SPI_FLASH_PLACE_FUNCTIONS_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_YIELD_DURING_ERASE: u32 = 1;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS: u32 = 20;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_TICKS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE: u32 = 8192;
pub const CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_GD_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_ISSI_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_MXIC_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_WINBOND_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_BOYA_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_TH_SUPPORT_ENABLED: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_GD_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_TH_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_WS_TRANSPORT: u32 = 1;
pub const CONFIG_WS_BUFFER_SIZE: u32 = 1024;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_USB_HOST_CONTROL_TRANSFER_MAX_SIZE: u32 = 256;
pub const CONFIG_USB_HOST_HW_BUFFER_BIAS_BALANCED: u32 = 1;
pub const CONFIG_USB_HOST_DEBOUNCE_DELAY_MS: u32 = 250;
pub const CONFIG_USB_HOST_RESET_HOLD_MS: u32 = 30;
pub const CONFIG_USB_HOST_RESET_RECOVERY_MS: u32 = 30;
pub const CONFIG_USB_HOST_SET_ADDR_RECOVERY_MS: u32 = 10;
pub const CONFIG_USB_OTG_SUPPORTED: u32 = 1;
pub const CONFIG_VFS_SUPPORT_IO: u32 = 1;
pub const CONFIG_VFS_SUPPORT_DIR: u32 = 1;
pub const CONFIG_VFS_SUPPORT_SELECT: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_VFS_MAX_COUNT: u32 = 8;
pub const CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_VFS_INITIALIZE_DEV_NULL: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES: u32 = 16;
pub const CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT: u32 = 30;
pub const CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN: u32 = 1;
pub const CONFIG_ADC2_DISABLE_DAC: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_CONSOLE_UART: u32 = 1;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32S2_ALLOW_RTC_FAST_MEM_AS_HEAP: u32 = 1;
pub const CONFIG_ESP32S2_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32S2_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP32S2_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP32S2_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP32S2_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ESP32S2_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP32S2_MEMPROT_FEATURE: u32 = 1;
pub const CONFIG_ESP32S2_MEMPROT_FEATURE_LOCK: u32 = 1;
pub const CONFIG_ESP32S2_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP32S2_RTC_CLK_CAL_CYCLES: u32 = 576;
pub const CONFIG_ESP32S2_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_ESP32S2_TIME_SYSCALL_USE_RTC_FRC1: u32 = 1;
pub const CONFIG_ESP32S2_TIME_SYSCALL_USE_RTC_SYSTIMER: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_BROWNOUT_INTR: u32 = 1;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_GDBSTUB_MAX_TASKS: u32 = 32;
pub const CONFIG_GDBSTUB_SUPPORT_TASKS: u32 = 1;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_SILENT: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTION_LEVEL: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_PERIPH_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_ISR: u32 = 1;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1440;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5760;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5760;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_NOT_FINISHED: u32 = 268;
pub const ESP_ERR_NOT_ALLOWED: u32 = 269;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const ESP_ERR_HW_CRYPTO_BASE: u32 = 49152;
pub const ESP_ERR_MEMPROT_BASE: u32 = 53248;
pub const ESP_EVENT_ANY_ID: i32 = -1;
pub const WIFI_AP_DEFAULT_MAX_IDLE_PERIOD: u32 = 292;
pub const WIFI_ACTIVE_SCAN_MIN_DEFAULT_TIME: u32 = 0;
pub const WIFI_ACTIVE_SCAN_MAX_DEFAULT_TIME: u32 = 120;
pub const WIFI_PASSIVE_SCAN_DEFAULT_TIME: u32 = 360;
pub const WIFI_SCAN_HOME_CHANNEL_DWELL_DEFAULT_TIME: u32 = 30;
pub const WIFI_PROTOCOL_11B: u32 = 1;
pub const WIFI_PROTOCOL_11G: u32 = 2;
pub const WIFI_PROTOCOL_11N: u32 = 4;
pub const WIFI_PROTOCOL_LR: u32 = 8;
pub const WIFI_PROTOCOL_11A: u32 = 16;
pub const WIFI_PROTOCOL_11AC: u32 = 32;
pub const WIFI_PROTOCOL_11AX: u32 = 64;
pub const SAE_H2E_IDENTIFIER_LEN: u32 = 32;
pub const WIFI_VENDOR_IE_ELEMENT_ID: u32 = 221;
pub const WIFI_PROMIS_FILTER_MASK_ALL: u32 = 4294967295;
pub const WIFI_PROMIS_FILTER_MASK_MGMT: u32 = 1;
pub const WIFI_PROMIS_FILTER_MASK_CTRL: u32 = 2;
pub const WIFI_PROMIS_FILTER_MASK_DATA: u32 = 4;
pub const WIFI_PROMIS_FILTER_MASK_MISC: u32 = 8;
pub const WIFI_PROMIS_FILTER_MASK_DATA_MPDU: u32 = 16;
pub const WIFI_PROMIS_FILTER_MASK_DATA_AMPDU: u32 = 32;
pub const WIFI_PROMIS_FILTER_MASK_FCSFAIL: u32 = 64;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ALL: u32 = 4286578688;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_WRAPPER: u32 = 8388608;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BAR: u32 = 16777216;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BA: u32 = 33554432;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_PSPOLL: u32 = 67108864;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_RTS: u32 = 134217728;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CTS: u32 = 268435456;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ACK: u32 = 536870912;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFEND: u32 = 1073741824;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFENDACK: u32 = 2147483648;
pub const WIFI_EVENT_MASK_ALL: u32 = 4294967295;
pub const WIFI_EVENT_MASK_NONE: u32 = 0;
pub const ESP_WIFI_NAN_MAX_SVC_SUPPORTED: u32 = 2;
pub const ESP_WIFI_NAN_DATAPATH_MAX_PEERS: u32 = 2;
pub const ESP_WIFI_NDP_ROLE_INITIATOR: u32 = 1;
pub const ESP_WIFI_NDP_ROLE_RESPONDER: u32 = 2;
pub const ESP_WIFI_MAX_SVC_NAME_LEN: u32 = 256;
pub const ESP_WIFI_MAX_FILTER_LEN: u32 = 256;
pub const ESP_WIFI_MAX_SVC_INFO_LEN: u32 = 64;
pub const ESP_WIFI_MAX_FUP_SSI_LEN: u32 = 2048;
pub const ESP_WIFI_MAX_SVC_SSI_LEN: u32 = 512;
pub const ESP_WIFI_MAX_NEIGHBOR_REP_LEN: u32 = 64;
pub const WIFI_OUI_LEN: u32 = 3;
pub const MAX_SSID_LEN: u32 = 32;
pub const MAX_PASSPHRASE_LEN: u32 = 64;
pub const MAX_WPS_AP_CRED: u32 = 3;
pub const WIFI_STATIS_BUFFER: u32 = 1;
pub const WIFI_STATIS_RXTX: u32 = 2;
pub const WIFI_STATIS_HW: u32 = 4;
pub const WIFI_STATIS_DIAG: u32 = 8;
pub const WIFI_STATIS_PS: u32 = 16;
pub const WIFI_STATIS_ALL: i32 = -1;
pub const WIFI_MAX_SUPPORT_COUNTRY_NUM: u32 = 176;
pub const WIFI_MAX_REGULATORY_RULE_NUM: u32 = 2;
pub const ESP_WIFI_MAX_CONN_NUM: u32 = 15;
pub const ESP_WIFI_CRYPTO_VERSION: u32 = 1;
pub const ESP_ERR_WIFI_NOT_INIT: u32 = 12289;
pub const ESP_ERR_WIFI_NOT_STARTED: u32 = 12290;
pub const ESP_ERR_WIFI_NOT_STOPPED: u32 = 12291;
pub const ESP_ERR_WIFI_IF: u32 = 12292;
pub const ESP_ERR_WIFI_MODE: u32 = 12293;
pub const ESP_ERR_WIFI_STATE: u32 = 12294;
pub const ESP_ERR_WIFI_CONN: u32 = 12295;
pub const ESP_ERR_WIFI_NVS: u32 = 12296;
pub const ESP_ERR_WIFI_MAC: u32 = 12297;
pub const ESP_ERR_WIFI_SSID: u32 = 12298;
pub const ESP_ERR_WIFI_PASSWORD: u32 = 12299;
pub const ESP_ERR_WIFI_TIMEOUT: u32 = 12300;
pub const ESP_ERR_WIFI_WAKE_FAIL: u32 = 12301;
pub const ESP_ERR_WIFI_WOULD_BLOCK: u32 = 12302;
pub const ESP_ERR_WIFI_NOT_CONNECT: u32 = 12303;
pub const ESP_ERR_WIFI_POST: u32 = 12306;
pub const ESP_ERR_WIFI_INIT_STATE: u32 = 12307;
pub const ESP_ERR_WIFI_STOP_STATE: u32 = 12308;
pub const ESP_ERR_WIFI_NOT_ASSOC: u32 = 12309;
pub const ESP_ERR_WIFI_TX_DISALLOW: u32 = 12310;
pub const ESP_ERR_WIFI_TWT_FULL: u32 = 12311;
pub const ESP_ERR_WIFI_TWT_SETUP_TIMEOUT: u32 = 12312;
pub const ESP_ERR_WIFI_TWT_SETUP_TXFAIL: u32 = 12313;
pub const ESP_ERR_WIFI_TWT_SETUP_REJECT: u32 = 12314;
pub const ESP_ERR_WIFI_DISCARD: u32 = 12315;
pub const ESP_ERR_WIFI_ROC_IN_PROGRESS: u32 = 12316;
pub const WIFI_STATIC_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_CACHE_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const WIFI_RX_MGMT_BUF_NUM_DEF: u32 = 5;
pub const WIFI_CSI_ENABLED: u32 = 0;
pub const WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const WIFI_AMSDU_TX_ENABLED: u32 = 0;
pub const WIFI_NVS_ENABLED: u32 = 1;
pub const WIFI_NANO_FORMAT_ENABLED: u32 = 0;
pub const WIFI_INIT_CONFIG_MAGIC: u32 = 523190095;
pub const WIFI_DEFAULT_RX_BA_WIN: u32 = 6;
pub const WIFI_TASK_CORE_ID: u32 = 0;
pub const WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const WIFI_STA_DISCONNECTED_PM_ENABLED: u32 = 1;
pub const WIFI_ENABLE_WPA3_SAE: u32 = 0;
pub const WIFI_ENABLE_SPIRAM: u32 = 0;
pub const WIFI_FTM_INITIATOR: u32 = 0;
pub const WIFI_FTM_RESPONDER: u32 = 0;
pub const WIFI_ENABLE_GCMP: u32 = 0;
pub const WIFI_ENABLE_GMAC: u32 = 32;
pub const WIFI_ENABLE_11R: u32 = 0;
pub const WIFI_ENABLE_ENTERPRISE: u32 = 128;
pub const WIFI_DUMP_HESIGB_ENABLED: u32 = 0;
pub const WIFI_TX_HETB_QUEUE_NUM: u32 = 1;
pub const CONFIG_FEATURE_WPA3_SAE_BIT: u32 = 1;
pub const CONFIG_FEATURE_CACHE_TX_BUF_BIT: u32 = 2;
pub const CONFIG_FEATURE_FTM_INITIATOR_BIT: u32 = 4;
pub const CONFIG_FEATURE_FTM_RESPONDER_BIT: u32 = 8;
pub const CONFIG_FEATURE_GCMP_BIT: u32 = 16;
pub const CONFIG_FEATURE_GMAC_BIT: u32 = 32;
pub const CONFIG_FEATURE_11R_BIT: u32 = 64;
pub const CONFIG_FEATURE_WIFI_ENT_BIT: u32 = 128;
pub const WIFI_FEATURE_CAPS: u32 = 160;
pub const ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE: u32 = 0;
pub const WIFI_LOG_SUBMODULE_ALL: u32 = 0;
pub const WIFI_LOG_SUBMODULE_INIT: u32 = 1;
pub const WIFI_LOG_SUBMODULE_IOCTL: u32 = 2;
pub const WIFI_LOG_SUBMODULE_CONN: u32 = 4;
pub const WIFI_LOG_SUBMODULE_SCAN: u32 = 8;
pub const ESP_WIFI_OS_ADAPTER_VERSION: u32 = 8;
pub const ESP_WIFI_OS_ADAPTER_MAGIC: u32 = 3735928495;
pub const OSI_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const OSI_QUEUE_SEND_FRONT: u32 = 0;
pub const OSI_QUEUE_SEND_BACK: u32 = 1;
pub const OSI_QUEUE_SEND_OVERWRITE: u32 = 2;
pub const SOC_ADC_SUPPORTED: u32 = 1;
pub const SOC_DAC_SUPPORTED: u32 = 1;
pub const SOC_UART_SUPPORTED: u32 = 1;
pub const SOC_TWAI_SUPPORTED: u32 = 1;
pub const SOC_CP_DMA_SUPPORTED: u32 = 1;
pub const SOC_DEDICATED_GPIO_SUPPORTED: u32 = 1;
pub const SOC_GPTIMER_SUPPORTED: u32 = 1;
pub const SOC_SUPPORTS_SECURE_DL_MODE: u32 = 1;
pub const SOC_ULP_FSM_SUPPORTED: u32 = 1;
pub const SOC_RISCV_COPROC_SUPPORTED: u32 = 1;
pub const SOC_USB_OTG_SUPPORTED: u32 = 1;
pub const SOC_PCNT_SUPPORTED: u32 = 1;
pub const SOC_PHY_SUPPORTED: u32 = 1;
pub const SOC_WIFI_SUPPORTED: u32 = 1;
pub const SOC_ULP_SUPPORTED: u32 = 1;
pub const SOC_CCOMP_TIMER_SUPPORTED: u32 = 1;
pub const SOC_ASYNC_MEMCPY_SUPPORTED: u32 = 1;
pub const SOC_EFUSE_KEY_PURPOSE_FIELD: u32 = 1;
pub const SOC_EFUSE_SUPPORTED: u32 = 1;
pub const SOC_TEMP_SENSOR_SUPPORTED: u32 = 1;
pub const SOC_CACHE_SUPPORT_WRAP: u32 = 1;
pub const SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const SOC_RTC_SLOW_MEM_SUPPORTED: u32 = 1;
pub const SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const SOC_PSRAM_DMA_CAPABLE: u32 = 1;
pub const SOC_XT_WDT_SUPPORTED: u32 = 1;
pub const SOC_I2S_SUPPORTED: u32 = 1;
pub const SOC_RMT_SUPPORTED: u32 = 1;
pub const SOC_SDM_SUPPORTED: u32 = 1;
pub const SOC_GPSPI_SUPPORTED: u32 = 1;
pub const SOC_LEDC_SUPPORTED: u32 = 1;
pub const SOC_I2C_SUPPORTED: u32 = 1;
pub const SOC_SYSTIMER_SUPPORTED: u32 = 1;
pub const SOC_SUPPORT_COEXISTENCE: u32 = 0;
pub const SOC_AES_SUPPORTED: u32 = 1;
pub const SOC_MPI_SUPPORTED: u32 = 1;
pub const SOC_SHA_SUPPORTED: u32 = 1;
pub const SOC_HMAC_SUPPORTED: u32 = 1;
pub const SOC_DIG_SIGN_SUPPORTED: u32 = 1;
pub const SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const SOC_MEMPROT_SUPPORTED: u32 = 1;
pub const SOC_TOUCH_SENSOR_SUPPORTED: u32 = 1;
pub const SOC_BOD_SUPPORTED: u32 = 1;
pub const SOC_CLK_TREE_SUPPORTED: u32 = 1;
pub const SOC_MPU_SUPPORTED: u32 = 1;
pub const SOC_WDT_SUPPORTED: u32 = 1;
pub const SOC_SPI_FLASH_SUPPORTED: u32 = 1;
pub const SOC_RNG_SUPPORTED: u32 = 1;
pub const SOC_LIGHT_SLEEP_SUPPORTED: u32 = 1;
pub const SOC_DEEP_SLEEP_SUPPORTED: u32 = 1;
pub const SOC_LP_PERIPH_SHARE_INTERRUPT: u32 = 1;
pub const SOC_PM_SUPPORTED: u32 = 1;
pub const SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const SOC_ADC_RTC_CTRL_SUPPORTED: u32 = 1;
pub const SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const SOC_ADC_ARBITER_SUPPORTED: u32 = 1;
pub const SOC_ADC_DIG_IIR_FILTER_SUPPORTED: u32 = 1;
pub const SOC_ADC_DIG_IIR_FILTER_UNIT_BINDED: u32 = 1;
pub const SOC_ADC_MONITOR_SUPPORTED: u32 = 1;
pub const SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const SOC_ADC_PERIPH_NUM: u32 = 2;
pub const SOC_ADC_MAX_CHANNEL_NUM: u32 = 10;
pub const SOC_ADC_ATTEN_NUM: u32 = 4;
pub const SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 2;
pub const SOC_ADC_PATT_LEN_MAX: u32 = 32;
pub const SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 12;
pub const SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const SOC_ADC_DIGI_IIR_FILTER_NUM: u32 = 2;
pub const SOC_ADC_DIGI_RESULT_BYTES: u32 = 2;
pub const SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 2;
pub const SOC_ADC_DIGI_MONITOR_NUM: u32 = 2;
pub const SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 83333;
pub const SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 611;
pub const SOC_ADC_RTC_MIN_BITWIDTH: u32 = 13;
pub const SOC_ADC_RTC_MAX_BITWIDTH: u32 = 13;
pub const SOC_ADC_CALIBRATION_V1_SUPPORTED: u32 = 1;
pub const SOC_ADC_SELF_HW_CALI_SUPPORTED: u32 = 1;
pub const SOC_ADC_SHARED_POWER: u32 = 1;
pub const SOC_BROWNOUT_RESET_SUPPORTED: u32 = 1;
pub const SOC_CACHE_WRITEBACK_SUPPORTED: u32 = 1;
pub const SOC_CP_DMA_MAX_BUFFER_SIZE: u32 = 4095;
pub const SOC_CPU_CORES_NUM: u32 = 1;
pub const SOC_CPU_INTR_NUM: u32 = 32;
pub const SOC_CPU_BREAKPOINTS_NUM: u32 = 2;
pub const SOC_CPU_WATCHPOINTS_NUM: u32 = 2;
pub const SOC_CPU_WATCHPOINT_MAX_REGION_SIZE: u32 = 64;
pub const SOC_DAC_CHAN_NUM: u32 = 2;
pub const SOC_DAC_RESOLUTION: u32 = 8;
pub const SOC_GPIO_PORT: u32 = 1;
pub const SOC_GPIO_PIN_COUNT: u32 = 47;
pub const SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER: u32 = 1;
pub const SOC_GPIO_FILTER_CLK_SUPPORT_APB: u32 = 1;
pub const SOC_GPIO_SUPPORT_RTC_INDEPENDENT: u32 = 1;
pub const SOC_GPIO_SUPPORT_FORCE_HOLD: u32 = 1;
pub const SOC_GPIO_IN_RANGE_MAX: u32 = 46;
pub const SOC_GPIO_OUT_RANGE_MAX: u32 = 45;
pub const SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u64 = 140737421246464;
pub const SOC_GPIO_CLOCKOUT_BY_IO_MUX: u32 = 1;
pub const SOC_GPIO_CLOCKOUT_CHANNEL_NUM: u32 = 3;
pub const SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP: u32 = 1;
pub const SOC_DEDIC_GPIO_OUT_CHANNELS_NUM: u32 = 8;
pub const SOC_DEDIC_GPIO_IN_CHANNELS_NUM: u32 = 8;
pub const SOC_DEDIC_GPIO_ALLOW_REG_ACCESS: u32 = 1;
pub const SOC_DEDIC_GPIO_HAS_INTERRUPT: u32 = 1;
pub const SOC_DEDIC_GPIO_OUT_AUTO_ENABLE: u32 = 1;
pub const SOC_I2C_NUM: u32 = 2;
pub const SOC_HP_I2C_NUM: u32 = 2;
pub const SOC_I2C_FIFO_LEN: u32 = 32;
pub const SOC_I2C_CMD_REG_NUM: u32 = 16;
pub const SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE: u32 = 1;
pub const SOC_I2C_SUPPORT_HW_CLR_BUS: u32 = 1;
pub const SOC_I2C_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_I2C_SUPPORT_APB: u32 = 1;
pub const SOC_I2S_NUM: u32 = 1;
pub const SOC_I2S_HW_VERSION_1: u32 = 1;
pub const SOC_I2S_SUPPORTS_APLL: u32 = 1;
pub const SOC_I2S_SUPPORTS_PLL_F160M: u32 = 1;
pub const SOC_I2S_SUPPORTS_DMA_EQUAL: u32 = 1;
pub const SOC_I2S_SUPPORTS_LCD_CAMERA: u32 = 1;
pub const SOC_I2S_MAX_DATA_WIDTH: u32 = 24;
pub const SOC_I2S_APLL_MIN_FREQ: u32 = 250000000;
pub const SOC_I2S_APLL_MAX_FREQ: u32 = 500000000;
pub const SOC_I2S_APLL_MIN_RATE: u32 = 10675;
pub const SOC_I2S_LCD_I80_VARIANT: u32 = 1;
pub const SOC_LCD_I80_SUPPORTED: u32 = 1;
pub const SOC_LCD_I80_BUSES: u32 = 1;
pub const SOC_LCD_I80_BUS_WIDTH: u32 = 24;
pub const SOC_LEDC_HAS_TIMER_SPECIFIC_MUX: u32 = 1;
pub const SOC_LEDC_SUPPORT_APB_CLOCK: u32 = 1;
pub const SOC_LEDC_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_LEDC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const SOC_LEDC_TIMER_NUM: u32 = 4;
pub const SOC_LEDC_CHANNEL_NUM: u32 = 8;
pub const SOC_LEDC_TIMER_BIT_WIDTH: u32 = 14;
pub const SOC_LEDC_SUPPORT_FADE_STOP: u32 = 1;
pub const SOC_MMU_LINEAR_ADDRESS_REGION_NUM: u32 = 5;
pub const SOC_MMU_PERIPH_NUM: u32 = 1;
pub const SOC_MPU_CONFIGURABLE_REGIONS_SUPPORTED: u32 = 0;
pub const SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const SOC_MPU_REGION_RO_SUPPORTED: u32 = 0;
pub const SOC_MPU_REGION_WO_SUPPORTED: u32 = 0;
pub const SOC_PCNT_GROUPS: u32 = 1;
pub const SOC_PCNT_UNITS_PER_GROUP: u32 = 4;
pub const SOC_PCNT_CHANNELS_PER_UNIT: u32 = 2;
pub const SOC_PCNT_THRES_POINT_PER_UNIT: u32 = 2;
pub const SOC_RMT_GROUPS: u32 = 1;
pub const SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 4;
pub const SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 4;
pub const SOC_RMT_CHANNELS_PER_GROUP: u32 = 4;
pub const SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 64;
pub const SOC_RMT_SUPPORT_RX_DEMODULATION: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_ASYNC_STOP: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_LOOP_COUNT: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_SYNCHRO: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY: u32 = 1;
pub const SOC_RMT_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_RMT_SUPPORT_APB: u32 = 1;
pub const SOC_RMT_CHANNEL_CLK_INDEPENDENT: u32 = 1;
pub const SOC_RTCIO_PIN_COUNT: u32 = 22;
pub const SOC_RTCIO_INPUT_OUTPUT_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_HOLD_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_WAKE_SUPPORTED: u32 = 1;
pub const SOC_LP_IO_CLOCK_IS_INDEPENDENT: u32 = 1;
pub const SOC_SDM_GROUPS: u32 = 1;
pub const SOC_SDM_CHANNELS_PER_GROUP: u32 = 8;
pub const SOC_SDM_CLK_SUPPORT_APB: u32 = 1;
pub const SOC_SPI_HD_BOTH_INOUT_SUPPORTED: u32 = 1;
pub const SOC_SPI_PERIPH_NUM: u32 = 3;
pub const SOC_SPI_DMA_CHAN_NUM: u32 = 3;
pub const SOC_SPI_MAX_CS_NUM: u32 = 6;
pub const SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 72;
pub const SOC_SPI_MAX_PRE_DIVIDER: u32 = 8192;
pub const SOC_SPI_SUPPORT_DDRCLK: u32 = 1;
pub const SOC_SPI_SLAVE_SUPPORT_SEG_TRANS: u32 = 1;
pub const SOC_SPI_SUPPORT_CD_SIG: u32 = 1;
pub const SOC_SPI_SUPPORT_CONTINUOUS_TRANS: u32 = 1;
pub const SOC_SPI_SUPPORT_CLK_APB: u32 = 1;
pub const SOC_SPI_SUPPORT_SLAVE_HD_VER2: u32 = 1;
pub const SOC_SPI_PERIPH_SUPPORT_CONTROL_DUMMY_OUT: u32 = 1;
pub const SOC_SPI_SUPPORT_OCT: u32 = 1;
pub const SOC_SPI_SCT_SUPPORTED: u32 = 1;
pub const SOC_SPI_SCT_REG_NUM: u32 = 27;
pub const SOC_SPI_SCT_BUFFER_NUM_MAX: u32 = 28;
pub const SOC_SPI_SCT_CONF_BITLEN_MAX: u32 = 8388605;
pub const SOC_MEMSPI_IS_INDEPENDENT: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_26M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const SOC_SYSTIMER_COUNTER_NUM: u32 = 1;
pub const SOC_SYSTIMER_ALARM_NUM: u32 = 3;
pub const SOC_SYSTIMER_BIT_WIDTH_LO: u32 = 32;
pub const SOC_SYSTIMER_BIT_WIDTH_HI: u32 = 32;
pub const SOC_TIMER_GROUPS: u32 = 2;
pub const SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 2;
pub const SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 64;
pub const SOC_TIMER_GROUP_SUPPORT_XTAL: u32 = 1;
pub const SOC_TIMER_GROUP_SUPPORT_APB: u32 = 1;
pub const SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 4;
pub const SOC_LP_TIMER_BIT_WIDTH_LO: u32 = 32;
pub const SOC_LP_TIMER_BIT_WIDTH_HI: u32 = 16;
pub const SOC_TOUCH_SENSOR_VERSION: u32 = 2;
pub const SOC_TOUCH_SENSOR_NUM: u32 = 15;
pub const SOC_TOUCH_MIN_CHAN_ID: u32 = 1;
pub const SOC_TOUCH_MAX_CHAN_ID: u32 = 14;
pub const SOC_TOUCH_SUPPORT_BENCHMARK: u32 = 1;
pub const SOC_TOUCH_SUPPORT_SLEEP_WAKEUP: u32 = 1;
pub const SOC_TOUCH_SUPPORT_WATERPROOF: u32 = 1;
pub const SOC_TOUCH_SUPPORT_PROX_SENSING: u32 = 1;
pub const SOC_TOUCH_SUPPORT_DENOISE_CHAN: u32 = 1;
pub const SOC_TOUCH_PROXIMITY_CHANNEL_NUM: u32 = 3;
pub const SOC_TOUCH_SAMPLE_CFG_NUM: u32 = 1;
pub const SOC_TWAI_CONTROLLER_NUM: u32 = 1;
pub const SOC_TWAI_MASK_FILTER_NUM: u32 = 1;
pub const SOC_TWAI_CLK_SUPPORT_APB: u32 = 1;
pub const SOC_TWAI_BRP_MIN: u32 = 2;
pub const SOC_TWAI_BRP_MAX: u32 = 32768;
pub const SOC_TWAI_SUPPORTS_RX_STATUS: u32 = 1;
pub const SOC_UART_NUM: u32 = 2;
pub const SOC_UART_HP_NUM: u32 = 2;
pub const SOC_UART_SUPPORT_WAKEUP_INT: u32 = 1;
pub const SOC_UART_SUPPORT_APB_CLK: u32 = 1;
pub const SOC_UART_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_UART_FIFO_LEN: u32 = 128;
pub const SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE: u32 = 1;
pub const SOC_SPIRAM_SUPPORTED: u32 = 1;
pub const SOC_SPIRAM_XIP_SUPPORTED: u32 = 1;
pub const SOC_USB_OTG_PERIPH_NUM: u32 = 1;
pub const SOC_SHA_DMA_MAX_BUFFER_SIZE: u32 = 3968;
pub const SOC_SHA_SUPPORT_DMA: u32 = 1;
pub const SOC_SHA_SUPPORT_RESUME: u32 = 1;
pub const SOC_SHA_CRYPTO_DMA: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA224: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA384: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA512: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA512_224: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA512_256: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA512_T: u32 = 1;
pub const SOC_MPI_MEM_BLOCKS_NUM: u32 = 4;
pub const SOC_MPI_OPERATIONS_NUM: u32 = 3;
pub const SOC_RSA_MAX_BIT_LEN: u32 = 4096;
pub const SOC_AES_SUPPORT_DMA: u32 = 1;
pub const SOC_AES_SUPPORT_GCM: u32 = 1;
pub const SOC_EFUSE_DIS_DOWNLOAD_ICACHE: u32 = 1;
pub const SOC_EFUSE_DIS_DOWNLOAD_DCACHE: u32 = 1;
pub const SOC_EFUSE_HARD_DIS_JTAG: u32 = 1;
pub const SOC_EFUSE_SOFT_DIS_JTAG: u32 = 1;
pub const SOC_EFUSE_DIS_BOOT_REMAP: u32 = 1;
pub const SOC_EFUSE_DIS_LEGACY_SPI_BOOT: u32 = 1;
pub const SOC_EFUSE_DIS_ICACHE: u32 = 1;
pub const SOC_SECURE_BOOT_V2_RSA: u32 = 1;
pub const SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 3;
pub const SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: u32 = 1;
pub const SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY: u32 = 1;
pub const SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 64;
pub const SOC_FLASH_ENCRYPTION_XTS_AES: u32 = 1;
pub const SOC_FLASH_ENCRYPTION_XTS_AES_OPTIONS: u32 = 1;
pub const SOC_FLASH_ENCRYPTION_XTS_AES_128: u32 = 1;
pub const SOC_FLASH_ENCRYPTION_XTS_AES_256: u32 = 1;
pub const SOC_MEMPROT_CPU_PREFETCH_PAD_SIZE: u32 = 16;
pub const SOC_MEMPROT_MEM_ALIGN_SIZE: u32 = 4;
pub const SOC_AES_CRYPTO_DMA: u32 = 1;
pub const SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const SOC_AES_SUPPORT_AES_192: u32 = 1;
pub const SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 84;
pub const SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH: u32 = 12;
pub const SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_SW_SUSPEND: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_WRAP: u32 = 1;
pub const SOC_PM_SUPPORT_EXT0_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_EXT1_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_EXT_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_WIFI_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_TOUCH_SENSOR_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_WIFI_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RTC_PERIPH_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RTC_FAST_MEM_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RTC_SLOW_MEM_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RC_FAST_PD: u32 = 1;
pub const SOC_PM_SUPPORT_VDDSDIO_PD: u32 = 1;
pub const SOC_CONFIGURABLE_VDDSDIO_SUPPORTED: u32 = 1;
pub const SOC_PM_MODEM_PD_BY_SW: u32 = 1;
pub const SOC_CLK_APLL_SUPPORTED: u32 = 1;
pub const SOC_CLK_RC_FAST_D256_SUPPORTED: u32 = 1;
pub const SOC_RTC_SLOW_CLK_SUPPORT_RC_FAST_D256: u32 = 1;
pub const SOC_CLK_RC_FAST_SUPPORT_CALIBRATION: u32 = 1;
pub const SOC_CLK_XTAL32K_SUPPORTED: u32 = 1;
pub const SOC_CLK_LP_FAST_SUPPORT_XTAL_D4: u32 = 1;
pub const SOC_COEX_HW_PTI: u32 = 1;
pub const SOC_EXTERNAL_COEX_ADVANCE: u32 = 0;
pub const SOC_EXTERNAL_COEX_LEADER_TX_LINE: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC: u32 = 1;
pub const SOC_WIFI_HW_TSF: u32 = 1;
pub const SOC_WIFI_FTM_SUPPORT: u32 = 1;
pub const SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const SOC_WIFI_SUPPORT_VARIABLE_BEACON_WINDOW: u32 = 1;
pub const SOC_WIFI_NAN_SUPPORT: u32 = 1;
pub const SOC_ULP_HAS_ADC: u32 = 1;
pub const SOC_PHY_COMBO_MODULE: u32 = 0;
pub const ESP_CAL_DATA_CHECK_FAIL: u32 = 1;
pub const ESP_ERR_ESPNOW_BASE: u32 = 12388;
pub const ESP_ERR_ESPNOW_NOT_INIT: u32 = 12389;
pub const ESP_ERR_ESPNOW_ARG: u32 = 12390;
pub const ESP_ERR_ESPNOW_NO_MEM: u32 = 12391;
pub const ESP_ERR_ESPNOW_FULL: u32 = 12392;
pub const ESP_ERR_ESPNOW_NOT_FOUND: u32 = 12393;
pub const ESP_ERR_ESPNOW_INTERNAL: u32 = 12394;
pub const ESP_ERR_ESPNOW_EXIST: u32 = 12395;
pub const ESP_ERR_ESPNOW_IF: u32 = 12396;
pub const ESP_ERR_ESPNOW_CHAN: u32 = 12397;
pub const ESP_NOW_ETH_ALEN: u32 = 6;
pub const ESP_NOW_KEY_LEN: u32 = 16;
pub const ESP_NOW_MAX_TOTAL_PEER_NUM: u32 = 20;
pub const ESP_NOW_MAX_ENCRYPT_PEER_NUM: u32 = 6;
pub const ESP_NOW_MAX_IE_DATA_LEN: u32 = 250;
pub const ESP_NOW_MAX_DATA_LEN: u32 = 250;
pub const ESP_NOW_MAX_DATA_LEN_V2: u32 = 1470;
pub type __int8_t = crate::c_types::c_schar;
pub type __uint8_t = crate::c_types::c_uchar;
pub type __int16_t = crate::c_types::c_short;
pub type __uint16_t = crate::c_types::c_ushort;
pub type __int32_t = crate::c_types::c_int;
pub type __uint32_t = crate::c_types::c_uint;
pub type __int64_t = crate::c_types::c_longlong;
pub type __uint64_t = crate::c_types::c_ulonglong;
pub type __int_least8_t = crate::c_types::c_schar;
pub type __uint_least8_t = crate::c_types::c_uchar;
pub type __int_least16_t = crate::c_types::c_short;
pub type __uint_least16_t = crate::c_types::c_ushort;
pub type __int_least32_t = crate::c_types::c_int;
pub type __uint_least32_t = crate::c_types::c_uint;
pub type __int_least64_t = crate::c_types::c_longlong;
pub type __uint_least64_t = crate::c_types::c_ulonglong;
pub type __intmax_t = crate::c_types::c_longlong;
pub type __uintmax_t = crate::c_types::c_ulonglong;
pub type __intptr_t = crate::c_types::c_int;
pub type __uintptr_t = crate::c_types::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::c_types::c_schar;
pub type uint_fast8_t = crate::c_types::c_uchar;
pub type int_fast16_t = crate::c_types::c_short;
pub type uint_fast16_t = crate::c_types::c_ushort;
pub type int_fast32_t = crate::c_types::c_int;
pub type uint_fast32_t = crate::c_types::c_uint;
pub type int_fast64_t = crate::c_types::c_longlong;
pub type uint_fast64_t = crate::c_types::c_ulonglong;
pub type _lock_t = crate::c_types::c_int;
pub type TickType_t = u32;
pub type UBaseType_t = u32;
pub type BaseType_t = i32;
pub type QueueHandle_t = *mut crate::c_types::c_void;
pub type esp_netif_t = *mut crate::c_types::c_void;
pub type esp_netif_inherent_config_t = *mut crate::c_types::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ets_timer {
    pub next: *mut timer_adpt,
    pub expire: u32,
    pub period: u32,
    pub func: ::core::option::Option<unsafe extern "C" fn(priv_: *mut crate::c_types::c_void)>,
    pub priv_: *mut crate::c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: u64,
    pub tv_usec: u32,
}
pub type wchar_t = crate::c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::c_types::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type __gnuc_va_list = [u32; 3usize];
pub type va_list = __gnuc_va_list;
pub type wint_t = crate::c_types::c_uint;
pub type __blkcnt_t = crate::c_types::c_long;
pub type __blksize_t = crate::c_types::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = crate::c_types::c_long;
pub type __pid_t = crate::c_types::c_int;
pub type __dev_t = crate::c_types::c_short;
pub type __uid_t = crate::c_types::c_ushort;
pub type __gid_t = crate::c_types::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = crate::c_types::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = crate::c_types::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = crate::c_types::c_long;
pub type _fpos_t = crate::c_types::c_long;
pub type __size_t = crate::c_types::c_uint;
pub type _ssize_t = crate::c_types::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: crate::c_types::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [crate::c_types::c_uchar; 4usize],
}
pub type _iconv_t = *mut crate::c_types::c_void;
pub type __clock_t = crate::c_types::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = crate::c_types::c_ulong;
pub type __daddr_t = crate::c_types::c_long;
pub type __timer_t = crate::c_types::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = crate::c_types::c_int;
pub type __nlink_t = crate::c_types::c_ushort;
pub type __suseconds_t = crate::c_types::c_long;
pub type __useconds_t = crate::c_types::c_ulong;
pub type __va_list = [u32; 3usize];
pub type __ULong = crate::c_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: crate::c_types::c_int,
    pub _maxwds: crate::c_types::c_int,
    pub _sign: crate::c_types::c_int,
    pub _wds: crate::c_types::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __tm {
    pub __tm_sec: crate::c_types::c_int,
    pub __tm_min: crate::c_types::c_int,
    pub __tm_hour: crate::c_types::c_int,
    pub __tm_mday: crate::c_types::c_int,
    pub __tm_mon: crate::c_types::c_int,
    pub __tm_year: crate::c_types::c_int,
    pub __tm_wday: crate::c_types::c_int,
    pub __tm_yday: crate::c_types::c_int,
    pub __tm_isdst: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut crate::c_types::c_void; 32usize],
    pub _dso_handle: [*mut crate::c_types::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: crate::c_types::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut crate::c_types::c_uchar,
    pub _size: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut crate::c_types::c_uchar,
    pub _r: crate::c_types::c_int,
    pub _w: crate::c_types::c_int,
    pub _flags: crate::c_types::c_short,
    pub _file: crate::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::c_types::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut crate::c_types::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *mut crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> crate::c_types::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *const crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> crate::c_types::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: _fpos_t,
            arg4: crate::c_types::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut crate::c_types::c_uchar,
    pub _ur: crate::c_types::c_int,
    pub _ubuf: [crate::c_types::c_uchar; 3usize],
    pub _nbuf: [crate::c_types::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: crate::c_types::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: crate::c_types::c_int,
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: crate::c_types::c_int,
    pub _iobs: *mut __FILE,
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rand48 {
    pub _seed: [crate::c_types::c_ushort; 3usize],
    pub _mult: [crate::c_types::c_ushort; 3usize],
    pub _add: crate::c_types::c_ushort,
    pub _rand_next: crate::c_types::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: crate::c_types::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut crate::c_types::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [crate::c_types::c_char; 8usize],
    pub _getdate_err: crate::c_types::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: crate::c_types::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: crate::c_types::c_int,
    pub _emergency: *mut crate::c_types::c_char,
    pub _reserved_0: crate::c_types::c_int,
    pub _reserved_1: crate::c_types::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: crate::c_types::c_int,
    pub _cvtlen: crate::c_types::c_int,
    pub _cvtbuf: *mut crate::c_types::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut crate::c_types::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: crate::c_types::c_int)>,
    pub _reserved_6: *mut _atexit,
    pub _reserved_7: _atexit,
    pub _reserved_8: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut crate::c_types::c_char,
}
extern "C" {
    pub fn __assert(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: *const crate::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> crate::c_types::c_int,
        >,
        arg3: *mut _glue,
    ) -> crate::c_types::c_int;
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub type off_t = __off_t;
extern "C" {
    pub fn ctermid(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut crate::c_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn printf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: [u32; 3usize],
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const crate::c_types::c_char,
        arg2: [u32; 3usize],
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: [u32; 3usize],
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn fputc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const crate::c_types::c_char, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getchar() -> crate::c_types::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn putc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putchar(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn puts(arg1: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ungetc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut crate::c_types::c_void,
        _size: crate::c_types::c_uint,
        _n: crate::c_types::c_uint,
        arg2: *mut FILE,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const crate::c_types::c_void,
        _size: crate::c_types::c_uint,
        _n: crate::c_types::c_uint,
        arg2: *mut FILE,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: crate::c_types::c_long,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> crate::c_types::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn perror(arg1: *const crate::c_types::c_char);
}
extern "C" {
    pub fn fopen(
        _name: *const crate::c_types::c_char,
        _type: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn remove(arg1: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_uint,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_uint,
        arg3: *const crate::c_types::c_char,
        arg4: [u32; 3usize],
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: [u32; 3usize],
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const crate::c_types::c_char,
        arg2: [u32; 3usize],
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: [u32; 3usize],
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fiprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fiscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: usize,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn viprintf(
        arg1: *const crate::c_types::c_char,
        arg2: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn viscanf(
        arg1: *const crate::c_types::c_char,
        arg2: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: usize,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fdopen(arg1: crate::c_types::c_int, arg2: *const crate::c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putw(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> crate::c_types::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut crate::c_types::c_void,
        arg2: usize,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut crate::c_types::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _fgetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *mut fpos_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: crate::c_types::c_long,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _gets_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const crate::c_types::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const crate::c_types::c_char)
        -> crate::c_types::c_int;
}
extern "C" {
    pub fn _remove_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const crate::c_types::c_char,
        _new: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const crate::c_types::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const crate::c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *mut crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *const crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __off: fpos_t,
                __whence: crate::c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut crate::c_types::c_void) -> crate::c_types::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const crate::c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *mut crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *const crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __off: fpos_t,
                __whence: crate::c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut crate::c_types::c_void) -> crate::c_types::c_int,
        >,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: crate::c_types::c_int,
    pub rem: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: crate::c_types::c_long,
    pub rem: crate::c_types::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: crate::c_types::c_longlong,
    pub rem: crate::c_types::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> crate::c_types::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut crate::c_types::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const crate::c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const crate::c_types::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const crate::c_types::c_void,
        __base: *const crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: crate::c_types::c_uint,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn div(__numer: crate::c_types::c_int, __denom: crate::c_types::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: crate::c_types::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn getenv(__string: *const crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const crate::c_types::c_char,
        arg2: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut crate::c_types::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const *mut crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn labs(arg1: crate::c_types::c_long) -> crate::c_types::c_long;
}
extern "C" {
    pub fn ldiv(__numer: crate::c_types::c_long, __denom: crate::c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: crate::c_types::c_uint) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const crate::c_types::c_char, arg2: usize) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const crate::c_types::c_char,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut crate::c_types::c_char, arg2: wchar_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const crate::c_types::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut crate::c_types::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> crate::c_types::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut crate::c_types::c_void,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut crate::c_types::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut crate::c_types::c_void, arg2: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const crate::c_types::c_char,
        resolved_path: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: crate::c_types::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn system(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn a64l(__input: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn l64a(__input: crate::c_types::c_long) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: crate::c_types::c_long,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: crate::c_types::c_int, arg2: *mut crate::c_types::c_void),
        >,
        __arg: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _Exit(__status: crate::c_types::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut crate::c_types::c_uint) -> crate::c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn lrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut crate::c_types::c_ushort) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: crate::c_types::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: crate::c_types::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: usize,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn random() -> crate::c_types::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn srandom(arg1: crate::c_types::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: crate::c_types::c_longlong) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: crate::c_types::c_longlong,
        __denom: crate::c_types::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut crate::c_types::c_void,
        arg2: usize,
        arg3: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
        arg5: *mut crate::c_types::c_int,
        arg6: *mut crate::c_types::c_int,
        arg7: *mut *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
        arg4: *const crate::c_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut crate::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut crate::c_types::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *const crate::c_types::c_void,
                arg3: *const crate::c_types::c_void,
            ) -> crate::c_types::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        arg1: *const crate::c_types::c_char,
        arg2: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn aligned_alloc(
        arg1: crate::c_types::c_uint,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: crate::c_types::c_int);
}
pub type esp_err_t = crate::c_types::c_int;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes\n\n This function finds the error code in a pre-generated lookup-table and\n returns its string representation.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes\n\n This function finds the error code in a pre-generated lookup-table of\n esp_err_t errors and returns its string representation. If the error code\n is not found then it is attempted to be found among system errors.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @param[out] buf buffer where the error message should be written\n @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte).\n @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut crate::c_types::c_char,
        buflen: usize,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        function: *const crate::c_types::c_char,
        expression: *const crate::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        function: *const crate::c_types::c_char,
        expression: *const crate::c_types::c_char,
    );
}
pub type esp_event_base_t = *const crate::c_types::c_char;
pub type esp_event_loop_handle_t = *mut crate::c_types::c_void;
pub type esp_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        event_handler_arg: *mut crate::c_types::c_void,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut crate::c_types::c_void,
    ),
>;
pub type esp_event_handler_instance_t = *mut crate::c_types::c_void;
#[doc = "< Station interface"]
pub const esp_interface_t_ESP_IF_WIFI_STA: esp_interface_t = 0;
#[doc = "< Soft-AP interface"]
pub const esp_interface_t_ESP_IF_WIFI_AP: esp_interface_t = 1;
#[doc = "< NAN interface"]
pub const esp_interface_t_ESP_IF_WIFI_NAN: esp_interface_t = 2;
#[doc = "< Ethernet interface"]
pub const esp_interface_t_ESP_IF_ETH: esp_interface_t = 3;
pub const esp_interface_t_ESP_IF_MAX: esp_interface_t = 4;
pub type esp_interface_t = crate::c_types::c_uint;
#[doc = "< Null mode"]
pub const wifi_mode_t_WIFI_MODE_NULL: wifi_mode_t = 0;
#[doc = "< Wi-Fi station mode"]
pub const wifi_mode_t_WIFI_MODE_STA: wifi_mode_t = 1;
#[doc = "< Wi-Fi soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_AP: wifi_mode_t = 2;
#[doc = "< Wi-Fi station + soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_APSTA: wifi_mode_t = 3;
#[doc = "< Wi-Fi NAN mode"]
pub const wifi_mode_t_WIFI_MODE_NAN: wifi_mode_t = 4;
pub const wifi_mode_t_WIFI_MODE_MAX: wifi_mode_t = 5;
#[doc = " @brief Wi-Fi mode type"]
pub type wifi_mode_t = crate::c_types::c_uint;
#[doc = "< Station interface"]
pub const wifi_interface_t_WIFI_IF_STA: wifi_interface_t = 0;
#[doc = "< Soft-AP interface"]
pub const wifi_interface_t_WIFI_IF_AP: wifi_interface_t = 1;
#[doc = "< NAN interface"]
pub const wifi_interface_t_WIFI_IF_NAN: wifi_interface_t = 2;
#[doc = "< Maximum number of interfaces"]
pub const wifi_interface_t_WIFI_IF_MAX: wifi_interface_t = 3;
#[doc = " @brief Wi-Fi interface type"]
pub type wifi_interface_t = crate::c_types::c_uint;
#[doc = "< Cancel off-channel transmission"]
pub const wifi_action_tx_t_WIFI_OFFCHAN_TX_CANCEL: wifi_action_tx_t = 0;
#[doc = "< Request off-channel transmission"]
pub const wifi_action_tx_t_WIFI_OFFCHAN_TX_REQ: wifi_action_tx_t = 1;
pub type wifi_action_tx_t = crate::c_types::c_uint;
#[doc = "< Cancel remain on channel"]
pub const wifi_roc_t_WIFI_ROC_CANCEL: wifi_roc_t = 0;
#[doc = "< Request remain on channel"]
pub const wifi_roc_t_WIFI_ROC_REQ: wifi_roc_t = 1;
pub type wifi_roc_t = crate::c_types::c_uint;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_AUTO: wifi_country_policy_t = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_MANUAL: wifi_country_policy_t = 1;
#[doc = " @brief Wi-Fi country policy"]
pub type wifi_country_policy_t = crate::c_types::c_uint;
#[doc = " @brief Structure describing Wi-Fi country-based regional restrictions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< Country code string"]
    pub cc: [crate::c_types::c_char; 3usize],
    #[doc = "< Start channel of the allowed 2.4GHz Wi-Fi channels"]
    pub schan: u8,
    #[doc = "< Total channel number of the allowed 2.4GHz Wi-Fi channels"]
    pub nchan: u8,
    #[doc = "< This field is used for getting Wi-Fi maximum transmitting power, call esp_wifi_set_max_tx_power to set the maximum transmitting power."]
    pub max_tx_power: i8,
    #[doc = "< Country policy"]
    pub policy: wifi_country_policy_t,
}
#[doc = "< Authenticate mode : open"]
pub const wifi_auth_mode_t_WIFI_AUTH_OPEN: wifi_auth_mode_t = 0;
#[doc = "< Authenticate mode : WEP"]
pub const wifi_auth_mode_t_WIFI_AUTH_WEP: wifi_auth_mode_t = 1;
#[doc = "< Authenticate mode : WPA_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_PSK: wifi_auth_mode_t = 2;
#[doc = "< Authenticate mode : WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_PSK: wifi_auth_mode_t = 3;
#[doc = "< Authenticate mode : WPA_WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_WPA2_PSK: wifi_auth_mode_t = 4;
#[doc = "< Authenticate mode : Wi-Fi EAP security, treated the same as WIFI_AUTH_WPA2_ENTERPRISE"]
pub const wifi_auth_mode_t_WIFI_AUTH_ENTERPRISE: wifi_auth_mode_t = 5;
#[doc = "< Authenticate mode : WPA2-Enterprise security"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_ENTERPRISE: wifi_auth_mode_t = 5;
#[doc = "< Authenticate mode : WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_PSK: wifi_auth_mode_t = 6;
#[doc = "< Authenticate mode : WPA2_WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_WPA3_PSK: wifi_auth_mode_t = 7;
#[doc = "< Authenticate mode : WAPI_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WAPI_PSK: wifi_auth_mode_t = 8;
#[doc = "< Authenticate mode : OWE"]
pub const wifi_auth_mode_t_WIFI_AUTH_OWE: wifi_auth_mode_t = 9;
#[doc = "< Authenticate mode : WPA3_ENT_SUITE_B_192_BIT"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_ENT_192: wifi_auth_mode_t = 10;
#[doc = "< This authentication mode will yield same result as WIFI_AUTH_WPA3_PSK and not recommended to be used. It will be deprecated in future, please use WIFI_AUTH_WPA3_PSK instead."]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_EXT_PSK: wifi_auth_mode_t = 11;
#[doc = "< This authentication mode will yield same result as WIFI_AUTH_WPA3_PSK and not recommended to be used. It will be deprecated in future, please use WIFI_AUTH_WPA3_PSK instead."]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_EXT_PSK_MIXED_MODE: wifi_auth_mode_t = 12;
#[doc = "< Authenticate mode : DPP"]
pub const wifi_auth_mode_t_WIFI_AUTH_DPP: wifi_auth_mode_t = 13;
#[doc = "< Authenticate mode : WPA3-Enterprise Only Mode"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_ENTERPRISE: wifi_auth_mode_t = 14;
#[doc = "< Authenticate mode : WPA3-Enterprise Transition Mode"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_WPA3_ENTERPRISE: wifi_auth_mode_t = 15;
#[doc = "< Authenticate mode : WPA-Enterprise security"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_ENTERPRISE: wifi_auth_mode_t = 16;
pub const wifi_auth_mode_t_WIFI_AUTH_MAX: wifi_auth_mode_t = 17;
#[doc = " @brief Wi-Fi authmode type\n Strength of authmodes\n Personal Networks   : OPEN < WEP < WPA_PSK < OWE < WPA2_PSK = WPA_WPA2_PSK < WAPI_PSK < WPA3_PSK = WPA2_WPA3_PSK = DPP\n Enterprise Networks : WIFI_AUTH_WPA_ENTERPRISE < WIFI_AUTH_WPA2_ENTERPRISE < WIFI_AUTH_WPA3_ENTERPRISE = WIFI_AUTH_WPA2_WPA3_ENTERPRISE < WIFI_AUTH_WPA3_ENT_192"]
pub type wifi_auth_mode_t = crate::c_types::c_uint;
#[doc = "< Unspecified reason"]
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED: wifi_err_reason_t = 1;
#[doc = "< Authentication expired"]
pub const wifi_err_reason_t_WIFI_REASON_AUTH_EXPIRE: wifi_err_reason_t = 2;
#[doc = "< Deauthentication due to leaving"]
pub const wifi_err_reason_t_WIFI_REASON_AUTH_LEAVE: wifi_err_reason_t = 3;
#[doc = "< Deprecated, will be removed in next IDF major release"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_EXPIRE: wifi_err_reason_t = 4;
#[doc = "< Disassociated due to inactivity"]
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_DUE_TO_INACTIVITY: wifi_err_reason_t = 4;
#[doc = "< Too many associated stations"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_TOOMANY: wifi_err_reason_t = 5;
#[doc = "< Deprecated, will be removed in next IDF major release"]
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHED: wifi_err_reason_t = 6;
#[doc = "< Class 2 frame received from nonauthenticated STA"]
pub const wifi_err_reason_t_WIFI_REASON_CLASS2_FRAME_FROM_NONAUTH_STA: wifi_err_reason_t = 6;
#[doc = "< Deprecated, will be removed in next IDF major release"]
pub const wifi_err_reason_t_WIFI_REASON_NOT_ASSOCED: wifi_err_reason_t = 7;
#[doc = "< Class 3 frame received from nonassociated STA"]
pub const wifi_err_reason_t_WIFI_REASON_CLASS3_FRAME_FROM_NONASSOC_STA: wifi_err_reason_t = 7;
#[doc = "< Deassociated due to leaving"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_LEAVE: wifi_err_reason_t = 8;
#[doc = "< Association but not authenticated"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_NOT_AUTHED: wifi_err_reason_t = 9;
#[doc = "< Disassociated due to poor power capability"]
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_PWRCAP_BAD: wifi_err_reason_t = 10;
#[doc = "< Disassociated due to unsupported channel"]
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_SUPCHAN_BAD: wifi_err_reason_t = 11;
#[doc = "< Disassociated due to BSS transition"]
pub const wifi_err_reason_t_WIFI_REASON_BSS_TRANSITION_DISASSOC: wifi_err_reason_t = 12;
#[doc = "< Invalid Information Element (IE)"]
pub const wifi_err_reason_t_WIFI_REASON_IE_INVALID: wifi_err_reason_t = 13;
#[doc = "< MIC failure"]
pub const wifi_err_reason_t_WIFI_REASON_MIC_FAILURE: wifi_err_reason_t = 14;
#[doc = "< 4-way handshake timeout"]
pub const wifi_err_reason_t_WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 15;
#[doc = "< Group key update timeout"]
pub const wifi_err_reason_t_WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT: wifi_err_reason_t = 16;
#[doc = "< IE differs in 4-way handshake"]
pub const wifi_err_reason_t_WIFI_REASON_IE_IN_4WAY_DIFFERS: wifi_err_reason_t = 17;
#[doc = "< Invalid group cipher"]
pub const wifi_err_reason_t_WIFI_REASON_GROUP_CIPHER_INVALID: wifi_err_reason_t = 18;
#[doc = "< Invalid pairwise cipher"]
pub const wifi_err_reason_t_WIFI_REASON_PAIRWISE_CIPHER_INVALID: wifi_err_reason_t = 19;
#[doc = "< Invalid AKMP"]
pub const wifi_err_reason_t_WIFI_REASON_AKMP_INVALID: wifi_err_reason_t = 20;
#[doc = "< Unsupported RSN IE version"]
pub const wifi_err_reason_t_WIFI_REASON_UNSUPP_RSN_IE_VERSION: wifi_err_reason_t = 21;
#[doc = "< Invalid RSN IE capabilities"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_RSN_IE_CAP: wifi_err_reason_t = 22;
#[doc = "< 802.1X authentication failed"]
pub const wifi_err_reason_t_WIFI_REASON_802_1X_AUTH_FAILED: wifi_err_reason_t = 23;
#[doc = "< Cipher suite rejected"]
pub const wifi_err_reason_t_WIFI_REASON_CIPHER_SUITE_REJECTED: wifi_err_reason_t = 24;
#[doc = "< TDLS peer unreachable"]
pub const wifi_err_reason_t_WIFI_REASON_TDLS_PEER_UNREACHABLE: wifi_err_reason_t = 25;
#[doc = "< TDLS unspecified"]
pub const wifi_err_reason_t_WIFI_REASON_TDLS_UNSPECIFIED: wifi_err_reason_t = 26;
#[doc = "< SSP requested disassociation"]
pub const wifi_err_reason_t_WIFI_REASON_SSP_REQUESTED_DISASSOC: wifi_err_reason_t = 27;
#[doc = "< No SSP roaming agreement"]
pub const wifi_err_reason_t_WIFI_REASON_NO_SSP_ROAMING_AGREEMENT: wifi_err_reason_t = 28;
#[doc = "< Bad cipher or AKM"]
pub const wifi_err_reason_t_WIFI_REASON_BAD_CIPHER_OR_AKM: wifi_err_reason_t = 29;
#[doc = "< Not authorized in this location"]
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHORIZED_THIS_LOCATION: wifi_err_reason_t = 30;
#[doc = "< Service change precludes TS"]
pub const wifi_err_reason_t_WIFI_REASON_SERVICE_CHANGE_PERCLUDES_TS: wifi_err_reason_t = 31;
#[doc = "< Unspecified QoS reason"]
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED_QOS: wifi_err_reason_t = 32;
#[doc = "< Not enough bandwidth"]
pub const wifi_err_reason_t_WIFI_REASON_NOT_ENOUGH_BANDWIDTH: wifi_err_reason_t = 33;
#[doc = "< Missing ACKs"]
pub const wifi_err_reason_t_WIFI_REASON_MISSING_ACKS: wifi_err_reason_t = 34;
#[doc = "< Exceeded TXOP"]
pub const wifi_err_reason_t_WIFI_REASON_EXCEEDED_TXOP: wifi_err_reason_t = 35;
#[doc = "< Station leaving"]
pub const wifi_err_reason_t_WIFI_REASON_STA_LEAVING: wifi_err_reason_t = 36;
#[doc = "< End of Block Ack (BA)"]
pub const wifi_err_reason_t_WIFI_REASON_END_BA: wifi_err_reason_t = 37;
#[doc = "< Unknown Block Ack (BA)"]
pub const wifi_err_reason_t_WIFI_REASON_UNKNOWN_BA: wifi_err_reason_t = 38;
#[doc = "< Timeout"]
pub const wifi_err_reason_t_WIFI_REASON_TIMEOUT: wifi_err_reason_t = 39;
#[doc = "< Peer initiated disassociation"]
pub const wifi_err_reason_t_WIFI_REASON_PEER_INITIATED: wifi_err_reason_t = 46;
#[doc = "< AP initiated disassociation"]
pub const wifi_err_reason_t_WIFI_REASON_AP_INITIATED: wifi_err_reason_t = 47;
#[doc = "< Invalid FT action frame count"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_FT_ACTION_FRAME_COUNT: wifi_err_reason_t = 48;
#[doc = "< Invalid PMKID"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_PMKID: wifi_err_reason_t = 49;
#[doc = "< Invalid MDE"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_MDE: wifi_err_reason_t = 50;
#[doc = "< Invalid FTE"]
pub const wifi_err_reason_t_WIFI_REASON_INVALID_FTE: wifi_err_reason_t = 51;
#[doc = "< Transmission link establishment failed"]
pub const wifi_err_reason_t_WIFI_REASON_TRANSMISSION_LINK_ESTABLISH_FAILED: wifi_err_reason_t = 67;
#[doc = "< Alternative channel occupied"]
pub const wifi_err_reason_t_WIFI_REASON_ALTERATIVE_CHANNEL_OCCUPIED: wifi_err_reason_t = 68;
#[doc = "< Beacon timeout"]
pub const wifi_err_reason_t_WIFI_REASON_BEACON_TIMEOUT: wifi_err_reason_t = 200;
#[doc = "< No AP found"]
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND: wifi_err_reason_t = 201;
#[doc = "< Authentication failed"]
pub const wifi_err_reason_t_WIFI_REASON_AUTH_FAIL: wifi_err_reason_t = 202;
#[doc = "< Association failed"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_FAIL: wifi_err_reason_t = 203;
#[doc = "< Handshake timeout"]
pub const wifi_err_reason_t_WIFI_REASON_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 204;
#[doc = "< Connection failed"]
pub const wifi_err_reason_t_WIFI_REASON_CONNECTION_FAIL: wifi_err_reason_t = 205;
#[doc = "< AP TSF reset"]
pub const wifi_err_reason_t_WIFI_REASON_AP_TSF_RESET: wifi_err_reason_t = 206;
#[doc = "< Roaming"]
pub const wifi_err_reason_t_WIFI_REASON_ROAMING: wifi_err_reason_t = 207;
#[doc = "< Association comeback time too long"]
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_COMEBACK_TIME_TOO_LONG: wifi_err_reason_t = 208;
#[doc = "< SA query timeout"]
pub const wifi_err_reason_t_WIFI_REASON_SA_QUERY_TIMEOUT: wifi_err_reason_t = 209;
#[doc = "< No AP found with compatible security"]
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND_W_COMPATIBLE_SECURITY: wifi_err_reason_t = 210;
#[doc = "< No AP found in auth mode threshold"]
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND_IN_AUTHMODE_THRESHOLD: wifi_err_reason_t = 211;
#[doc = "< No AP found in RSSI threshold"]
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND_IN_RSSI_THRESHOLD: wifi_err_reason_t = 212;
#[doc = " @brief Wi-Fi disconnection reason codes\n\n These reason codes are used to indicate the cause of disconnection."]
pub type wifi_err_reason_t = crate::c_types::c_uint;
#[doc = "< The channel width is HT20"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_NONE: wifi_second_chan_t = 0;
#[doc = "< The channel width is HT40 and the secondary channel is above the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_ABOVE: wifi_second_chan_t = 1;
#[doc = "< The channel width is HT40 and the secondary channel is below the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_BELOW: wifi_second_chan_t = 2;
#[doc = " @brief Wi-Fi second channel type"]
pub type wifi_second_chan_t = crate::c_types::c_uint;
#[doc = "< Active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< Passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
#[doc = " @brief Wi-Fi scan type"]
pub type wifi_scan_type_t = crate::c_types::c_uint;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< Minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< Maximum active scan time per channel, units: millisecond, values above 1500 ms may\ncause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_time_t {
    #[doc = "< Active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< Passive scan time per channel, units: millisecond, values above 1500 ms may\ncause station to disconnect from AP and are not recommended."]
    pub passive: u32,
}
#[doc = " @brief Channel bitmap for setting specific channels to be scanned"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_channel_bitmap_t {
    #[doc = "< Represents 2.4 GHz channels, that bits can be set as wifi_2g_channel_bit_t shown."]
    pub ghz_2_channels: u16,
    #[doc = "< Represents 5 GHz channels, that bits can be set as wifi_5g_channel_bit_t shown."]
    pub ghz_5_channels: u32,
}
#[doc = " @brief Parameters for an SSID scan"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_config_t {
    #[doc = "< SSID of AP"]
    pub ssid: *mut u8,
    #[doc = "< MAC address of AP"]
    pub bssid: *mut u8,
    #[doc = "< Channel, scan the specific channel"]
    pub channel: u8,
    #[doc = "< Enable it to scan AP whose SSID is hidden"]
    pub show_hidden: bool,
    #[doc = "< Scan type, active or passive"]
    pub scan_type: wifi_scan_type_t,
    #[doc = "< Scan time per channel"]
    pub scan_time: wifi_scan_time_t,
    #[doc = "< Time spent at home channel between scanning consecutive channels."]
    pub home_chan_dwell_time: u8,
    #[doc = "< Channel bitmap for setting specific channels to be scanned.\nPlease note that the 'channel' parameter above needs to be set to 0 to allow scanning by bitmap.\nAlso, note that only allowed channels configured by wifi_country_t can be scanned."]
    pub channel_bitmap: wifi_scan_channel_bitmap_t,
    #[doc = "< Enable it to scan return home channel under coexist"]
    pub coex_background_scan: bool,
}
#[doc = " @brief Parameters default scan configurations"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_default_params_t {
    #[doc = "< Scan time per channel"]
    pub scan_time: wifi_scan_time_t,
    #[doc = "< Time spent at home channel between scanning consecutive channels."]
    pub home_chan_dwell_time: u8,
}
#[doc = "< The cipher type is none"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_NONE: wifi_cipher_type_t = 0;
#[doc = "< The cipher type is WEP40"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP40: wifi_cipher_type_t = 1;
#[doc = "< The cipher type is WEP104"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP104: wifi_cipher_type_t = 2;
#[doc = "< The cipher type is TKIP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP: wifi_cipher_type_t = 3;
#[doc = "< The cipher type is CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_CCMP: wifi_cipher_type_t = 4;
#[doc = "< The cipher type is TKIP and CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP_CCMP: wifi_cipher_type_t = 5;
#[doc = "< The cipher type is AES-CMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_CMAC128: wifi_cipher_type_t = 6;
#[doc = "< The cipher type is SMS4"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_SMS4: wifi_cipher_type_t = 7;
#[doc = "< The cipher type is GCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_GCMP: wifi_cipher_type_t = 8;
#[doc = "< The cipher type is GCMP-256"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_GCMP256: wifi_cipher_type_t = 9;
#[doc = "< The cipher type is AES-GMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_GMAC128: wifi_cipher_type_t = 10;
#[doc = "< The cipher type is AES-GMAC-256"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_GMAC256: wifi_cipher_type_t = 11;
#[doc = "< The cipher type is unknown"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_UNKNOWN: wifi_cipher_type_t = 12;
#[doc = " @brief Wi-Fi cipher type"]
pub type wifi_cipher_type_t = crate::c_types::c_uint;
#[doc = "< Bandwidth is HT20"]
pub const wifi_bandwidth_t_WIFI_BW_HT20: wifi_bandwidth_t = 1;
#[doc = "< Bandwidth is 20 MHz"]
pub const wifi_bandwidth_t_WIFI_BW20: wifi_bandwidth_t = 1;
#[doc = "< Bandwidth is HT40"]
pub const wifi_bandwidth_t_WIFI_BW_HT40: wifi_bandwidth_t = 2;
#[doc = "< Bandwidth is 40 MHz"]
pub const wifi_bandwidth_t_WIFI_BW40: wifi_bandwidth_t = 2;
#[doc = "< Bandwidth is 80 MHz"]
pub const wifi_bandwidth_t_WIFI_BW80: wifi_bandwidth_t = 3;
#[doc = "< Bandwidth is 160 MHz"]
pub const wifi_bandwidth_t_WIFI_BW160: wifi_bandwidth_t = 4;
#[doc = "< Bandwidth is 80 + 80 MHz"]
pub const wifi_bandwidth_t_WIFI_BW80_BW80: wifi_bandwidth_t = 5;
#[doc = " @brief Wi-Fi bandwidth type"]
pub type wifi_bandwidth_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi antenna 0"]
pub const wifi_ant_t_WIFI_ANT_ANT0: wifi_ant_t = 0;
#[doc = "< Wi-Fi antenna 1"]
pub const wifi_ant_t_WIFI_ANT_ANT1: wifi_ant_t = 1;
#[doc = "< Invalid Wi-Fi antenna"]
pub const wifi_ant_t_WIFI_ANT_MAX: wifi_ant_t = 2;
#[doc = " @brief Wi-Fi antenna"]
pub type wifi_ant_t = crate::c_types::c_uint;
#[doc = " @brief Description of a Wi-Fi AP HE Info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_he_ap_info_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< In a M-BSSID set, identifies the non-transmitted BSSID"]
    pub bssid_index: u8,
}
impl wifi_he_ap_info_t {
    #[inline]
    pub fn bss_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_bss_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn partial_bss_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_partial_bss_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bss_color_disabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bss_color_disabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bss_color: u8,
        partial_bss_color: u8,
        bss_color_disabled: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let bss_color: u8 = unsafe { ::core::mem::transmute(bss_color) };
            bss_color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let partial_bss_color: u8 = unsafe { ::core::mem::transmute(partial_bss_color) };
            partial_bss_color as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bss_color_disabled: u8 = unsafe { ::core::mem::transmute(bss_color_disabled) };
            bss_color_disabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Description of a Wi-Fi AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_record_t {
    #[doc = "< MAC address of AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 33usize],
    #[doc = "< Channel of AP"]
    pub primary: u8,
    #[doc = "< Secondary channel of AP"]
    pub second: wifi_second_chan_t,
    #[doc = "< Signal strength of AP. Note that in some rare cases where signal strength is very strong, RSSI values can be slightly positive"]
    pub rssi: i8,
    #[doc = "< Auth mode of AP"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Pairwise cipher of AP"]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< Group cipher of AP"]
    pub group_cipher: wifi_cipher_type_t,
    #[doc = "< Antenna used to receive beacon from AP"]
    pub ant: wifi_ant_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Country information of AP"]
    pub country: wifi_country_t,
    #[doc = "< HE AP info"]
    pub he_ap: wifi_he_ap_info_t,
    #[doc = "< Bandwidth of AP"]
    pub bandwidth: wifi_bandwidth_t,
    #[doc = "< This fields are used only AP bandwidth is 80 and 160 MHz, to transmit the center channel\nfrequency of the BSS. For AP bandwidth is 80 + 80 MHz, it is the center channel frequency\nof the lower frequency segment."]
    pub vht_ch_freq1: u8,
    #[doc = "< this fields are used only AP bandwidth is 80 + 80 MHz, and is used to transmit the center\nchannel frequency of the second segment."]
    pub vht_ch_freq2: u8,
}
impl wifi_ap_record_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11a(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11a(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ax(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ax(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ftm_responder(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ftm_responder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ftm_initiator(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ftm_initiator(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        phy_11a: u32,
        phy_11ac: u32,
        phy_11ax: u32,
        wps: u32,
        ftm_responder: u32,
        ftm_initiator: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let phy_11a: u32 = unsafe { ::core::mem::transmute(phy_11a) };
            phy_11a as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let phy_11ac: u32 = unsafe { ::core::mem::transmute(phy_11ac) };
            phy_11ac as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let phy_11ax: u32 = unsafe { ::core::mem::transmute(phy_11ax) };
            phy_11ax as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ftm_responder: u32 = unsafe { ::core::mem::transmute(ftm_responder) };
            ftm_responder as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ftm_initiator: u32 = unsafe { ::core::mem::transmute(ftm_initiator) };
            ftm_initiator as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Do fast scan, scan will end after find SSID match AP"]
pub const wifi_scan_method_t_WIFI_FAST_SCAN: wifi_scan_method_t = 0;
#[doc = "< All channel scan, scan will end after scan all the channel"]
pub const wifi_scan_method_t_WIFI_ALL_CHANNEL_SCAN: wifi_scan_method_t = 1;
#[doc = " @brief Wi-Fi scan method"]
pub type wifi_scan_method_t = crate::c_types::c_uint;
#[doc = "< Sort match AP in scan list by RSSI"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SIGNAL: wifi_sort_method_t = 0;
#[doc = "< Sort match AP in scan list by security mode"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SECURITY: wifi_sort_method_t = 1;
#[doc = " @brief Wi-Fi sort AP method"]
pub type wifi_sort_method_t = crate::c_types::c_uint;
#[doc = " @brief Structure describing parameters for a Wi-Fi fast scan"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_threshold_t {
    #[doc = "< The minimum rssi to accept in the fast scan mode. Defaults to -127 if set to >= 0"]
    pub rssi: i8,
    #[doc = "< The weakest auth mode to accept in the fast scan mode\nNote: In case this value is not set and password is set as per WPA2 standards(password len >= 8), it will be defaulted to WPA2 and device won't connect to deprecated WEP/WPA networks. Please set auth mode threshold as WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK to connect to WEP/WPA networks"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< The RSSI value of the 5G AP is within the rssi_5g_adjustment range compared to the 2G AP, the 5G AP will be given priority for connection."]
    pub rssi_5g_adjustment: u8,
}
#[doc = "< No power save"]
pub const wifi_ps_type_t_WIFI_PS_NONE: wifi_ps_type_t = 0;
#[doc = "< Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period"]
pub const wifi_ps_type_t_WIFI_PS_MIN_MODEM: wifi_ps_type_t = 1;
#[doc = "< Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t"]
pub const wifi_ps_type_t_WIFI_PS_MAX_MODEM: wifi_ps_type_t = 2;
#[doc = " @brief Wi-Fi power save type"]
pub type wifi_ps_type_t = crate::c_types::c_uint;
#[doc = "< Band is 2.4 GHz"]
pub const wifi_band_t_WIFI_BAND_2G: wifi_band_t = 1;
#[doc = "< Band is 5 GHz"]
pub const wifi_band_t_WIFI_BAND_5G: wifi_band_t = 2;
#[doc = " @brief Argument structure for Wi-Fi band"]
pub type wifi_band_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi band mode is 2.4 GHz only"]
pub const wifi_band_mode_t_WIFI_BAND_MODE_2G_ONLY: wifi_band_mode_t = 1;
#[doc = "< Wi-Fi band mode is 5 GHz only"]
pub const wifi_band_mode_t_WIFI_BAND_MODE_5G_ONLY: wifi_band_mode_t = 2;
#[doc = "< Wi-Fi band mode is 2.4 GHz + 5 GHz"]
pub const wifi_band_mode_t_WIFI_BAND_MODE_AUTO: wifi_band_mode_t = 3;
#[doc = " @brief Argument structure for Wi-Fi band mode"]
pub type wifi_band_mode_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi channel 1"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_1: wifi_2g_channel_bit_t = 2;
#[doc = "< Wi-Fi channel 2"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_2: wifi_2g_channel_bit_t = 4;
#[doc = "< Wi-Fi channel 3"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_3: wifi_2g_channel_bit_t = 8;
#[doc = "< Wi-Fi channel 4"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_4: wifi_2g_channel_bit_t = 16;
#[doc = "< Wi-Fi channel 5"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_5: wifi_2g_channel_bit_t = 32;
#[doc = "< Wi-Fi channel 6"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_6: wifi_2g_channel_bit_t = 64;
#[doc = "< Wi-Fi channel 7"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_7: wifi_2g_channel_bit_t = 128;
#[doc = "< Wi-Fi channel 8"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_8: wifi_2g_channel_bit_t = 256;
#[doc = "< Wi-Fi channel 9"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_9: wifi_2g_channel_bit_t = 512;
#[doc = "< Wi-Fi channel 10"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_10: wifi_2g_channel_bit_t = 1024;
#[doc = "< Wi-Fi channel 11"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_11: wifi_2g_channel_bit_t = 2048;
#[doc = "< Wi-Fi channel 12"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_12: wifi_2g_channel_bit_t = 4096;
#[doc = "< Wi-Fi channel 13"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_13: wifi_2g_channel_bit_t = 8192;
#[doc = "< Wi-Fi channel 14"]
pub const wifi_2g_channel_bit_t_WIFI_CHANNEL_14: wifi_2g_channel_bit_t = 16384;
#[doc = " Argument structure for 2.4G channels"]
pub type wifi_2g_channel_bit_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi channel 36"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_36: wifi_5g_channel_bit_t = 2;
#[doc = "< Wi-Fi channel 40"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_40: wifi_5g_channel_bit_t = 4;
#[doc = "< Wi-Fi channel 44"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_44: wifi_5g_channel_bit_t = 8;
#[doc = "< Wi-Fi channel 48"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_48: wifi_5g_channel_bit_t = 16;
#[doc = "< Wi-Fi channel 52"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_52: wifi_5g_channel_bit_t = 32;
#[doc = "< Wi-Fi channel 56"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_56: wifi_5g_channel_bit_t = 64;
#[doc = "< Wi-Fi channel 60"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_60: wifi_5g_channel_bit_t = 128;
#[doc = "< Wi-Fi channel 64"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_64: wifi_5g_channel_bit_t = 256;
#[doc = "< Wi-Fi channel 100"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_100: wifi_5g_channel_bit_t = 512;
#[doc = "< Wi-Fi channel 104"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_104: wifi_5g_channel_bit_t = 1024;
#[doc = "< Wi-Fi channel 108"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_108: wifi_5g_channel_bit_t = 2048;
#[doc = "< Wi-Fi channel 112"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_112: wifi_5g_channel_bit_t = 4096;
#[doc = "< Wi-Fi channel 116"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_116: wifi_5g_channel_bit_t = 8192;
#[doc = "< Wi-Fi channel 120"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_120: wifi_5g_channel_bit_t = 16384;
#[doc = "< Wi-Fi channel 124"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_124: wifi_5g_channel_bit_t = 32768;
#[doc = "< Wi-Fi channel 128"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_128: wifi_5g_channel_bit_t = 65536;
#[doc = "< Wi-Fi channel 132"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_132: wifi_5g_channel_bit_t = 131072;
#[doc = "< Wi-Fi channel 136"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_136: wifi_5g_channel_bit_t = 262144;
#[doc = "< Wi-Fi channel 140"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_140: wifi_5g_channel_bit_t = 524288;
#[doc = "< Wi-Fi channel 144"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_144: wifi_5g_channel_bit_t = 1048576;
#[doc = "< Wi-Fi channel 149"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_149: wifi_5g_channel_bit_t = 2097152;
#[doc = "< Wi-Fi channel 153"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_153: wifi_5g_channel_bit_t = 4194304;
#[doc = "< Wi-Fi channel 157"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_157: wifi_5g_channel_bit_t = 8388608;
#[doc = "< Wi-Fi channel 161"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_161: wifi_5g_channel_bit_t = 16777216;
#[doc = "< Wi-Fi channel 165"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_165: wifi_5g_channel_bit_t = 33554432;
#[doc = "< Wi-Fi channel 169"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_169: wifi_5g_channel_bit_t = 67108864;
#[doc = "< Wi-Fi channel 173"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_173: wifi_5g_channel_bit_t = 134217728;
#[doc = "< Wi-Fi channel 177"]
pub const wifi_5g_channel_bit_t_WIFI_CHANNEL_177: wifi_5g_channel_bit_t = 268435456;
#[doc = " Argument structure for 5G channels"]
pub type wifi_5g_channel_bit_t = crate::c_types::c_uint;
#[doc = " @brief Description of a Wi-Fi protocols"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_protocols_t {
    #[doc = "< Represents 2.4 GHz protocol, support 802.11b or 802.11g or 802.11n or 802.11ax or LR mode"]
    pub ghz_2g: u16,
    #[doc = "< Represents 5 GHz protocol, support 802.11a or 802.11n or 802.11ac or 802.11ax"]
    pub ghz_5g: u16,
}
#[doc = " @brief Description of a Wi-Fi band bandwidths"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_bandwidths_t {
    #[doc = "< Represents 2.4 GHz bandwidth"]
    pub ghz_2g: wifi_bandwidth_t,
    #[doc = "< Represents 5 GHz bandwidth"]
    pub ghz_5g: wifi_bandwidth_t,
}
#[doc = " @brief Configuration structure for Protected Management Frame"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_pmf_config_t {
    #[doc = "< Deprecated variable. Device will always connect in PMF mode if other device also advertises PMF capability."]
    pub capable: bool,
    #[doc = "< Advertises that Protected Management Frame is required. Device will not associate to non-PMF capable devices."]
    pub required: bool,
}
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_UNSPECIFIED: wifi_sae_pwe_method_t = 0;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_HUNT_AND_PECK: wifi_sae_pwe_method_t = 1;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_HASH_TO_ELEMENT: wifi_sae_pwe_method_t = 2;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_BOTH: wifi_sae_pwe_method_t = 3;
#[doc = " @brief Configuration for SAE PWE derivation"]
pub type wifi_sae_pwe_method_t = crate::c_types::c_uint;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_AUTOMATIC: wifi_sae_pk_mode_t = 0;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_ONLY: wifi_sae_pk_mode_t = 1;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_DISABLED: wifi_sae_pk_mode_t = 2;
#[doc = " @brief Configuration for SAE-PK"]
pub type wifi_sae_pk_mode_t = crate::c_types::c_uint;
#[doc = " @brief Configuration structure for BSS max idle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_bss_max_idle_config_t {
    #[doc = "< Sets BSS Max idle period (1 Unit = 1000TUs OR 1.024 Seconds). If there are no frames for this period from a STA, SoftAP will disassociate due to inactivity. Setting it to 0 disables the feature"]
    pub period: u16,
    #[doc = "< Requires clients to use protected keep alive frames for BSS Max Idle period"]
    pub protected_keep_alive: bool,
}
#[doc = " @brief Soft-AP configuration settings for the device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_config_t {
    #[doc = "< SSID of soft-AP. If ssid_len field is 0, this must be a Null terminated string. Otherwise, length is set according to ssid_len."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of soft-AP."]
    pub password: [u8; 64usize],
    #[doc = "< Optional length of SSID field."]
    pub ssid_len: u8,
    #[doc = "< Channel of soft-AP"]
    pub channel: u8,
    #[doc = "< Auth mode of soft-AP. Do not support AUTH_WEP, AUTH_WAPI_PSK and AUTH_OWE in soft-AP mode. When the auth mode is set to WPA2_PSK, WPA2_WPA3_PSK or WPA3_PSK, the pairwise cipher will be overwritten with WIFI_CIPHER_TYPE_CCMP by default, unless explicitly set."]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Broadcast SSID or not, default 0, broadcast the SSID"]
    pub ssid_hidden: u8,
    #[doc = "< Max number of stations allowed to connect in"]
    pub max_connection: u8,
    #[doc = "< Beacon interval which should be multiples of 100. Unit: TU(time unit, 1 TU = 1024 us). Range: 100 ~ 60000. Default value: 100"]
    pub beacon_interval: u16,
    #[doc = "< Channel Switch Announcement Count. Notify the station that the channel will switch after the csa_count beacon intervals. Default value: 3"]
    pub csa_count: u8,
    #[doc = "< Dtim period of soft-AP. Range: 1 ~ 10. Default value: 1"]
    pub dtim_period: u8,
    #[doc = "< Pairwise cipher of SoftAP, group cipher will be derived using this. Cipher values are valid starting from WIFI_CIPHER_TYPE_TKIP, enum values before that will be considered as invalid and default cipher suites(TKIP+CCMP) will be used. Valid cipher suites in softAP mode are WIFI_CIPHER_TYPE_TKIP, WIFI_CIPHER_TYPE_CCMP, WIFI_CIPHER_TYPE_TKIP_CCMP, WIFI_CIPHER_TYPE_GCMP and WIFI_CIPHER_TYPE_GCMP256."]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< Enable FTM Responder mode"]
    pub ftm_responder: bool,
    #[doc = "< Configuration for Protected Management Frame"]
    pub pmf_cfg: wifi_pmf_config_t,
    #[doc = "< Configuration for SAE PWE derivation method"]
    pub sae_pwe_h2e: wifi_sae_pwe_method_t,
    #[doc = "< Whether to enable transition disable feature"]
    pub transition_disable: u8,
    #[doc = "< Enable SAE EXT feature. SOC_GCMP_SUPPORT is required for this feature."]
    pub sae_ext: u8,
    #[doc = "< Configuration for bss max idle, effective if CONFIG_WIFI_BSS_MAX_IDLE_SUPPORT is enabled"]
    pub bss_max_idle_cfg: wifi_bss_max_idle_config_t,
    #[doc = "< GTK rekeying interval in seconds. If set to 0, GTK rekeying is disabled. Range: 60 ~ 65535 including 0."]
    pub gtk_rekey_interval: u16,
}
#[doc = " @brief STA configuration settings for the device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_config_t {
    #[doc = "< SSID of target AP."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of target AP."]
    pub password: [u8; 64usize],
    #[doc = "< Do all channel scan or fast scan"]
    pub scan_method: wifi_scan_method_t,
    #[doc = "< Whether set MAC address of target AP or not. Generally, station_config.bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< Channel hint for target AP. For 2.4G AP, set to 1~13 to scan starting from the specified channel before connecting to AP. For 5G AP, set to 36~177 (36, 40, 44 ... 177) to scan starting from the specified channel before connecting to AP. Set to 0 for no preference"]
    pub channel: u8,
    #[doc = "< Listen interval for ESP32 station to receive beacon when WIFI_PS_MAX_MODEM is set. Units: AP beacon intervals. Defaults to 3 if set to 0."]
    pub listen_interval: u16,
    #[doc = "< Sort the connect AP in the list by rssi or security mode"]
    pub sort_method: wifi_sort_method_t,
    #[doc = "< When scan_threshold is set, only APs which have an auth mode that is more secure than the selected auth mode and a signal stronger than the minimum RSSI will be used."]
    pub threshold: wifi_scan_threshold_t,
    #[doc = "< Configuration for Protected Management Frame. Will be advertised in RSN Capabilities in RSN IE."]
    pub pmf_cfg: wifi_pmf_config_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Configuration for SAE PWE derivation method"]
    pub sae_pwe_h2e: wifi_sae_pwe_method_t,
    #[doc = "< Configuration for SAE-PK (Public Key) Authentication method"]
    pub sae_pk_mode: wifi_sae_pk_mode_t,
    #[doc = "< Number of connection retries station will do before moving to next AP. scan_method should be set as WIFI_ALL_CHANNEL_SCAN to use this config.\nNote: Enabling this may cause connection time to increase in case best AP doesn't behave properly."]
    pub failure_retry_cnt: u8,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Password identifier for H2E. this needs to be null terminated string"]
    pub sae_h2e_identifier: [u8; 32usize],
}
impl wifi_sta_config_t {
    #[inline]
    pub fn rm_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rm_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btm_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_btm_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbo_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mbo_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ft_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ft_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn owe_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_owe_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transition_disable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transition_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rm_enabled: u32,
        btm_enabled: u32,
        mbo_enabled: u32,
        ft_enabled: u32,
        owe_enabled: u32,
        transition_disable: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rm_enabled: u32 = unsafe { ::core::mem::transmute(rm_enabled) };
            rm_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let btm_enabled: u32 = unsafe { ::core::mem::transmute(btm_enabled) };
            btm_enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mbo_enabled: u32 = unsafe { ::core::mem::transmute(mbo_enabled) };
            mbo_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ft_enabled: u32 = unsafe { ::core::mem::transmute(ft_enabled) };
            ft_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let owe_enabled: u32 = unsafe { ::core::mem::transmute(owe_enabled) };
            owe_enabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let transition_disable: u32 = unsafe { ::core::mem::transmute(transition_disable) };
            transition_disable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn he_dcm_set(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_dcm_max_constellation_tx(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_max_constellation_tx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn he_dcm_max_constellation_rx(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_max_constellation_rx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn he_mcs9_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_mcs9_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_su_beamformee_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_su_beamformee_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_su_bmforming_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_su_bmforming_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_mu_bmforming_partial_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_mu_bmforming_partial_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_cqi_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_cqi_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vht_su_beamformee_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vht_su_beamformee_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vht_mu_beamformee_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vht_mu_beamformee_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vht_mcs8_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vht_mcs8_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        he_dcm_set: u32,
        he_dcm_max_constellation_tx: u32,
        he_dcm_max_constellation_rx: u32,
        he_mcs9_enabled: u32,
        he_su_beamformee_disabled: u32,
        he_trig_su_bmforming_feedback_disabled: u32,
        he_trig_mu_bmforming_partial_feedback_disabled: u32,
        he_trig_cqi_feedback_disabled: u32,
        vht_su_beamformee_disabled: u32,
        vht_mu_beamformee_disabled: u32,
        vht_mcs8_enabled: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let he_dcm_set: u32 = unsafe { ::core::mem::transmute(he_dcm_set) };
            he_dcm_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let he_dcm_max_constellation_tx: u32 =
                unsafe { ::core::mem::transmute(he_dcm_max_constellation_tx) };
            he_dcm_max_constellation_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let he_dcm_max_constellation_rx: u32 =
                unsafe { ::core::mem::transmute(he_dcm_max_constellation_rx) };
            he_dcm_max_constellation_rx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let he_mcs9_enabled: u32 = unsafe { ::core::mem::transmute(he_mcs9_enabled) };
            he_mcs9_enabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let he_su_beamformee_disabled: u32 =
                unsafe { ::core::mem::transmute(he_su_beamformee_disabled) };
            he_su_beamformee_disabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let he_trig_su_bmforming_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_su_bmforming_feedback_disabled) };
            he_trig_su_bmforming_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let he_trig_mu_bmforming_partial_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_mu_bmforming_partial_feedback_disabled) };
            he_trig_mu_bmforming_partial_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let he_trig_cqi_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_cqi_feedback_disabled) };
            he_trig_cqi_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let vht_su_beamformee_disabled: u32 =
                unsafe { ::core::mem::transmute(vht_su_beamformee_disabled) };
            vht_su_beamformee_disabled as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let vht_mu_beamformee_disabled: u32 =
                unsafe { ::core::mem::transmute(vht_mu_beamformee_disabled) };
            vht_mu_beamformee_disabled as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let vht_mcs8_enabled: u32 = unsafe { ::core::mem::transmute(vht_mcs8_enabled) };
            vht_mcs8_enabled as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Discovery start configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_config_t {
    #[doc = "< NAN Discovery operating channel"]
    pub op_channel: u8,
    #[doc = "< Device's preference value to serve as NAN Master"]
    pub master_pref: u8,
    #[doc = "< Scan time in seconds while searching for a NAN cluster"]
    pub scan_time: u8,
    #[doc = "< Warm up time before assuming NAN Anchor Master role"]
    pub warm_up_sec: u16,
}
#[doc = " @brief Configuration data for device's AP or STA or NAN.\n\n The usage of this union (for ap, sta or nan configuration) is determined by the accompanying\n interface argument passed to esp_wifi_set_config() or esp_wifi_get_config()\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_config_t {
    #[doc = "< Configuration of AP"]
    pub ap: wifi_ap_config_t,
    #[doc = "< Configuration of STA"]
    pub sta: wifi_sta_config_t,
    #[doc = "< Configuration of NAN"]
    pub nan: wifi_nan_config_t,
}
#[doc = " @brief Description of STA associated with AP"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wifi_sta_info_t {
    #[doc = "< MAC address"]
    pub mac: [u8; 6usize],
    #[doc = "< Current average rssi of sta connected"]
    pub rssi: i8,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wifi_sta_info_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11a(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11a(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ax(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ax(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mesh_child(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mesh_child(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        phy_11a: u32,
        phy_11ac: u32,
        phy_11ax: u32,
        is_mesh_child: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let phy_11a: u32 = unsafe { ::core::mem::transmute(phy_11a) };
            phy_11a as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let phy_11ac: u32 = unsafe { ::core::mem::transmute(phy_11ac) };
            phy_11ac as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let phy_11ax: u32 = unsafe { ::core::mem::transmute(phy_11ax) };
            phy_11ax as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_mesh_child: u32 = unsafe { ::core::mem::transmute(is_mesh_child) };
            is_mesh_child as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< All configuration will store in both memory and flash"]
pub const wifi_storage_t_WIFI_STORAGE_FLASH: wifi_storage_t = 0;
#[doc = "< All configuration will only store in the memory"]
pub const wifi_storage_t_WIFI_STORAGE_RAM: wifi_storage_t = 1;
#[doc = " @brief Wi-Fi storage type"]
pub type wifi_storage_t = crate::c_types::c_uint;
#[doc = "< Beacon frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_BEACON: wifi_vendor_ie_type_t = 0;
#[doc = "< Probe request frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_REQ: wifi_vendor_ie_type_t = 1;
#[doc = "< Probe response frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_RESP: wifi_vendor_ie_type_t = 2;
#[doc = "< Association request frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_REQ: wifi_vendor_ie_type_t = 3;
#[doc = "< Association response frame"]
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_RESP: wifi_vendor_ie_type_t = 4;
#[doc = " @brief     Vendor Information Element type\n\n Determines the frame type that the IE will be associated with."]
pub type wifi_vendor_ie_type_t = crate::c_types::c_uint;
#[doc = "< Vendor ID element 0"]
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_0: wifi_vendor_ie_id_t = 0;
#[doc = "< Vendor ID element 1"]
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_1: wifi_vendor_ie_id_t = 1;
#[doc = " @brief     Vendor Information Element index\n\n Each IE type can have up to two associated vendor ID elements."]
pub type wifi_vendor_ie_id_t = crate::c_types::c_uint;
#[doc = "< PHY mode for Low Rate"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_LR: wifi_phy_mode_t = 0;
#[doc = "< PHY mode for 11b"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_11B: wifi_phy_mode_t = 1;
#[doc = "< PHY mode for 11g"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_11G: wifi_phy_mode_t = 2;
#[doc = "< PHY mode for 11a"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_11A: wifi_phy_mode_t = 3;
#[doc = "< PHY mode for Bandwidth HT20"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HT20: wifi_phy_mode_t = 4;
#[doc = "< PHY mode for Bandwidth HT40"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HT40: wifi_phy_mode_t = 5;
#[doc = "< PHY mode for Bandwidth HE20"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HE20: wifi_phy_mode_t = 6;
#[doc = "< PHY mode for Bandwidth VHT20"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_VHT20: wifi_phy_mode_t = 7;
#[doc = " @brief     Operation PHY mode"]
pub type wifi_phy_mode_t = crate::c_types::c_uint;
#[doc = " @brief Vendor Information Element header\n\n The first bytes of the Information Element will match this header. Payload follows."]
#[repr(C)]
pub struct vendor_ie_data_t {
    #[doc = "< Should be set to WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    pub element_id: u8,
    #[doc = "< Length of all bytes in the element data following this field. Minimum 4."]
    pub length: u8,
    #[doc = "< Vendor identifier (OUI)."]
    pub vendor_oui: [u8; 3usize],
    #[doc = "< Vendor-specific OUI type."]
    pub vendor_oui_type: u8,
    #[doc = "< Payload. Length is equal to value in 'length' field, minus 4."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = "< Management frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MGMT: wifi_promiscuous_pkt_type_t = 0;
#[doc = "< Control frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_CTRL: wifi_promiscuous_pkt_type_t = 1;
#[doc = "< Data frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_DATA: wifi_promiscuous_pkt_type_t = 2;
#[doc = "< Other type, such as MIMO etc. 'buf' argument is wifi_promiscuous_pkt_t but the payload is zero length."]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MISC: wifi_promiscuous_pkt_type_t = 3;
#[doc = " @brief Promiscuous frame type\n\n Passed to promiscuous mode RX callback to indicate the type of parameter in the buffer.\n"]
pub type wifi_promiscuous_pkt_type_t = crate::c_types::c_uint;
#[doc = " @brief Mask for filtering different packet types in promiscuous mode"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_promiscuous_filter_t {
    #[doc = "< OR of one or more filter values WIFI_PROMIS_FILTER_*"]
    pub filter_mask: u32,
}
#[doc = " @brief Wi-Fi GPIO configuration for antenna selection\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_ant_gpio_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl wifi_ant_gpio_t {
    #[inline]
    pub fn gpio_select(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_select(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_num(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_num(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gpio_select: u8, gpio_num: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpio_select: u8 = unsafe { ::core::mem::transmute(gpio_select) };
            gpio_select as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let gpio_num: u8 = unsafe { ::core::mem::transmute(gpio_num) };
            gpio_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Wi-Fi GPIOs configuration for antenna selection\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ant_gpio_config_t {
    #[doc = "< The configurations of GPIOs that connect to external antenna switch"]
    pub gpio_cfg: [wifi_ant_gpio_t; 4usize],
}
#[doc = "< Enable Wi-Fi antenna 0 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT0: wifi_ant_mode_t = 0;
#[doc = "< Enable Wi-Fi antenna 1 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT1: wifi_ant_mode_t = 1;
#[doc = "< Enable Wi-Fi antenna 0 and 1, automatically select an antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_AUTO: wifi_ant_mode_t = 2;
#[doc = "< Invalid Wi-Fi enabled antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_MAX: wifi_ant_mode_t = 3;
#[doc = " @brief Wi-Fi antenna mode\n"]
pub type wifi_ant_mode_t = crate::c_types::c_uint;
#[doc = " @brief Wi-Fi antenna configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ant_config_t {
    #[doc = "< Wi-Fi antenna mode for receiving"]
    pub rx_ant_mode: wifi_ant_mode_t,
    #[doc = "< Default antenna mode for receiving, it's ignored if rx_ant_mode is not WIFI_ANT_MODE_AUTO"]
    pub rx_ant_default: wifi_ant_t,
    #[doc = "< Wi-Fi antenna mode for transmission, it can be set to WIFI_ANT_MODE_AUTO only if rx_ant_mode is set to WIFI_ANT_MODE_AUTO"]
    pub tx_ant_mode: wifi_ant_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl wifi_ant_config_t {
    #[inline]
    pub fn enabled_ant0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled_ant1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled_ant0: u8,
        enabled_ant1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let enabled_ant0: u8 = unsafe { ::core::mem::transmute(enabled_ant0) };
            enabled_ant0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let enabled_ant1: u8 = unsafe { ::core::mem::transmute(enabled_ant1) };
            enabled_ant1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief     The Rx callback function of Action Tx operations\n\n @param     hdr Pointer to the IEEE 802.11 Header structure\n @param     payload Pointer to the Payload following 802.11 Header\n @param     len Length of the Payload\n @param     channel Channel number the frame is received on\n"]
pub type wifi_action_rx_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        hdr: *mut u8,
        payload: *mut u8,
        len: usize,
        channel: u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Action Frame Tx Request"]
#[repr(C)]
pub struct wifi_action_tx_req_t {
    #[doc = "< Wi-Fi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< Destination MAC address"]
    pub dest_mac: [u8; 6usize],
    #[doc = "< ACTION TX operation type"]
    pub type_: wifi_action_tx_t,
    #[doc = "< Channel on which to perform ACTION TX Operation"]
    pub channel: u8,
    #[doc = "< Duration to wait for on target channel"]
    pub wait_time_ms: u32,
    #[doc = "< Indicates no ack required"]
    pub no_ack: bool,
    #[doc = "< Rx Callback to receive action frames"]
    pub rx_cb: wifi_action_rx_cb_t,
    #[doc = "< Unique Identifier for operation provided by wifi driver"]
    pub op_id: u8,
    #[doc = "< Length of the appended Data"]
    pub data_len: u32,
    #[doc = "< Appended Data payload"]
    pub data: __IncompleteArrayField<u8>,
}
#[doc = "< ROC operation was completed successfully"]
pub const wifi_roc_done_status_t_WIFI_ROC_DONE: wifi_roc_done_status_t = 0;
#[doc = "< ROC operation was cancelled"]
pub const wifi_roc_done_status_t_WIFI_ROC_FAIL: wifi_roc_done_status_t = 1;
#[doc = " Status codes for WIFI_EVENT_ROC_DONE evt"]
pub type wifi_roc_done_status_t = crate::c_types::c_uint;
#[doc = " @brief     The callback function executed when ROC operation has ended\n\n @param     context rxcb registered for the corresponding ROC operation\n @param     op_id  ID of the corresponding ROC operation\n @param     status status code of the ROC operation denoted\n"]
pub type wifi_action_roc_done_cb_t = ::core::option::Option<
    unsafe extern "C" fn(context: u32, op_id: u8, status: wifi_roc_done_status_t),
>;
#[doc = " @brief Remain on Channel request\n\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_roc_req_t {
    #[doc = "< WiFi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< ROC operation type"]
    pub type_: wifi_roc_t,
    #[doc = "< Channel on which to perform ROC Operation"]
    pub channel: u8,
    #[doc = "< Secondary channel"]
    pub sec_channel: wifi_second_chan_t,
    #[doc = "< Duration to wait for on target channel"]
    pub wait_time_ms: u32,
    #[doc = "< Rx Callback to receive any response"]
    pub rx_cb: wifi_action_rx_cb_t,
    #[doc = "< ID of this specific ROC operation provided by wifi driver"]
    pub op_id: u8,
    #[doc = "< Callback to function that will be called upon ROC done. If assigned, WIFI_EVENT_ROC_DONE event will not be posted"]
    pub done_cb: wifi_action_roc_done_cb_t,
}
#[doc = " @brief FTM Initiator configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ftm_initiator_cfg_t {
    #[doc = "< MAC address of the FTM Responder"]
    pub resp_mac: [u8; 6usize],
    #[doc = "< Primary channel of the FTM Responder"]
    pub channel: u8,
    #[doc = "< No. of FTM frames requested in terms of 4 or 8 bursts (allowed values - 0(No pref), 16, 24, 32, 64)"]
    pub frm_count: u8,
    #[doc = "< Requested period between FTM bursts in 100's of milliseconds (allowed values 0(No pref) - 100)"]
    pub burst_period: u16,
    #[doc = "< True - Using esp_wifi_ftm_get_report to get FTM report, False - Using ftm_report_data from\nWIFI_EVENT_FTM_REPORT to get FTM report"]
    pub use_get_report_api: bool,
}
#[doc = "< Value 0 Reserved"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_RESERVED: wifi_nan_svc_proto_t = 0;
#[doc = "< Bonjour Protocol"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_BONJOUR: wifi_nan_svc_proto_t = 1;
#[doc = "< Generic Service Protocol"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_GENERIC: wifi_nan_svc_proto_t = 2;
#[doc = "< CSA Matter specific protocol"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_CSA_MATTER: wifi_nan_svc_proto_t = 3;
#[doc = "< Values 4-255 Reserved"]
pub const wifi_nan_svc_proto_t_WIFI_SVC_PROTO_MAX: wifi_nan_svc_proto_t = 4;
#[doc = " @brief Protocol types in NAN service specific info attribute\n"]
pub type wifi_nan_svc_proto_t = crate::c_types::c_uint;
#[doc = " @brief WFA defined Protocol types in NAN service specific info attribute\n"]
#[repr(C)]
pub struct wifi_nan_wfa_ssi_t {
    #[doc = "< WFA OUI - 0x50, 0x6F, 0x9A"]
    pub wfa_oui: [u8; 3usize],
    #[doc = "< WFA defined protocol types"]
    pub proto: wifi_nan_svc_proto_t,
    #[doc = "< Service Info payload"]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = "< Send unicast Publish frame to Subscribers that match the requirement"]
pub const wifi_nan_service_type_t_NAN_PUBLISH_SOLICITED: wifi_nan_service_type_t = 0;
#[doc = "< Send broadcast Publish frames in every Discovery Window(DW)"]
pub const wifi_nan_service_type_t_NAN_PUBLISH_UNSOLICITED: wifi_nan_service_type_t = 1;
#[doc = "< Send broadcast Subscribe frames in every DW"]
pub const wifi_nan_service_type_t_NAN_SUBSCRIBE_ACTIVE: wifi_nan_service_type_t = 2;
#[doc = "< Passively listens to Publish frames"]
pub const wifi_nan_service_type_t_NAN_SUBSCRIBE_PASSIVE: wifi_nan_service_type_t = 3;
#[doc = " @brief NAN Services types\n"]
pub type wifi_nan_service_type_t = crate::c_types::c_uint;
#[doc = " @brief NAN Publish service configuration parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_publish_cfg_t {
    #[doc = "< Service name identifier"]
    pub service_name: [crate::c_types::c_char; 256usize],
    #[doc = "< Service type"]
    pub type_: wifi_nan_service_type_t,
    #[doc = "< Comma separated filters for filtering services"]
    pub matching_filter: [crate::c_types::c_char; 256usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [crate::c_types::c_char; 64usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Length of service specific info, maximum allowed length - ESP_WIFI_MAX_SVC_SSI_LEN"]
    pub ssi_len: u16,
    #[doc = "< Service Specific Info of type wifi_nan_wfa_ssi_t for WFA defined protocols, otherwise proprietary and defined by Applications"]
    pub ssi: *mut u8,
}
impl wifi_nan_publish_cfg_t {
    #[inline]
    pub fn single_replied_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_replied_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn datapath_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_datapath_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_gas(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_gas(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single_replied_event: u8,
        datapath_reqd: u8,
        fsd_reqd: u8,
        fsd_gas: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single_replied_event: u8 = unsafe { ::core::mem::transmute(single_replied_event) };
            single_replied_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let datapath_reqd: u8 = unsafe { ::core::mem::transmute(datapath_reqd) };
            datapath_reqd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fsd_reqd: u8 = unsafe { ::core::mem::transmute(fsd_reqd) };
            fsd_reqd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fsd_gas: u8 = unsafe { ::core::mem::transmute(fsd_gas) };
            fsd_gas as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Subscribe service configuration parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_subscribe_cfg_t {
    #[doc = "< Service name identifier"]
    pub service_name: [crate::c_types::c_char; 256usize],
    #[doc = "< Service type"]
    pub type_: wifi_nan_service_type_t,
    #[doc = "< Comma separated filters for filtering services"]
    pub matching_filter: [crate::c_types::c_char; 256usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [crate::c_types::c_char; 64usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Length of service specific info, maximum allowed length - ESP_WIFI_MAX_SVC_SSI_LEN"]
    pub ssi_len: u16,
    #[doc = "< Service Specific Info of type wifi_nan_wfa_ssi_t for WFA defined protocols, otherwise proprietary and defined by Applications"]
    pub ssi: *mut u8,
}
impl wifi_nan_subscribe_cfg_t {
    #[inline]
    pub fn single_match_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_match_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn datapath_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_datapath_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_gas(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_gas(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single_match_event: u8,
        datapath_reqd: u8,
        fsd_reqd: u8,
        fsd_gas: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single_match_event: u8 = unsafe { ::core::mem::transmute(single_match_event) };
            single_match_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let datapath_reqd: u8 = unsafe { ::core::mem::transmute(datapath_reqd) };
            datapath_reqd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fsd_reqd: u8 = unsafe { ::core::mem::transmute(fsd_reqd) };
            fsd_reqd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fsd_gas: u8 = unsafe { ::core::mem::transmute(fsd_gas) };
            fsd_gas as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Follow-up parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_followup_params_t {
    #[doc = "< Own service instance id"]
    pub inst_id: u8,
    #[doc = "< Peer's service instance id"]
    pub peer_inst_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [crate::c_types::c_char; 64usize],
    #[doc = "< Length of service specific info, maximum allowed length - ESP_WIFI_MAX_FUP_SSI_LEN"]
    pub ssi_len: u16,
    #[doc = "< Service Specific Info of type wifi_nan_wfa_ssi_t for WFA defined protocols, otherwise proprietary and defined by Applications"]
    pub ssi: *mut u8,
}
#[doc = " @brief NAN Datapath Request parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_req_t {
    #[doc = "< Publisher's service instance id"]
    pub pub_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< NDP Confirm frame required"]
    pub confirm_required: bool,
}
#[doc = " @brief NAN Datapath Response parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_resp_t {
    #[doc = "< True - Accept incoming NDP, False - Reject it"]
    pub accept: bool,
    #[doc = "< NAN Datapath Identifier"]
    pub ndp_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
}
#[doc = " @brief NAN Datapath End parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_end_req_t {
    #[doc = "< NAN Datapath Identifier"]
    pub ndp_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
}
#[doc = "< 1 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_1M_L: wifi_phy_rate_t = 0;
#[doc = "< 2 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_L: wifi_phy_rate_t = 1;
#[doc = "< 5.5 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_L: wifi_phy_rate_t = 2;
#[doc = "< 11 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_L: wifi_phy_rate_t = 3;
#[doc = "< 2 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_S: wifi_phy_rate_t = 5;
#[doc = "< 5.5 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_S: wifi_phy_rate_t = 6;
#[doc = "< 11 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_S: wifi_phy_rate_t = 7;
#[doc = "< 48 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_48M: wifi_phy_rate_t = 8;
#[doc = "< 24 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_24M: wifi_phy_rate_t = 9;
#[doc = "< 12 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_12M: wifi_phy_rate_t = 10;
#[doc = "< 6 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_6M: wifi_phy_rate_t = 11;
#[doc = "< 54 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_54M: wifi_phy_rate_t = 12;
#[doc = "< 36 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_36M: wifi_phy_rate_t = 13;
#[doc = "< 18 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_18M: wifi_phy_rate_t = 14;
#[doc = "< 9 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_9M: wifi_phy_rate_t = 15;
#[doc = "< MCS0 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_LGI: wifi_phy_rate_t = 16;
#[doc = "< MCS1 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_LGI: wifi_phy_rate_t = 17;
#[doc = "< MCS2 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_LGI: wifi_phy_rate_t = 18;
#[doc = "< MCS3 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_LGI: wifi_phy_rate_t = 19;
#[doc = "< MCS4 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_LGI: wifi_phy_rate_t = 20;
#[doc = "< MCS5 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_LGI: wifi_phy_rate_t = 21;
#[doc = "< MCS6 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_LGI: wifi_phy_rate_t = 22;
#[doc = "< MCS7 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_LGI: wifi_phy_rate_t = 23;
#[doc = "< MCS0 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_SGI: wifi_phy_rate_t = 24;
#[doc = "< MCS1 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_SGI: wifi_phy_rate_t = 25;
#[doc = "< MCS2 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_SGI: wifi_phy_rate_t = 26;
#[doc = "< MCS3 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_SGI: wifi_phy_rate_t = 27;
#[doc = "< MCS4 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_SGI: wifi_phy_rate_t = 28;
#[doc = "< MCS5 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_SGI: wifi_phy_rate_t = 29;
#[doc = "< MCS6 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_SGI: wifi_phy_rate_t = 30;
#[doc = "< MCS7 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_SGI: wifi_phy_rate_t = 31;
#[doc = "< Espressif-specific Long Range mode rate, 250 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_250K: wifi_phy_rate_t = 41;
#[doc = "< Espressif-specific Long Range mode rate, 500 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_500K: wifi_phy_rate_t = 42;
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MAX: wifi_phy_rate_t = 43;
#[doc = " @brief Wi-Fi PHY rate encodings\n\n @note Rate Table: MCS Rate and Guard Interval Information\n |       MCS RATE              |          HT20           |          HT40           |          HE20           |         VHT20           |\n |-----------------------------|-------------------------|-------------------------|-------------------------|-------------------------|\n | WIFI_PHY_RATE_MCS0_LGI      |     6.5 Mbps (800 ns)   |    13.5 Mbps (800 ns)   |     8.1 Mbps (1600 ns)  |     6.5 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS1_LGI      |      13 Mbps (800 ns)   |      27 Mbps (800 ns)   |    16.3 Mbps (1600 ns)  |      13 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS2_LGI      |    19.5 Mbps (800 ns)   |    40.5 Mbps (800 ns)   |    24.4 Mbps (1600 ns)  |    19.5 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS3_LGI      |      26 Mbps (800 ns)   |      54 Mbps (800 ns)   |    32.5 Mbps (1600 ns)  |      26 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS4_LGI      |      39 Mbps (800 ns)   |      81 Mbps (800 ns)   |    48.8 Mbps (1600 ns)  |      39 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS5_LGI      |      52 Mbps (800 ns)   |     108 Mbps (800 ns)   |      65 Mbps (1600 ns)  |      52 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS6_LGI      |    58.5 Mbps (800 ns)   |   121.5 Mbps (800 ns)   |    73.1 Mbps (1600 ns)  |    58.5 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS7_LGI      |      65 Mbps (800 ns)   |     135 Mbps (800 ns)   |    81.3 Mbps (1600 ns)  |      65 Mbps (800 ns)   |\n | WIFI_PHY_RATE_MCS8_LGI      |                         |                         |    97.5 Mbps (1600 ns)  |                         |\n | WIFI_PHY_RATE_MCS9_LGI      |                         |                         |   108.3 Mbps (1600 ns)  |                         |\n\n @note\n |       MCS RATE              |          HT20           |          HT40           |          HE20           |         VHT20           |\n |-----------------------------|-------------------------|-------------------------|-------------------------|-------------------------|\n | WIFI_PHY_RATE_MCS0_SGI      |     7.2 Mbps (400 ns)   |      15 Mbps (400 ns)   |      8.6 Mbps (800 ns)  |     7.2 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS1_SGI      |    14.4 Mbps (400 ns)   |      30 Mbps (400 ns)   |     17.2 Mbps (800 ns)  |    14.4 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS2_SGI      |    21.7 Mbps (400 ns)   |      45 Mbps (400 ns)   |     25.8 Mbps (800 ns)  |    21.7 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS3_SGI      |    28.9 Mbps (400 ns)   |      60 Mbps (400 ns)   |     34.4 Mbps (800 ns)  |    28.9 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS4_SGI      |    43.3 Mbps (400 ns)   |      90 Mbps (400 ns)   |     51.6 Mbps (800 ns)  |    43.3 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS5_SGI      |    57.8 Mbps (400 ns)   |     120 Mbps (400 ns)   |     68.8 Mbps (800 ns)  |    57.8 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS6_SGI      |      65 Mbps (400 ns)   |     135 Mbps (400 ns)   |     77.4 Mbps (800 ns)  |      65 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS7_SGI      |    72.2 Mbps (400 ns)   |     150 Mbps (400 ns)   |       86 Mbps (800 ns)  |    72.2 Mbps (400 ns)   |\n | WIFI_PHY_RATE_MCS8_SGI      |                         |                         |    103.2 Mbps (800 ns)  |                         |\n | WIFI_PHY_RATE_MCS9_SGI      |                         |                         |    114.7 Mbps (800 ns)  |                         |\n"]
pub type wifi_phy_rate_t = crate::c_types::c_uint;
#[doc = "< Wi-Fi ready"]
pub const wifi_event_t_WIFI_EVENT_WIFI_READY: wifi_event_t = 0;
#[doc = "< Finished scanning AP"]
pub const wifi_event_t_WIFI_EVENT_SCAN_DONE: wifi_event_t = 1;
#[doc = "< Station start"]
pub const wifi_event_t_WIFI_EVENT_STA_START: wifi_event_t = 2;
#[doc = "< Station stop"]
pub const wifi_event_t_WIFI_EVENT_STA_STOP: wifi_event_t = 3;
#[doc = "< Station connected to AP"]
pub const wifi_event_t_WIFI_EVENT_STA_CONNECTED: wifi_event_t = 4;
#[doc = "< Station disconnected from AP"]
pub const wifi_event_t_WIFI_EVENT_STA_DISCONNECTED: wifi_event_t = 5;
#[doc = "< The auth mode of AP connected by device's station changed"]
pub const wifi_event_t_WIFI_EVENT_STA_AUTHMODE_CHANGE: wifi_event_t = 6;
#[doc = "< Station WPS succeeds in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_SUCCESS: wifi_event_t = 7;
#[doc = "< Station WPS fails in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_FAILED: wifi_event_t = 8;
#[doc = "< Station WPS timeout in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_TIMEOUT: wifi_event_t = 9;
#[doc = "< Station WPS pin code in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PIN: wifi_event_t = 10;
#[doc = "< Station WPS overlap in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP: wifi_event_t = 11;
#[doc = "< Soft-AP start"]
pub const wifi_event_t_WIFI_EVENT_AP_START: wifi_event_t = 12;
#[doc = "< Soft-AP stop"]
pub const wifi_event_t_WIFI_EVENT_AP_STOP: wifi_event_t = 13;
#[doc = "< A station connected to Soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STACONNECTED: wifi_event_t = 14;
#[doc = "< A station disconnected from Soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STADISCONNECTED: wifi_event_t = 15;
#[doc = "< Receive probe request packet in soft-AP interface"]
pub const wifi_event_t_WIFI_EVENT_AP_PROBEREQRECVED: wifi_event_t = 16;
#[doc = "< Receive report of FTM procedure"]
pub const wifi_event_t_WIFI_EVENT_FTM_REPORT: wifi_event_t = 17;
#[doc = "< AP's RSSI crossed configured threshold"]
pub const wifi_event_t_WIFI_EVENT_STA_BSS_RSSI_LOW: wifi_event_t = 18;
#[doc = "< Status indication of Action Tx operation"]
pub const wifi_event_t_WIFI_EVENT_ACTION_TX_STATUS: wifi_event_t = 19;
#[doc = "< Remain-on-Channel operation complete"]
pub const wifi_event_t_WIFI_EVENT_ROC_DONE: wifi_event_t = 20;
#[doc = "< Station beacon timeout"]
pub const wifi_event_t_WIFI_EVENT_STA_BEACON_TIMEOUT: wifi_event_t = 21;
#[doc = "< Connectionless module wake interval start"]
pub const wifi_event_t_WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START: wifi_event_t = 22;
#[doc = "< Soft-AP wps succeeds in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_SUCCESS: wifi_event_t = 23;
#[doc = "< Soft-AP wps fails in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_FAILED: wifi_event_t = 24;
#[doc = "< Soft-AP wps timeout in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_TIMEOUT: wifi_event_t = 25;
#[doc = "< Soft-AP wps pin code in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_PIN: wifi_event_t = 26;
#[doc = "< Soft-AP wps overlap in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_PBC_OVERLAP: wifi_event_t = 27;
#[doc = "< iTWT setup"]
pub const wifi_event_t_WIFI_EVENT_ITWT_SETUP: wifi_event_t = 28;
#[doc = "< iTWT teardown"]
pub const wifi_event_t_WIFI_EVENT_ITWT_TEARDOWN: wifi_event_t = 29;
#[doc = "< iTWT probe"]
pub const wifi_event_t_WIFI_EVENT_ITWT_PROBE: wifi_event_t = 30;
#[doc = "< iTWT suspend"]
pub const wifi_event_t_WIFI_EVENT_ITWT_SUSPEND: wifi_event_t = 31;
#[doc = "< TWT wakeup"]
pub const wifi_event_t_WIFI_EVENT_TWT_WAKEUP: wifi_event_t = 32;
#[doc = "< bTWT setup"]
pub const wifi_event_t_WIFI_EVENT_BTWT_SETUP: wifi_event_t = 33;
#[doc = "< bTWT teardown"]
pub const wifi_event_t_WIFI_EVENT_BTWT_TEARDOWN: wifi_event_t = 34;
#[doc = "< NAN Discovery has started"]
pub const wifi_event_t_WIFI_EVENT_NAN_STARTED: wifi_event_t = 35;
#[doc = "< NAN Discovery has stopped"]
pub const wifi_event_t_WIFI_EVENT_NAN_STOPPED: wifi_event_t = 36;
#[doc = "< NAN Service Discovery match found"]
pub const wifi_event_t_WIFI_EVENT_NAN_SVC_MATCH: wifi_event_t = 37;
#[doc = "< Replied to a NAN peer with Service Discovery match"]
pub const wifi_event_t_WIFI_EVENT_NAN_REPLIED: wifi_event_t = 38;
#[doc = "< Received a Follow-up message"]
pub const wifi_event_t_WIFI_EVENT_NAN_RECEIVE: wifi_event_t = 39;
#[doc = "< Received NDP Request from a NAN Peer"]
pub const wifi_event_t_WIFI_EVENT_NDP_INDICATION: wifi_event_t = 40;
#[doc = "< NDP Confirm Indication"]
pub const wifi_event_t_WIFI_EVENT_NDP_CONFIRM: wifi_event_t = 41;
#[doc = "< NAN Datapath terminated indication"]
pub const wifi_event_t_WIFI_EVENT_NDP_TERMINATED: wifi_event_t = 42;
#[doc = "< Wi-Fi home channel change，doesn't occur when scanning"]
pub const wifi_event_t_WIFI_EVENT_HOME_CHANNEL_CHANGE: wifi_event_t = 43;
#[doc = "< Received Neighbor Report response"]
pub const wifi_event_t_WIFI_EVENT_STA_NEIGHBOR_REP: wifi_event_t = 44;
#[doc = "< a station tried to connect with wrong password"]
pub const wifi_event_t_WIFI_EVENT_AP_WRONG_PASSWORD: wifi_event_t = 45;
#[doc = "< Station sampled beacon offset unstable"]
pub const wifi_event_t_WIFI_EVENT_STA_BEACON_OFFSET_UNSTABLE: wifi_event_t = 46;
#[doc = "< DPP URI is ready through Bootstrapping"]
pub const wifi_event_t_WIFI_EVENT_DPP_URI_READY: wifi_event_t = 47;
#[doc = "< Config received via DPP Authentication"]
pub const wifi_event_t_WIFI_EVENT_DPP_CFG_RECVD: wifi_event_t = 48;
#[doc = "< DPP failed"]
pub const wifi_event_t_WIFI_EVENT_DPP_FAILED: wifi_event_t = 49;
#[doc = "< Invalid Wi-Fi event ID"]
pub const wifi_event_t_WIFI_EVENT_MAX: wifi_event_t = 50;
#[doc = " @brief Wi-Fi event declarations"]
pub type wifi_event_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @cond **/\n/** @brief Wi-Fi event base declaration"]
    pub static WIFI_EVENT: esp_event_base_t;
}
#[doc = " @brief Argument structure for WIFI_EVENT_SCAN_DONE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_scan_done_t {
    #[doc = "< Status of scanning APs: 0 — success, 1 - failure"]
    pub status: u32,
    #[doc = "< Number of scan results"]
    pub number: u8,
    #[doc = "< Scan sequence number, used for block scan"]
    pub scan_id: u8,
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_CONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_connected_t {
    #[doc = "< SSID of connected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of connected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of connected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< Channel of connected AP"]
    pub channel: u8,
    #[doc = "< Authentication mode used by the connection"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Authentication id assigned by the connected AP"]
    pub aid: u16,
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_DISCONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_disconnected_t {
    #[doc = "< SSID of disconnected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of disconnected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of disconnected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< Disconnection reason"]
    pub reason: u8,
    #[doc = "< Disconnection RSSI"]
    pub rssi: i8,
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_AUTHMODE_CHANGE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_authmode_change_t {
    #[doc = "< Old auth mode of AP"]
    pub old_mode: wifi_auth_mode_t,
    #[doc = "< New auth mode of AP"]
    pub new_mode: wifi_auth_mode_t,
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_WPS_ER_PIN event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< WPS normal fail reason"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_NORMAL:
    wifi_event_sta_wps_fail_reason_t = 0;
#[doc = "< WPS receive M2D frame"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_RECV_M2D:
    wifi_event_sta_wps_fail_reason_t = 1;
#[doc = "< Recv deauth from AP while wps handshake"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_RECV_DEAUTH:
    wifi_event_sta_wps_fail_reason_t = 2;
#[doc = "< Max WPS fail reason"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_MAX: wifi_event_sta_wps_fail_reason_t =
    3;
#[doc = " @brief Argument structure for WIFI_EVENT_STA_WPS_ER_FAILED event"]
pub type wifi_event_sta_wps_fail_reason_t = crate::c_types::c_uint;
#[doc = " @brief Argument structure for WIFI_EVENT_STA_WPS_ER_SUCCESS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_success_t {
    #[doc = "< Number of AP credentials received"]
    pub ap_cred_cnt: u8,
    #[doc = "< All AP credentials received from WPS handshake"]
    pub ap_cred: [wifi_event_sta_wps_er_success_t__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_success_t__bindgen_ty_1 {
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< Passphrase for the AP"]
    pub passphrase: [u8; 64usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_STACONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_staconnected_t {
    #[doc = "< MAC address of the station connected to Soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< AID assigned by the Soft-AP to the connected station"]
    pub aid: u8,
    #[doc = "< Flag indicating whether the connected station is a mesh child"]
    pub is_mesh_child: bool,
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_STADISCONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_stadisconnected_t {
    #[doc = "< MAC address of the station disconnects from the soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< AID that the Soft-AP assigned to the disconnected station"]
    pub aid: u8,
    #[doc = "< Flag indicating whether the disconnected station is a mesh child"]
    pub is_mesh_child: bool,
    #[doc = "< Disconnection reason"]
    pub reason: u16,
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_PROBEREQRECVED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_probe_req_rx_t {
    #[doc = "< Received probe request signal strength"]
    pub rssi: crate::c_types::c_int,
    #[doc = "< MAC address of the station which send probe request"]
    pub mac: [u8; 6usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_BSS_RSSI_LOW event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_bss_rssi_low_t {
    #[doc = "< RSSI value of bss"]
    pub rssi: i32,
}
#[doc = " @brief Argument structure for WIFI_EVENT_HOME_CHANNEL_CHANGE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_home_channel_change_t {
    #[doc = "< Old home channel of the device"]
    pub old_chan: u8,
    #[doc = "< Old second channel of the device"]
    pub old_snd: wifi_second_chan_t,
    #[doc = "< New home channel of the device"]
    pub new_chan: u8,
    #[doc = "< New second channel of the device"]
    pub new_snd: wifi_second_chan_t,
}
#[doc = "< FTM exchange is successful"]
pub const wifi_ftm_status_t_FTM_STATUS_SUCCESS: wifi_ftm_status_t = 0;
#[doc = "< Peer does not support FTM"]
pub const wifi_ftm_status_t_FTM_STATUS_UNSUPPORTED: wifi_ftm_status_t = 1;
#[doc = "< Peer rejected FTM configuration in FTM Request"]
pub const wifi_ftm_status_t_FTM_STATUS_CONF_REJECTED: wifi_ftm_status_t = 2;
#[doc = "< Peer did not respond to FTM Requests"]
pub const wifi_ftm_status_t_FTM_STATUS_NO_RESPONSE: wifi_ftm_status_t = 3;
#[doc = "< Unknown error during FTM exchange"]
pub const wifi_ftm_status_t_FTM_STATUS_FAIL: wifi_ftm_status_t = 4;
#[doc = "< FTM session did not result in any valid measurements"]
pub const wifi_ftm_status_t_FTM_STATUS_NO_VALID_MSMT: wifi_ftm_status_t = 5;
#[doc = "< User triggered termination"]
pub const wifi_ftm_status_t_FTM_STATUS_USER_TERM: wifi_ftm_status_t = 6;
#[doc = " @brief FTM operation status types\n"]
pub type wifi_ftm_status_t = crate::c_types::c_uint;
#[doc = " @brief Structure representing a report entry for Fine Timing Measurement (FTM) in Wi-Fi.\n\n This structure holds the information related to the FTM process between a Wi-Fi FTM Initiator\n and a Wi-Fi FTM Responder. FTM is used for precise distance measurement by timing the exchange\n of frames between devices."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ftm_report_entry_t {
    #[doc = "< Dialog Token of the FTM frame"]
    pub dlog_token: u8,
    #[doc = "< RSSI of the FTM frame received"]
    pub rssi: i8,
    #[doc = "< Round Trip Time in pSec with a peer"]
    pub rtt: u32,
    #[doc = "< Time of departure of FTM frame from FTM Responder in pSec"]
    pub t1: u64,
    #[doc = "< Time of arrival of FTM frame at FTM Initiator in pSec"]
    pub t2: u64,
    #[doc = "< Time of departure of ACK from FTM Initiator in pSec"]
    pub t3: u64,
    #[doc = "< Time of arrival of ACK at FTM Responder in pSec"]
    pub t4: u64,
}
#[doc = " @brief Argument structure for WIFI_EVENT_FTM_REPORT event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ftm_report_t {
    #[doc = "< MAC address of the FTM Peer"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< Status of the FTM operation"]
    pub status: wifi_ftm_status_t,
    #[doc = "< Raw average Round-Trip-Time with peer in Nano-Seconds"]
    pub rtt_raw: u32,
    #[doc = "< Estimated Round-Trip-Time with peer in Nano-Seconds"]
    pub rtt_est: u32,
    #[doc = "< Estimated one-way distance in Centi-Meters"]
    pub dist_est: u32,
    #[doc = "< Pointer to FTM Report, should be freed after use. Note: Highly recommended\nto use API esp_wifi_ftm_get_report to get the report instead of using this"]
    pub ftm_report_data: *mut wifi_ftm_report_entry_t,
    #[doc = "< Number of entries in the FTM Report data"]
    pub ftm_report_num_entries: u8,
}
#[doc = "< ACTION_TX operation was completed successfully"]
pub const wifi_action_tx_status_type_t_WIFI_ACTION_TX_DONE: wifi_action_tx_status_type_t = 0;
#[doc = "< ACTION_TX operation failed during tx"]
pub const wifi_action_tx_status_type_t_WIFI_ACTION_TX_FAILED: wifi_action_tx_status_type_t = 1;
#[doc = "< ACTION_TX operation completed it's wait duration"]
pub const wifi_action_tx_status_type_t_WIFI_ACTION_TX_DURATION_COMPLETED:
    wifi_action_tx_status_type_t = 2;
#[doc = "< ACTION_TX operation was cancelled by application or higher priority operation"]
pub const wifi_action_tx_status_type_t_WIFI_ACTION_TX_OP_CANCELLED: wifi_action_tx_status_type_t =
    3;
#[doc = " Status codes for WIFI_EVENT_ACTION_TX_STATUS evt */\n/** There will be back to back events in success case TX_DONE and TX_DURATION_COMPLETED"]
pub type wifi_action_tx_status_type_t = crate::c_types::c_uint;
#[doc = " Argument structure for WIFI_EVENT_ACTION_TX_STATUS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_action_tx_status_t {
    #[doc = "< WiFi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< Context to identify the request"]
    pub context: u32,
    #[doc = "< Status of the operation"]
    pub status: wifi_action_tx_status_type_t,
    #[doc = "< ID of the corresponding operation that was provided during action tx request"]
    pub op_id: u8,
    #[doc = "< Channel provided in tx request"]
    pub channel: u8,
}
#[doc = " @brief Argument structure for WIFI_EVENT_ROC_DONE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_roc_done_t {
    #[doc = "< Context to identify the initiator of the request"]
    pub context: u32,
    #[doc = "< ROC status"]
    pub status: wifi_roc_done_status_t,
    #[doc = "< ID of the corresponding ROC operation"]
    pub op_id: u8,
    #[doc = "< Channel provided in tx request"]
    pub channel: u8,
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_WPS_RG_PIN event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< WPS normal fail reason"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_NORMAL: wps_fail_reason_t = 0;
#[doc = "< WPS failed due to incorrect config"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_CONFIG: wps_fail_reason_t = 1;
#[doc = "< WPS failed during auth"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_AUTH: wps_fail_reason_t = 2;
#[doc = "< Max WPS fail reason"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_MAX: wps_fail_reason_t = 3;
#[doc = " @brief WPS fail reason"]
pub type wps_fail_reason_t = crate::c_types::c_uint;
#[doc = " @brief Argument structure for WIFI_EVENT_AP_WPS_RG_FAILED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_fail_reason_t {
    #[doc = "< WPS failure reason wps_fail_reason_t"]
    pub reason: wps_fail_reason_t,
    #[doc = "< Enrollee mac address"]
    pub peer_macaddr: [u8; 6usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_AP_WPS_RG_SUCCESS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_success_t {
    #[doc = "< Enrollee mac address"]
    pub peer_macaddr: [u8; 6usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_NAN_SVC_MATCH event"]
#[repr(C)]
pub struct wifi_event_nan_svc_match_t {
    #[doc = "< Subscribe Service Identifier"]
    pub subscribe_id: u8,
    #[doc = "< Publish Service Identifier"]
    pub publish_id: u8,
    #[doc = "< NAN Interface MAC of the Publisher"]
    pub pub_if_mac: [u8; 6usize],
    #[doc = "< Indicates whether publisher's service ID needs to be updated"]
    pub update_pub_id: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Indicates version of SSI in Publish instance, 0 if not available"]
    pub ssi_version: u8,
    #[doc = "< Length of service specific info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info of Publisher"]
    pub ssi: __IncompleteArrayField<u8>,
}
impl wifi_event_nan_svc_match_t {
    #[inline]
    pub fn datapath_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_datapath_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsd_gas(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsd_gas(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        datapath_reqd: u8,
        fsd_reqd: u8,
        fsd_gas: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let datapath_reqd: u8 = unsafe { ::core::mem::transmute(datapath_reqd) };
            datapath_reqd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fsd_reqd: u8 = unsafe { ::core::mem::transmute(fsd_reqd) };
            fsd_reqd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fsd_gas: u8 = unsafe { ::core::mem::transmute(fsd_gas) };
            fsd_gas as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Argument structure for WIFI_EVENT_NAN_REPLIED event"]
#[repr(C)]
pub struct wifi_event_nan_replied_t {
    #[doc = "< Publish Service Identifier"]
    pub publish_id: u8,
    #[doc = "< Subscribe Service Identifier"]
    pub subscribe_id: u8,
    #[doc = "< NAN Interface MAC of the Subscriber"]
    pub sub_if_mac: [u8; 6usize],
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Length of service specific info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info of Subscriber"]
    pub ssi: __IncompleteArrayField<u8>,
}
#[doc = " @brief Argument structure for WIFI_EVENT_NAN_RECEIVE event"]
#[repr(C)]
pub struct wifi_event_nan_receive_t {
    #[doc = "< Our Service Identifier"]
    pub inst_id: u8,
    #[doc = "< Peer's Service Identifier"]
    pub peer_inst_id: u8,
    #[doc = "< Peer's NAN Interface MAC"]
    pub peer_if_mac: [u8; 6usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub peer_svc_info: [u8; 64usize],
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Length of service specific info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info from Follow-up"]
    pub ssi: __IncompleteArrayField<u8>,
}
#[doc = " @brief Argument structure for WIFI_EVENT_NDP_INDICATION event"]
#[repr(C)]
pub struct wifi_event_ndp_indication_t {
    #[doc = "< Publish Id for NAN Service"]
    pub publish_id: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Peer's NAN Management Interface MAC"]
    pub peer_nmi: [u8; 6usize],
    #[doc = "< Peer's NAN Data Interface MAC"]
    pub peer_ndi: [u8; 6usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [u8; 64usize],
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Length of service specific info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info from NDP/NDPE Attribute"]
    pub ssi: __IncompleteArrayField<u8>,
}
#[doc = " @brief Argument structure for WIFI_EVENT_NDP_CONFIRM event"]
#[repr(C)]
pub struct wifi_event_ndp_confirm_t {
    #[doc = "< NDP status code"]
    pub status: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Peer's NAN Management Interface MAC"]
    pub peer_nmi: [u8; 6usize],
    #[doc = "< Peer's NAN Data Interface MAC"]
    pub peer_ndi: [u8; 6usize],
    #[doc = "< Own NAN Data Interface MAC"]
    pub own_ndi: [u8; 6usize],
    #[doc = "< To be deprecated in next major release, use ssi instead"]
    pub svc_info: [u8; 64usize],
    #[doc = "< Reserved"]
    pub reserved_1: u32,
    #[doc = "< Reserved"]
    pub reserved_2: u32,
    #[doc = "< Length of Service Specific Info"]
    pub ssi_len: u16,
    #[doc = "< Service specific info from NDP/NDPE Attribute"]
    pub ssi: __IncompleteArrayField<u8>,
}
#[doc = " @brief Argument structure for WIFI_EVENT_NDP_TERMINATED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ndp_terminated_t {
    #[doc = "< Termination reason code"]
    pub reason: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Initiator's NAN Data Interface MAC"]
    pub init_ndi: [u8; 6usize],
}
#[doc = " @brief Argument structure for WIFI_EVENT_STA_NEIGHBOR_REP event"]
#[repr(C)]
pub struct wifi_event_neighbor_report_t {
    #[doc = "< Neighbor Report received from the AP (will be deprecated in next major release, use n_report instead)"]
    pub report: [u8; 64usize],
    #[doc = "< Length of the report"]
    pub report_len: u16,
    #[doc = "< Neighbor Report received from the AP"]
    pub n_report: __IncompleteArrayField<u8>,
}
#[doc = " Argument structure for WIFI_EVENT_AP_WRONG_PASSWORD event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wrong_password_t {
    #[doc = "< MAC address of the station trying to connect to Soft-AP"]
    pub mac: [u8; 6usize],
}
#[doc = " @brief Argument structure for wifi_tx_rate_config"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_tx_rate_config_t {
    #[doc = "< Phymode of specified interface"]
    pub phymode: wifi_phy_mode_t,
    #[doc = "< Rate of specified interface"]
    pub rate: wifi_phy_rate_t,
    #[doc = "< Using ERSU to send frame, ERSU is a transmission mode related to 802.11 ax.\nERSU is always used in long distance transmission, and its frame has lower rate compared with SU mode"]
    pub ersu: bool,
    #[doc = "< Using dcm rate to send frame"]
    pub dcm: bool,
}
#[doc = " Argument structure for regulatory rule"]
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub struct wifi_reg_rule_t {
    #[doc = "< start channel of regulatory rule"]
    pub start_channel: u8,
    #[doc = "< end channel of regulatory rule"]
    pub end_channel: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl wifi_reg_rule_t {
    #[inline]
    pub fn max_bandwidth(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_max_bandwidth(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn max_eirp(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_max_eirp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn is_dfs(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_dfs(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        max_bandwidth: u16,
        max_eirp: u16,
        is_dfs: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let max_bandwidth: u16 = unsafe { ::core::mem::transmute(max_bandwidth) };
            max_bandwidth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 6u8, {
            let max_eirp: u16 = unsafe { ::core::mem::transmute(max_eirp) };
            max_eirp as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_dfs: u16 = unsafe { ::core::mem::transmute(is_dfs) };
            is_dfs as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Argument structure for regdomain"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_regulatory_t {
    #[doc = "< number of regulatory rules"]
    pub n_reg_rules: u8,
    #[doc = "< array of regulatory rules"]
    pub reg_rules: [wifi_reg_rule_t; 2usize],
}
#[doc = " Argument structure for regdomain"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_regdomain_t {
    #[doc = "< country code string"]
    pub cn: [crate::c_types::c_char; 2usize],
    #[doc = "< regulatory type of country"]
    pub regulatory_type: u8,
}
#[doc = "< Sending Wi-Fi data successfully"]
pub const wifi_tx_status_t_WIFI_SEND_SUCCESS: wifi_tx_status_t = 0;
#[doc = "< Sending Wi-Fi data fail"]
pub const wifi_tx_status_t_WIFI_SEND_FAIL: wifi_tx_status_t = 1;
#[doc = " @brief Status of wifi sending data"]
pub type wifi_tx_status_t = crate::c_types::c_uint;
#[doc = " @brief Information of wifi sending data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_tx_info_t {
    #[doc = "< The address of the receive device"]
    pub des_addr: *mut u8,
    #[doc = "< The address of the sending device"]
    pub src_addr: *mut u8,
    #[doc = "< Interface of sending 80211 tx data"]
    pub ifidx: wifi_interface_t,
    #[doc = "< The data for 80211 tx, start from the MAC header"]
    pub data: *mut u8,
    #[doc = "< The frame body length for 80211 tx, excluding the MAC header"]
    pub data_len: u8,
    #[doc = "< Data rate"]
    pub rate: wifi_phy_rate_t,
    #[doc = "< Status of sending 80211 tx data"]
    pub tx_status: wifi_tx_status_t,
}
#[doc = " @brief Information of wifi sending data"]
pub type esp_80211_tx_info_t = wifi_tx_info_t;
#[doc = " Argument structure for WIFI_EVENT_STA_BEACON_OFFSET_UNSTABLE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_beacon_offset_unstable_t {
    #[doc = "< Received beacon success rate"]
    pub beacon_success_rate: f32,
}
#[doc = " Argument structure for WIFI_EVENT_DPP_URI_READY event"]
#[repr(C)]
pub struct wifi_event_dpp_uri_ready_t {
    #[doc = "< URI data length including null termination"]
    pub uri_data_len: u32,
    #[doc = "< URI data"]
    pub uri: __IncompleteArrayField<crate::c_types::c_char>,
}
#[doc = " Argument structure for WIFI_EVENT_DPP_CFG_RECVD event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_dpp_config_received_t {
    #[doc = "< Received WIFI config in DPP"]
    pub wifi_cfg: wifi_config_t,
}
#[doc = " Argument structure for WIFI_EVENT_DPP_FAIL event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_dpp_failed_t {
    #[doc = "< Failure reason"]
    pub failure_reason: crate::c_types::c_int,
}
#[doc = " @brief List of stations associated with the Soft-AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_list_t {
    #[doc = "< station list"]
    pub sta: [wifi_sta_info_t; 15usize],
    #[doc = "< number of stations in the list (other entries are invalid)"]
    pub num: crate::c_types::c_int,
}
#[doc = " @brief Received packet radio metadata header, this is the common header at the beginning of all promiscuous mode RX callback buffers"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wifi_pkt_rx_ctrl_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 36usize]>,
}
impl wifi_pkt_rx_ctrl_t {
    #[inline]
    pub fn rssi(&self) -> crate::c_types::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rssi(&mut self, val: crate::c_types::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rate(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rate(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_mode(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sig_mode(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn cwb(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cwb(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smoothing(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_smoothing(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_sounding(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_sounding(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aggregation(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fec_coding(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec_coding(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgi(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgi(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ampdu_cnt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ampdu_cnt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary_channel(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secondary_channel(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ant(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(223usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ant(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(223usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noise_floor(&self) -> crate::c_types::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(224usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_noise_floor(&mut self, val: crate::c_types::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(224usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_len(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(256usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sig_len(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(256usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_state(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(280usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rx_state(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(280usize, 8u8, val as u64)
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_csi_config_t {
    #[doc = "< enable to receive legacy long training field(lltf) data. Default enabled"]
    pub lltf_en: bool,
    #[doc = "< enable to receive HT long training field(htltf) data. Default enabled"]
    pub htltf_en: bool,
    #[doc = "< enable to receive space time block code HT long training field(stbc-htltf2) data. Default enabled"]
    pub stbc_htltf2_en: bool,
    #[doc = "< enable to generate htlft data by averaging lltf and ht_ltf data when receiving HT packet. Otherwise, use ht_ltf data directly. Default enabled"]
    pub ltf_merge_en: bool,
    #[doc = "< enable to turn on channel filter to smooth adjacent sub-carrier. Disable it to keep independence of adjacent sub-carrier. Default enabled"]
    pub channel_filter_en: bool,
    #[doc = "< manually scale the CSI data by left shifting or automatically scale the CSI data. If set true, please set the shift bits. false: automatically. true: manually. Default false"]
    pub manu_scale: bool,
    #[doc = "< manually left shift bits of the scale of the CSI data. The range of the left shift bits is 0~15"]
    pub shift: u8,
    #[doc = "< enable to dump 802.11 ACK frame, default disabled"]
    pub dump_ack_en: bool,
}
#[doc = " @brief Payload passed to 'buf' parameter of promiscuous mode RX callback."]
#[repr(C)]
pub struct wifi_promiscuous_pkt_t {
    #[doc = "< metadata header"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< Data or management payload. Length of payload is described by rx_ctrl.sig_len. Type of content determined by packet type argument of callback."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = " @brief CSI data type\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_csi_info_t {
    #[doc = "< received packet radio metadata header of the CSI data"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< source MAC address of the CSI data"]
    pub mac: [u8; 6usize],
    #[doc = "< destination MAC address of the CSI data"]
    pub dmac: [u8; 6usize],
    #[doc = "< first four bytes of the CSI data is invalid or not, true indicates the first four bytes is invalid due to hardware limitation"]
    pub first_word_invalid: bool,
    #[doc = "< valid buffer of CSI data"]
    pub buf: *mut i8,
    #[doc = "< valid length of CSI data"]
    pub len: u16,
    #[doc = "< header of the wifi packet"]
    pub hdr: *mut u8,
    #[doc = "< payload of the wifi packet"]
    pub payload: *mut u8,
    #[doc = "< payload len of the wifi packet"]
    pub payload_len: u16,
    #[doc = "< rx sequence number of the wifi packet"]
    pub rx_seq: u16,
}
#[doc = " Configuration for creating event loops"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_event_loop_args_t {
    #[doc = "< size of the event loop queue"]
    pub queue_size: i32,
    #[doc = "< name of the event loop task; if NULL,\na dedicated task is not created for event loop"]
    pub task_name: *const crate::c_types::c_char,
    #[doc = "< priority of the event loop task, ignored if task name is NULL"]
    pub task_priority: UBaseType_t,
    #[doc = "< stack size of the event loop task, ignored if task name is NULL"]
    pub task_stack_size: u32,
    #[doc = "< core to which the event loop task is pinned to,\nignored if task name is NULL"]
    pub task_core_id: BaseType_t,
}
extern "C" {
    #[doc = " @brief Create a new event loop.\n\n @param[in] event_loop_args configuration structure for the event loop to create\n @param[out] event_loop handle to the created event loop\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: event_loop_args or event_loop was NULL\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - ESP_FAIL: Failed to create task loop\n  - Others: Fail"]
    pub fn esp_event_loop_create(
        event_loop_args: *const esp_event_loop_args_t,
        event_loop: *mut esp_event_loop_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an existing event loop.\n\n @param[in] event_loop event loop to delete, must not be NULL\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_delete(event_loop: esp_event_loop_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create default event loop\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - ESP_ERR_INVALID_STATE: Default event loop has already been created\n  - ESP_FAIL: Failed to create task loop\n  - Others: Fail"]
    pub fn esp_event_loop_create_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the default event loop\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_delete_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dispatch events posted to an event loop.\n\n This function is used to dispatch events posted to a loop with no dedicated task, i.e. task name was set to NULL\n in event_loop_args argument during loop creation. This function includes an argument to limit the amount of time\n it runs, returning control to the caller when that time expires (or some time afterwards). There is no guarantee\n that a call to this function will exit at exactly the time of expiry. There is also no guarantee that events have\n been dispatched during the call, as the function might have spent all the allotted time waiting on the event queue.\n Once an event has been dequeued, however, it is guaranteed to be dispatched. This guarantee contributes to not being\n able to exit exactly at time of expiry as (1) blocking on internal mutexes is necessary for dispatching the dequeued\n event, and (2) during  dispatch of the dequeued event there is no way to control the time occupied by handler code\n execution. The guaranteed time of exit is therefore the allotted time + amount of time required to dispatch\n the last dequeued event.\n\n In cases where waiting on the queue times out, ESP_OK is returned and not ESP_ERR_TIMEOUT, since it is\n normal behavior.\n\n @param[in] event_loop event loop to dispatch posted events from, must not be NULL\n @param[in] ticks_to_run number of ticks to run the loop\n\n @note encountering an unknown event that has been posted to the loop will only generate a warning, not an error.\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_run(
        event_loop: esp_event_loop_handle_t,
        ticks_to_run: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to the system event loop (legacy).\n\n This function can be used to register a handler for either: (1) specific events,\n (2) all events of a certain event base, or (3) all events known by the system event loop.\n\n  - specific events: specify exact event_base and event_id\n  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id\n  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id\n\n Registering multiple handlers to events is possible. Registering a single handler to multiple events is\n also possible. However, registering the same handler to the same event multiple times would cause the\n previous registrations to be overwritten.\n\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to a specific loop (legacy).\n\n This function behaves in the same manner as esp_event_handler_register, except the additional\n specification of the event loop to register the handler to.\n\n @param[in] event_loop the event loop to register this handler function to, must not be NULL\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an instance of event handler to a specific loop.\n\n This function can be used to register a handler for either: (1) specific events,\n (2) all events of a certain event base, or (3) all events known by the system event loop.\n\n  - specific events: specify exact event_base and event_id\n  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id\n  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id\n\n Besides the error, the function returns an instance object as output parameter to identify each registration.\n This is necessary to remove (unregister) the registration before the event loop is deleted.\n\n Registering multiple handlers to events, registering a single handler to multiple events as well as registering\n the same handler to the same event multiple times is possible.\n Each registration yields a distinct instance object which identifies it over the registration\n lifetime.\n\n @param[in] event_loop the event loop to register this handler function to, must not be NULL\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n @param[out] instance An event handler instance object related to the registered event handler and data, can be NULL.\n             This needs to be kept if the specific callback instance should be unregistered before deleting the whole\n             event loop. Registering the same event handler multiple times is possible and yields distinct instance\n             objects. The data can be the same for all registrations.\n             If no unregistration is needed, but the handler should be deleted when the event loop is deleted,\n             instance can be NULL.\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @note Calling this function with instance set to NULL is equivalent to calling esp_event_handler_register_with.\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID or instance is NULL\n  - Others: Fail"]
    pub fn esp_event_handler_instance_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
        instance: *mut esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an instance of event handler to the default loop.\n\n This function does the same as esp_event_handler_instance_register_with, except that it registers the\n handler to the default event loop.\n\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n @param[out] instance An event handler instance object related to the registered event handler and data, can be NULL.\n             This needs to be kept if the specific callback instance should be unregistered before deleting the whole\n             event loop. Registering the same event handler multiple times is possible and yields distinct instance\n             objects. The data can be the same for all registrations.\n             If no unregistration is needed, but the handler should be deleted when the event loop is deleted,\n             instance can be NULL.\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @note Calling this function with instance set to NULL is equivalent to calling esp_event_handler_register.\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID or instance is NULL\n  - Others: Fail"]
    pub fn esp_event_handler_instance_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
        instance: *mut esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler with the system event loop (legacy).\n\n Unregisters a handler, so it will no longer be called during dispatch.\n Handlers can be unregistered for any combination of event_base and event_id which were previously registered.\n To unregister a handler, the event_base and event_id arguments must match exactly the arguments passed to\n esp_event_handler_register() when that handler was registered. Passing ESP_EVENT_ANY_BASE and/or ESP_EVENT_ANY_ID\n will only unregister handlers that were registered with the same wildcard arguments.\n\n @note When using ESP_EVENT_ANY_ID, handlers registered to specific event IDs using the same base will not be\n       unregistered. When using ESP_EVENT_ANY_BASE, events registered to specific bases will also not be\n       unregistered. This avoids accidental unregistration of handlers registered by other users or components.\n\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] event_handler the handler to unregister\n\n @return ESP_OK success\n @return ESP_ERR_INVALID_ARG invalid combination of event base and event ID\n @return others fail"]
    pub fn esp_event_handler_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler from a specific event loop (legacy).\n\n This function behaves in the same manner as esp_event_handler_unregister, except the additional specification of\n the event loop to unregister the handler with.\n\n @param[in] event_loop the event loop with which to unregister this handler function, must not be NULL\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] event_handler the handler to unregister\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler instance from a specific event loop.\n\n Unregisters a handler instance, so it will no longer be called during dispatch.\n Handler instances can be unregistered for any combination of event_base and event_id which were previously\n registered. To unregister a handler instance, the event_base and event_id arguments must match exactly the\n arguments passed to esp_event_handler_instance_register() when that handler instance was registered.\n Passing ESP_EVENT_ANY_BASE and/or ESP_EVENT_ANY_ID will only unregister handler instances that were registered\n with the same wildcard arguments.\n\n @note When using ESP_EVENT_ANY_ID, handlers registered to specific event IDs using the same base will not be\n       unregistered. When using ESP_EVENT_ANY_BASE, events registered to specific bases will also not be\n       unregistered. This avoids accidental unregistration of handlers registered by other users or components.\n\n @param[in] event_loop the event loop with which to unregister this handler function, must not be NULL\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] instance the instance object of the registration to be unregistered\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_instance_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        instance: esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler from the system event loop.\n\n This function does the same as esp_event_handler_instance_unregister_with, except that it unregisters the\n handler instance from the default event loop.\n\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] instance the instance object of the registration to be unregistered\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_instance_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        instance: esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the system default event loop. The event loop library keeps a copy of event_data and manages\n the copy's lifetime automatically (allocation + deletion); this ensures that the data the\n handler receives is always valid.\n\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data\n @param[in] ticks_to_wait number of ticks to block on a full event queue\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,\n                      queue full when posting from ISR\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the specified event loop. The event loop library keeps a copy of event_data and manages\n the copy's lifetime automatically (allocation + deletion); this ensures that the data the\n handler receives is always valid.\n\n This function behaves in the same manner as esp_event_post, except the additional specification of the event loop\n to post the event to.\n\n @param[in] event_loop the event loop to post to, must not be NULL\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data\n @param[in] ticks_to_wait number of ticks to block on a full event queue\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,\n                      queue full when posting from ISR\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Special variant of esp_event_post for posting events from interrupt handlers.\n\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data; max is 4 bytes\n @param[out] task_unblocked an optional parameter (can be NULL) which indicates that an event task with\n                            higher priority than currently running task has been unblocked by the posted event;\n                            a context switch should be requested before the interrupt is existed.\n\n @note this function is only available when CONFIG_ESP_EVENT_POST_FROM_ISR is enabled\n @note when this function is called from an interrupt handler placed in IRAM, this function should\n       be placed in IRAM as well by enabling CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR\n\n @return\n  - ESP_OK: Success\n  - ESP_FAIL: Event queue for the default event loop full\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID,\n                          data size of more than 4 bytes\n  - Others: Fail"]
    pub fn esp_event_isr_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: usize,
        task_unblocked: *mut BaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Special variant of esp_event_post_to for posting events from interrupt handlers\n\n @param[in] event_loop the event loop to post to, must not be NULL\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data\n @param[out] task_unblocked an optional parameter (can be NULL) which indicates that an event task with\n                            higher priority than currently running task has been unblocked by the posted event;\n                            a context switch should be requested before the interrupt is existed.\n\n @note this function is only available when CONFIG_ESP_EVENT_POST_FROM_ISR is enabled\n @note when this function is called from an interrupt handler placed in IRAM, this function should\n       be placed in IRAM as well by enabling CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR\n\n @return\n  - ESP_OK: Success\n  - ESP_FAIL: Event queue for the loop full\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID,\n                          data size of more than 4 bytes\n  - Others: Fail"]
    pub fn esp_event_isr_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: usize,
        task_unblocked: *mut BaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dumps statistics of all event loops.\n\n Dumps event loop info in the format:\n\n@verbatim\nevent loop\nhandler\nhandler\n...\nevent loop\nhandler\nhandler\n...\n\nwhere:\n\nevent loop\nformat: address,name rx:total_received dr:total_dropped\nwhere:\naddress - memory address of the event loop\nname - name of the event loop, 'none' if no dedicated task\ntotal_received - number of successfully posted events\ntotal_dropped - number of events unsuccessfully posted due to queue being full\n\nhandler\nformat: address ev:base,id inv:total_invoked run:total_runtime\nwhere:\naddress - address of the handler function\nbase,id - the event specified by event base and ID this handler executes\ntotal_invoked - number of times this handler has been invoked\ntotal_runtime - total amount of time used for invoking this handler\n\n@endverbatim\n\n @param[in] file the file stream to output to\n\n @note this function is a noop when CONFIG_ESP_EVENT_LOOP_PROFILING is disabled\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - Others: Fail"]
    pub fn esp_event_dump(file: *mut FILE) -> esp_err_t;
}
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_MD5: esp_crypto_hash_alg_t = 0;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA1: esp_crypto_hash_alg_t = 1;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_MD5: esp_crypto_hash_alg_t = 2;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA1: esp_crypto_hash_alg_t = 3;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA256: esp_crypto_hash_alg_t = 4;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA256: esp_crypto_hash_alg_t = 5;
pub type esp_crypto_hash_alg_t = crate::c_types::c_uint;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_NULL: esp_crypto_cipher_alg_t = 0;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_AES: esp_crypto_cipher_alg_t = 1;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_3DES: esp_crypto_cipher_alg_t = 2;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_DES: esp_crypto_cipher_alg_t = 3;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC2: esp_crypto_cipher_alg_t = 4;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC4: esp_crypto_cipher_alg_t = 5;
pub type esp_crypto_cipher_alg_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_hash {
    _unused: [u8; 0],
}
pub type esp_crypto_hash_t = crypto_hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_cipher {
    _unused: [u8; 0],
}
pub type esp_crypto_cipher_t = crypto_cipher;
#[doc = " @brief The AES 128 encrypt callback function used by esp_wifi.\n\n @param key  Encryption key.\n @param iv  Encryption IV for CBC mode (16 bytes).\n @param data  Data to encrypt in-place.\n @param data_len  Length of data in bytes (must be divisible by 16)"]
pub type esp_aes_128_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        iv: *const crate::c_types::c_uchar,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES 128 decrypt callback function used by esp_wifi.\n\n @param key  Decryption key.\n @param iv  Decryption IV for CBC mode (16 bytes).\n @param data  Data to decrypt in-place.\n @param data_len  Length of data in bytes (must be divisible by 16)\n"]
pub type esp_aes_128_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        iv: *const crate::c_types::c_uchar,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES wrap callback function used by esp_wifi.\n\n @param kek  16-octet Key encryption key (KEK).\n @param n  Length of the plaintext key in 64-bit units;\n @param plain  Plaintext key to be wrapped, n * 64 bits\n @param cipher  Wrapped key, (n + 1) * 64 bits\n"]
pub type esp_aes_wrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const crate::c_types::c_uchar,
        n: crate::c_types::c_int,
        plain: *const crate::c_types::c_uchar,
        cipher: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES unwrap callback function used by esp_wifi.\n\n @param kek  16-octet Key decryption key (KEK).\n @param n  Length of the plaintext key in 64-bit units;\n @param cipher  Wrapped key to be unwrapped, (n + 1) * 64 bits\n @param plain  Plaintext key, n * 64 bits\n"]
pub type esp_aes_unwrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const crate::c_types::c_uchar,
        n: crate::c_types::c_int,
        cipher: *const crate::c_types::c_uchar,
        plain: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The SHA256 callback function used by esp_wifi.\n\n @param key  Key for HMAC operations.\n @param key_len  Length of the key in bytes.\n @param num_elem  Number of elements in the data vector.\n @param addr  Pointers to the data areas.\n @param len  Lengths of the data blocks.\n @param mac  Buffer for the hash (32 bytes).\n"]
pub type esp_hmac_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_int,
        num_elem: crate::c_types::c_int,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_int,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The SHA256 PRF callback function used by esp_wifi.\n\n @param key  Key for PRF.\n @param key_len  Length of the key in bytes.\n @param label  A unique label for each purpose of the PRF.\n @param data  Extra data to bind into the key.\n @param data_len  Length of the data.\n @param buf  Buffer for the generated pseudo-random key.\n @param buf_len  Number of bytes of key to generate.\n"]
pub type esp_sha256_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_int,
        label: *const crate::c_types::c_char,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
        buf: *mut crate::c_types::c_uchar,
        buf_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-MD5 callback function over data buffer (RFC 2104)'\n\n @param key Key for HMAC operations\n @param key_len Length of the key in bytes\n @param data Pointers to the data area\n @param data_len Length of the data area\n @param mac Buffer for the hash (16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-MD5 callback function over data vector (RFC 2104)\n\n @param key Key for HMAC operations\n @param key_len Length of the key in bytes\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param mac Buffer for the hash (16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-SHA1 callback function over data buffer (RFC 2104)\n\n @param key Key for HMAC operations\n @param key_len Length of the key in bytes\n @param data Pointers to the data area\n @param data_len Length of the data area\n @param mac Buffer for the hash (20 bytes)\n Returns: 0 on success, -1 of failure"]
pub type esp_hmac_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-SHA1 callback function over data vector (RFC 2104)\n\n @param key Key for HMAC operations\n @param key_len Length of the key in bytes\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param mac Buffer for the hash (20 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA1-based Pseudo-Random Function (PRF) (IEEE 802.11i, 8.5.1.1) callback function\n\n @param key Key for PRF\n @param key_len Length of the key in bytes\n @param label A unique label for each purpose of the PRF\n @param data Extra data to bind into the key\n @param data_len Length of the data\n @param buf Buffer for the generated pseudo-random key\n @param buf_len Number of bytes of key to generate\n Returns: 0 on success, -1 of failure\n\n This function is used to derive new, cryptographically separate keys from a\n given key (e.g., PMK in IEEE 802.11i)."]
pub type esp_sha1_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        label: *const crate::c_types::c_char,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        buf: *mut crate::c_types::c_uchar,
        buf_len: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA-1 hash callback function for data vector\n\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param mac Buffer for the hash\n Returns: 0 on success, -1 on failure"]
pub type esp_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA1-based key derivation function (PBKDF2) callback function for IEEE 802.11i\n\n @param passphrase ASCII passphrase\n @param ssid SSID\n @param ssid_len SSID length in bytes\n @param iterations Number of iterations to run\n @param buf Buffer for the generated key\n @param buflen Length of the buffer in bytes\n Returns: 0 on success, -1 of failure\n\n This function is used to derive PSK for WPA-PSK. For this protocol,\n iterations is set to 4096 and buflen to 32. This function is described in\n IEEE Std 802.11-2004, Clause H.4. The main construction is from PKCS#5 v2.0."]
pub type esp_pbkdf2_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        passphrase: *const crate::c_types::c_char,
        ssid: *const crate::c_types::c_char,
        ssid_len: crate::c_types::c_uint,
        iterations: crate::c_types::c_int,
        buf: *mut crate::c_types::c_uchar,
        buflen: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief XOR RC4 stream callback function to given data with skip-stream-start\n\n @param key RC4 key\n @param keylen RC4 key length\n @param skip number of bytes to skip from the beginning of the RC4 stream\n @param data data to be XOR'ed with RC4 stream\n @param data_len buf length\n Returns: 0 on success, -1 on failure\n\n Generate RC4 pseudo random stream for the given key, skip beginning of the\n stream, and XOR the end result with the data buffer to perform RC4\n encryption/decryption."]
pub type esp_rc4_skip_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        keylen: crate::c_types::c_uint,
        skip: crate::c_types::c_uint,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief MD5 hash callback function for data vector\n\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param mac Buffer for the hash\n Returns: 0 on success, -1 on failure"]
pub type esp_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Encrypt one AES block callback function\n\n @param ctx Context pointer from aes_encrypt_init()\n @param plain Plaintext data to be encrypted (16 bytes)\n @param crypt Buffer for the encrypted data (16 bytes)"]
pub type esp_aes_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        plain: *const crate::c_types::c_uchar,
        crypt: *mut crate::c_types::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES callback function for encryption\n\n @param key Encryption key\n @param len Key length in bytes (usually 16, i.e., 128 bits)\n Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_encrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        len: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void,
>;
#[doc = " @brief Deinitialize AES encryption callback function\n\n @param ctx Context pointer from aes_encrypt_init()"]
pub type esp_aes_encrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void)>;
#[doc = " @brief Decrypt one AES block callback function\n\n @param ctx Context pointer from aes_encrypt_init()\n @param crypt Encrypted data (16 bytes)\n @param plain Buffer for the decrypted data (16 bytes)"]
pub type esp_aes_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        crypt: *const crate::c_types::c_uchar,
        plain: *mut crate::c_types::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES callback function for decryption\n\n @param key Decryption key\n @param len Key length in bytes (usually 16, i.e., 128 bits)\n Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_decrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        len: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void,
>;
#[doc = " @brief Deinitialize AES decryption callback function\n\n @param ctx Context pointer from aes_encrypt_init()"]
pub type esp_aes_decrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void)>;
#[doc = " @brief One-Key CBC MAC (OMAC1) hash with AES-128 callback function for MIC computation\n\n @param key 128-bit key for the hash operation\n @param data Data buffer for which a MIC is computed\n @param data_len Length of data buffer in bytes\n @param mic Buffer for MIC (128 bits, i.e., 16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_omac1_aes_128_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        data: *const u8,
        data_len: usize,
        mic: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Decrypt data callback function using CCMP (Counter Mode CBC-MAC Protocol OR\n        Counter Mode Cipher Block Chaining Message Authentication\n        Code Protocol) which is used in IEEE 802.11i RSN standard.\n @param tk 128-bit Temporal Key for obtained during 4-way handshake\n @param ieee80211_hdr Pointer to IEEE802.11 frame headeri needed for AAD\n @param data Pointer to encrypted data buffer\n @param data_len Encrypted data length in bytes\n @param decrypted_len Length of decrypted data\n @param espnow_pkt Indicates if it's an ESPNOW packet\n Returns: Pointer to decrypted data on success, NULL on failure"]
pub type esp_ccmp_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        ieee80211_hdr: *const u8,
        data: *const u8,
        data_len: usize,
        decrypted_len: *mut usize,
        espnow_pkt: bool,
    ) -> *mut u8,
>;
#[doc = " @brief Encrypt data callback function using CCMP (Counter Mode CBC-MAC Protocol OR\n        Counter Mode Cipher Block Chaining Message Authentication\n        Code Protocol) which is used in IEEE 802.11i RSN standard.\n @param tk 128-bit Temporal Key for obtained during 4-way handshake\n @param frame Pointer to IEEE802.11 frame including header\n @param len Length of the frame including header\n @param hdrlen Length of the header\n @param pn Packet Number counter\n @param keyid Key ID to be mentioned in CCMP Vector\n @param encrypted_len Length of the encrypted frame including header"]
pub type esp_ccmp_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        frame: *mut u8,
        len: usize,
        hdrlen: usize,
        pn: *mut u8,
        keyid: crate::c_types::c_int,
        encrypted_len: *mut usize,
    ) -> *mut u8,
>;
#[doc = " @brief One-Key GMAC hash callback function with AES for MIC computation\n\n @param key key for the hash operation\n @param keylen key length\n @param iv initialization vector\n @param iv_len initialization vector length\n @param aad aad\n @param aad_len aad length\n @param mic Buffer for MIC (128 bits, i.e., 16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_aes_gmac_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        keylen: usize,
        iv: *const u8,
        iv_len: usize,
        aad: *const u8,
        aad_len: usize,
        mic: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA256 hash callback function for data vector\n @param num_elem Number of elements in the data vector\n @param addr Pointers to the data areas\n @param len Lengths of the data blocks\n @param buf Buffer for the hash\n Returns: 0 on success, -1 on failure"]
pub type esp_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: usize,
        addr: *mut *const u8,
        len: *const usize,
        buf: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief CRC32 value callback function in little endian.\n\n @param crc Initial CRC value (result of last calculation or 0 for the first time)\n @param buf Data buffer that used to calculate the CRC value\n @param len Length of the data buffer\n @return CRC32 value"]
pub type esp_crc32_le_t =
    ::core::option::Option<unsafe extern "C" fn(crc: u32, buf: *const u8, len: u32) -> u32>;
#[doc = " @brief The crypto callback function structure used by esp_wifi.\n        The structure can be set as software crypto or the crypto optimized by device's\n        hardware."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wpa_crypto_funcs_t {
    #[doc = "< The crypto callback function structure size"]
    pub size: u32,
    #[doc = "< The crypto callback function structure version"]
    pub version: u32,
    #[doc = "< The SHA256 callback function used by esp_wifi"]
    pub hmac_sha256_vector: esp_hmac_sha256_vector_t,
    #[doc = "< SHA1-based key derivation function (PBKDF2) callback function for IEEE 802.11"]
    pub pbkdf2_sha1: esp_pbkdf2_sha1_t,
    #[doc = "< The AES 128 encrypt callback function used by esp_wifi"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< The AES 128 decrypt callback function used by esp_wifi"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
    #[doc = "< One-Key CBC MAC (OMAC1) hash with AES-128 callback function for MIC computation"]
    pub omac1_aes_128: esp_omac1_aes_128_t,
    #[doc = "< Decrypt data callback function using CCMP"]
    pub ccmp_decrypt: esp_ccmp_decrypt_t,
    #[doc = "< Encrypt data callback function using CCMP"]
    pub ccmp_encrypt: esp_ccmp_encrypt_t,
    #[doc = "< One-Key GMAC hash callback function with AES for MIC computation"]
    pub aes_gmac: esp_aes_gmac_t,
    #[doc = "< SHA256 hash callback function for data vector"]
    pub sha256_vector: esp_sha256_vector_t,
}
#[doc = " @brief The crypto callback function structure used in mesh vendor IE encryption. The\n        structure can be set as software crypto or the crypto optimized by device's\n        hardware."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mesh_crypto_funcs_t {
    #[doc = "< Callback function used in mesh vendor IE encryption"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< Callback function used in mesh vendor IE decryption"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
}
extern "C" {
    #[doc = " @brief Attaches wifi station interface to supplied netif\n\n @param esp_netif instance to attach the wifi station to\n\n @return\n  - ESP_OK on success\n  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_station(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Attaches wifi soft AP interface to supplied netif\n\n @param esp_netif instance to attach the wifi AP to\n\n @return\n  - ESP_OK on success\n  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_ap(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for STA interface\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_sta_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for AP interface\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_ap_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for NAN interface\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_nan_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clears default wifi event handlers for supplied network interface\n\n @param esp_netif instance of corresponding if object\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_clear_default_wifi_driver_and_handlers(
        esp_netif: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI AP. In case of any init error this API aborts.\n\n @note The API creates esp_netif object with default WiFi access point config,\n attaches the netif to wifi and registers wifi handlers to the default event loop.\n This API uses assert() to check for potential errors, so it could abort the program.\n (Note that the default event loop needs to be created prior to calling this API)\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_ap() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI STA. In case of any init error this API aborts.\n\n @note The API creates esp_netif object with default WiFi station config,\n attaches the netif to wifi and registers wifi handlers to the default event loop.\n This API uses assert() to check for potential errors, so it could abort the program.\n (Note that the default event loop needs to be created prior to calling this API)\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_sta() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI NAN. In case of any init error this API aborts.\n\n @note The API creates esp_netif object with default WiFi station config,\n attaches the netif to wifi and registers wifi handlers to the default event loop.\n (Note that the default event loop needs to be created prior to calling this API)\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_nan() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Destroys default WIFI netif created with esp_netif_create_default_wifi_...() API.\n\n @param[in] esp_netif object to detach from WiFi and destroy\n\n @note This API unregisters wifi handlers and detaches the created object from the wifi.\n (this function is a no-operation if esp_netif is NULL)"]
    pub fn esp_netif_destroy_default_wifi(esp_netif: *mut crate::c_types::c_void);
}
extern "C" {
    #[doc = " @brief Creates esp_netif WiFi object based on the custom configuration.\n\n @attention This API DOES NOT register default handlers!\n\n @param[in] wifi_if type of wifi interface\n @param[in] esp_netif_config inherent esp-netif configuration pointer\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_wifi(
        wifi_if: wifi_interface_t,
        esp_netif_config: *const esp_netif_inherent_config_t,
    ) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default STA and AP network interfaces for esp-mesh.\n\n Both netifs are almost identical to the default station and softAP, but with\n DHCP client and server disabled. Please note that the DHCP client is typically\n enabled only if the device is promoted to a root node.\n\n Returns created interfaces which could be ignored setting parameters to NULL\n if an application code does not need to save the interface instances\n for further processing.\n\n @param[out] p_netif_sta pointer where the resultant STA interface is saved (if non NULL)\n @param[out] p_netif_ap pointer where the resultant AP interface is saved (if non NULL)\n\n @return ESP_OK on success"]
    pub fn esp_netif_create_default_wifi_mesh_netifs(
        p_netif_sta: *mut *mut esp_netif_t,
        p_netif_ap: *mut *mut esp_netif_t,
    ) -> esp_err_t;
}
#[doc = " @brief WiFi stack configuration parameters passed to esp_wifi_init call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_init_config_t {
    #[doc = "< WiFi OS functions"]
    pub osi_funcs: *mut wifi_osi_funcs_t,
    #[doc = "< WiFi station crypto functions when connect"]
    pub wpa_crypto_funcs: wpa_crypto_funcs_t,
    #[doc = "< WiFi static RX buffer number"]
    pub static_rx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi dynamic RX buffer number"]
    pub dynamic_rx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi TX buffer type"]
    pub tx_buf_type: crate::c_types::c_int,
    #[doc = "< WiFi static TX buffer number"]
    pub static_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi dynamic TX buffer number"]
    pub dynamic_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi RX MGMT buffer type"]
    pub rx_mgmt_buf_type: crate::c_types::c_int,
    #[doc = "< WiFi RX MGMT buffer number"]
    pub rx_mgmt_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi TX cache buffer number"]
    pub cache_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi channel state information enable flag"]
    pub csi_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMPDU RX feature enable flag"]
    pub ampdu_rx_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMPDU TX feature enable flag"]
    pub ampdu_tx_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMSDU TX feature enable flag"]
    pub amsdu_tx_enable: crate::c_types::c_int,
    #[doc = "< WiFi NVS flash enable flag"]
    pub nvs_enable: crate::c_types::c_int,
    #[doc = "< Nano option for printf/scan family enable flag"]
    pub nano_enable: crate::c_types::c_int,
    #[doc = "< WiFi Block Ack RX window size"]
    pub rx_ba_win: crate::c_types::c_int,
    #[doc = "< WiFi Task Core ID"]
    pub wifi_task_core_id: crate::c_types::c_int,
    #[doc = "< WiFi softAP maximum length of the beacon"]
    pub beacon_max_len: crate::c_types::c_int,
    #[doc = "< WiFi management short buffer number, the minimum value is 6, the maximum value is 32"]
    pub mgmt_sbuf_num: crate::c_types::c_int,
    #[doc = "< Enables additional WiFi features and capabilities"]
    pub feature_caps: u64,
    #[doc = "< WiFi Power Management for station at disconnected status"]
    pub sta_disconnected_pm: bool,
    #[doc = "< Maximum encrypt number of peers supported by espnow"]
    pub espnow_max_encrypt_num: crate::c_types::c_int,
    #[doc = "< WiFi TX HE TB QUEUE number for STA HE TB PPDU transmission"]
    pub tx_hetb_queue_num: crate::c_types::c_int,
    #[doc = "< enable dump sigb field"]
    pub dump_hesigb_enable: bool,
    #[doc = "< WiFi init magic number, it should be the last field"]
    pub magic: crate::c_types::c_int,
}
extern "C" {
    #[doc = " @addtogroup WPA_APIs\n @{"]
    pub static g_wifi_default_wpa_crypto_funcs: wpa_crypto_funcs_t;
}
extern "C" {
    pub static mut g_wifi_osi_funcs: wifi_osi_funcs_t;
}
extern "C" {
    #[doc = " @brief  Initialize WiFi\n         Allocate resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n         WiFi NVS structure etc. This WiFi also starts WiFi task\n\n @attention 1. This API must be called before all other WiFi API can be called\n @attention 2. Always use WIFI_INIT_CONFIG_DEFAULT macro to initialize the configuration to default values, this can\n               guarantee all the fields get correct value when more fields are added into wifi_init_config_t\n               in future release. If you want to set your own initial values, overwrite the default values\n               which are set by WIFI_INIT_CONFIG_DEFAULT. Please be notified that the field 'magic' of\n               wifi_init_config_t should always be WIFI_INIT_CONFIG_MAGIC!\n\n @param  config pointer to WiFi initialized configuration structure; can point to a temporary variable.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_NO_MEM: out of memory\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Deinit WiFi\n         Free all resource allocated in esp_wifi_init and stop WiFi task\n\n @attention 1. This API should be called if you want to remove WiFi driver from the system\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi operating mode\n\n            Set the WiFi operating mode as station, soft-AP, station+soft-AP or NAN.\n            The default mode is station mode.\n\n @param     mode  WiFi operating mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_mode(mode: wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get current operating mode of WiFi\n\n @param[out]  mode  store current WiFi mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_mode(mode: *mut wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start WiFi according to current configuration\n         If mode is WIFI_MODE_STA, it creates station control block and starts station\n         If mode is WIFI_MODE_AP, it creates soft-AP control block and starts soft-AP\n         If mode is WIFI_MODE_APSTA, it creates soft-AP and station control block and starts soft-AP and station\n         If mode is WIFI_MODE_NAN, it creates NAN control block and starts NAN\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: It doesn't normally happen, the function called inside the API was passed invalid argument, user should check if the wifi related config is correct\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong\n    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop WiFi\n         If mode is WIFI_MODE_STA, it stops station and frees station control block\n         If mode is WIFI_MODE_AP, it stops soft-AP and frees soft-AP control block\n         If mode is WIFI_MODE_APSTA, it stops station/soft-AP and frees station/soft-AP control block\n         If mode is WIFI_MODE_NAN, it stops NAN and frees NAN control block\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restore WiFi stack persistent settings to default values\n\n This function will reset settings made using the following APIs:\n - esp_wifi_set_bandwidth,\n - esp_wifi_set_protocol,\n - esp_wifi_set_config related\n - esp_wifi_set_mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_restore() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Connect WiFi station to the AP.\n\n @attention 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode\n @attention 2. If station interface is connected to an AP, call esp_wifi_disconnect to disconnect.\n @attention 3. The scanning triggered by esp_wifi_scan_start() will not be effective until connection between device and the AP is established.\n               If device is scanning and connecting at the same time, it will abort scanning and return a warning message and error\n               number ESP_ERR_WIFI_STATE.\n @attention 4. This API attempts to connect to an Access Point (AP) only once. To enable reconnection in case of a connection failure, please use\n               the 'failure_retry_cnt' feature in the 'wifi_sta_config_t'. Users are suggested to implement reconnection logic in their application\n               for scenarios where the specified AP does not exist, or reconnection is desired after the device has received a disconnect event.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_MODE: WiFi mode error\n    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong\n    - ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid"]
    pub fn esp_wifi_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Disconnect WiFi station from the AP.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_disconnect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Currently this API is just an stub API\n\n\n @return\n    - ESP_OK: succeed\n    - others: fail"]
    pub fn esp_wifi_clear_fast_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     deauthenticate all stations or associated id equals to aid\n\n @param     aid  when aid is 0, deauthenticate all stations, otherwise deauthenticate station whose associated id is aid\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    pub fn esp_wifi_deauth_sta(aid: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Scan all available APs.\n\n @attention If this API is called, the found APs are stored in WiFi driver dynamic allocated memory. And then\n            can be freed in esp_wifi_scan_get_ap_records(), esp_wifi_scan_get_ap_record() or esp_wifi_clear_ap_list(),\n            so call any one to free the memory once the scan is done.\n @attention The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds.\n            Values above 1500ms may cause station to disconnect from AP and are not recommended.\n\n @param     config  configuration settings for scanning, if set to NULL default settings will be used\n                    of which default values are show_hidden:false, scan_type:active, scan_time.active.min:0,\n                    scan_time.active.max:120 milliseconds, scan_time.passive:360 milliseconds\n                    home_chan_dwell_time:30ms\n\n @param     block if block is true, this API will block the caller until the scan is done, otherwise\n                         it will return immediately\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_WIFI_TIMEOUT: blocking scan is timeout\n    - ESP_ERR_WIFI_STATE: wifi still connecting when invoke esp_wifi_scan_start\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_scan_start(config: *const wifi_scan_config_t, block: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set default parameters used for scanning by station.\n\n @attention The values set using this API are also used for scans used while connecting.\n\n @attention The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds.\n\n @attention The home_chan_dwell_time needs to be a minimum of 30ms and a maximum of 150ms.\n\n @attention Set any of the parameters to 0 to indicate using the default parameters -\n            scan_time.active.min : 0ms, scan_time.active.max : 120ms home_chan_dwell_time : 30ms\n            scan_time.passive : 360ms\n\n @attention Default values can be retrieved using the macro WIFI_SCAN_PARAMS_DEFAULT_CONFIG()\n\n @attention Set the config parameter to NULL to reset previously set scan parameters to their default values.\n\n @param     config  default configuration settings for all scans by stations\n\n @return\n    - ESP_OK: succeed\n    - ESP_FAIL: failed as station mode has not been started yet\n    - ESP_ERR_INVALID_ARG: values provided do not satisfy the requirements\n    - ESP_ERR_NOT_SUPPORTED: This API is not supported in AP mode yet\n    - ESP_ERR_INVALID_STATE: a scan/connect is in progress right now, cannot change scan parameters\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_scan_parameters(config: *const wifi_scan_default_params_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get default parameters used for scanning by station.\n\n @param     config  structure variable within which scan default params will be stored\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: passed parameter does not point to a valid memory\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_get_scan_parameters(config: *mut wifi_scan_default_params_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop the scan in process\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_scan_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get number of APs found in last scan\n\n @param[out] number  store number of APs found in last scan\n\n @attention This API can only be called when the scan is completed, otherwise it may get wrong value.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_scan_get_ap_num(number: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AP list found in last scan.\n\n @attention  This API will free all memory occupied by scanned AP list.\n\n @param[inout]  number As input param, it stores max AP number ap_records can hold.\n                As output param, it receives the actual AP number this API returns.\n @param         ap_records  wifi_ap_record_t array to hold the found APs\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_NO_MEM: out of memory"]
    pub fn esp_wifi_scan_get_ap_records(
        number: *mut u16,
        ap_records: *mut wifi_ap_record_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get one AP record from the scanned AP list.\n\n @attention  Different from esp_wifi_scan_get_ap_records(), this API only gets one AP record\n             from the scanned AP list each time. This API will free the memory of one AP record,\n             if the user doesn't get all records in the scannned AP list, then needs to call esp_wifi_clear_ap_list()\n             to free the remaining memory.\n\n @param[out] ap_record  pointer to one AP record\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_FAIL: scan APs is NULL, means all AP records fetched or no AP found"]
    pub fn esp_wifi_scan_get_ap_record(ap_record: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Clear AP list found in last scan\n\n @attention This API will free all memory occupied by scanned AP list.\n            When the obtained AP list fails, AP records must be cleared,otherwise it may cause memory leakage.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_INVALID_ARG: It doesn't normally happen, the function called inside the API was passed invalid argument, user should check if the wifi related config is correct"]
    pub fn esp_wifi_clear_ap_list() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get information of AP to which the device is associated with\n\n @attention When the obtained country information is empty, it means that the AP does not carry country information\n\n @param     ap_info  the wifi_ap_record_t to hold AP information\n            sta can get the connected ap's phy mode info through the struct member\n            phy_11b，phy_11g，phy_11n，phy_lr in the wifi_ap_record_t struct.\n            For example, phy_11b = 1 imply that ap support 802.11b mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_CONN: The station interface don't initialized\n    - ESP_ERR_WIFI_NOT_CONNECT: The station is in disconnect status"]
    pub fn esp_wifi_sta_get_ap_info(ap_info: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi power save type\n\n @attention Default power save type is WIFI_PS_MIN_MODEM.\n\n @param     type  power save type\n\n @return    ESP_OK: succeed"]
    pub fn esp_wifi_set_ps(type_: wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi power save type\n\n @attention Default power save type is WIFI_PS_MIN_MODEM.\n\n @param[out]  type: store current power save type\n\n @return    ESP_OK: succeed"]
    pub fn esp_wifi_get_ps(type_: *mut wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of specified interface\n            The default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N).\n            if CONFIG_SOC_WIFI_HE_SUPPORT and band is 2.4G, the default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_11AX).\n            if CONFIG_SOC_WIFI_HE_SUPPORT and band is 5G, the default protocol is (WIFI_PROTOCOL_11A|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_11AC|WIFI_PROTOCOL_11AX).\n\n @attention 2.4G: Support 802.11b or 802.11bg or 802.11bgn or 802.11bgnax or LR mode\n            5G: Support 802.11a or 802.11an or 802.11anac or 802.11anacax\n\n @param     ifx  interfaces\n @param     protocol_bitmap  WiFi protocol bitmap\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_protocol(ifx: wifi_interface_t, protocol_bitmap: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the current protocol bitmap of the specified interface\n\n @param     ifx  interface\n @param[out] protocol_bitmap  store current WiFi protocol bitmap of interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_get_protocol(ifx: wifi_interface_t, protocol_bitmap: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the bandwidth of specified interface\n\n @attention 1. API return false if try to configure an interface that is not enabled\n @attention 2. WIFI_BW_HT40 is supported only when the interface support 11N\n\n @param     ifx  interface to be configured\n @param     bw  bandwidth\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_bandwidth(ifx: wifi_interface_t, bw: wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the bandwidth of specified interface\n\n @attention 1. API return false if try to get a interface that is not enable\n\n @param     ifx interface to be configured\n @param[out] bw  store bandwidth of interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_bandwidth(ifx: wifi_interface_t, bw: *mut wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set primary/secondary channel of device\n\n @attention 1. This API should be called after esp_wifi_start() and before esp_wifi_stop()\n @attention 2. When device is in STA mode, this API should not be called when STA is scanning or connecting to an external AP\n @attention 3. When device is in softAP mode, this API should not be called when softAP has connected to external STAs\n @attention 4. When device is in STA+softAP mode, this API should not be called when in the scenarios described above\n @attention 5. The channel info set by this API will not be stored in NVS. So If you want to remember the channel used before wifi stop,\n               you need to call this API again after wifi start, or you can call `esp_wifi_set_config()` to store the channel info in NVS.\n\n @param     primary  for HT20, primary is the channel number, for HT40, primary is the primary channel\n @param     second   for HT20, second is ignored, for HT40, second is the second channel\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_set_channel(primary: u8, second: wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the primary/secondary channel of device\n\n @attention 1. API return false if try to get a interface that is not enable\n\n @param     primary   store current primary channel\n @param[out]  second  store current second channel\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_channel(primary: *mut u8, second: *mut wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country info\n\n @attention 1. It is discouraged to call this API since this doesn't validate the per-country rules,\n               it's up to the user to fill in all fields according to local regulations.\n               Please use esp_wifi_set_country_code instead.\n @attention 2. The default country is \"01\" (world safe mode) {.cc=\"01\", .schan=1, .nchan=11, .policy=WIFI_COUNTRY_POLICY_AUTO}.\n @attention 3. The third octet of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '.\n @attention 4. When the country policy is WIFI_COUNTRY_POLICY_AUTO, the country info of the AP to which\n               the station is connected is used. E.g. if the configured country info is {.cc=\"US\", .schan=1, .nchan=11}\n               and the country info of the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14}\n               then the country info that will be used is {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected\n               from the AP the country info is set back to the country info of the station automatically,\n               {.cc=\"US\", .schan=1, .nchan=11} in the example.\n @attention 5. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, then the configured country info is used always.\n @attention 6. When the country info is changed because of configuration or because the station connects to a different\n               external AP, the country IE in probe response/beacon of the soft-AP is also changed.\n @attention 7. The country configuration is stored into flash.\n @attention 8. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the\n               country info.\n\n @param     country   the configured country info\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country(country: *const wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country info\n\n @param     country  country info\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country(country: *mut wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set MAC address of WiFi station, soft-AP or NAN interface.\n\n @attention 1. This API can only be called when the interface is disabled\n @attention 2. Above mentioned interfaces have different MAC addresses, do not set them to be the same.\n @attention 3. The bit 0 of the first byte of MAC address can not be 1. For example, the MAC address\n      can set to be \"1a:XX:XX:XX:XX:XX\", but can not be \"15:XX:XX:XX:XX:XX\".\n\n @param     ifx  interface\n @param     mac  the MAC address\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_WIFI_MAC: invalid mac address\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_mac(ifx: wifi_interface_t, mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mac of specified interface\n\n @param      ifx  interface\n @param[out] mac  store mac of the interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_mac(ifx: wifi_interface_t, mac: *mut u8) -> esp_err_t;
}
#[doc = " @brief The RX callback function in the promiscuous mode.\n        Each time a packet is received, the callback function will be called.\n\n @param buf  Data received. Type of data in buffer (wifi_promiscuous_pkt_t or wifi_pkt_rx_ctrl_t) indicated by 'type' parameter.\n @param type  promiscuous packet type.\n"]
pub type wifi_promiscuous_cb_t = ::core::option::Option<
    unsafe extern "C" fn(buf: *mut crate::c_types::c_void, type_: wifi_promiscuous_pkt_type_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function in the promiscuous mode.\n\n Each time a packet is received, the registered callback function will be called.\n\n @param cb  callback\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Enable the promiscuous mode.\n\n @param     en  false - disable, true - enable\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous mode.\n\n @param[out] en  store the current status of promiscuous mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous(en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the promiscuous mode packet type filter.\n\n @note The default filter is to filter all packets except WIFI_PKT_MISC\n\n @param filter the packet type filtered in promiscuous mode.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_filter(filter: *const wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous filter.\n\n @param[out] filter  store the current status of promiscuous filter\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_filter(filter: *mut wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable subtype filter of the control packet in promiscuous mode.\n\n @note The default filter is to filter none control packet.\n\n @param filter the subtype of the control packet filtered in promiscuous mode.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_ctrl_filter(
        filter: *const wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the subtype filter of the control packet in promiscuous mode.\n\n @param[out] filter  store the current status of subtype filter of the control packet in promiscuous mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_ctrl_filter(
        filter: *mut wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the configuration of the STA, AP or NAN\n\n @attention 1. This API can be called only when specified interface is enabled, otherwise, API fail\n @attention 2. For station configuration, bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP.\n @attention 3. ESP devices are limited to only one channel, so when in the soft-AP+station mode, the soft-AP will adjust its channel automatically to be the same as\n               the channel of the station.\n @attention 4. The configuration will be stored in NVS for station and soft-AP\n\n @param     interface  interface\n @param     conf  station, soft-AP or NAN configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_WIFI_MODE: invalid mode\n    - ESP_ERR_WIFI_PASSWORD: invalid password\n    - ESP_ERR_WIFI_NVS: WiFi internal NVS error\n    - others: refer to the error code in esp_err.h"]
    pub fn esp_wifi_set_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get configuration of specified interface\n\n @param     interface  interface\n @param[out]  conf  station or soft-AP configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get STAs associated with soft-AP\n\n @attention SSC only API\n\n @param[out] sta  station list\n             ap can get the connected sta's phy mode info through the struct member\n             phy_11b，phy_11g，phy_11n，phy_lr in the wifi_sta_info_t struct.\n             For example, phy_11b = 1 imply that sta support 802.11b mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_list(sta: *mut wifi_sta_list_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AID of STA connected with soft-AP\n\n @param     mac  STA's mac address\n @param[out]  aid  Store the AID corresponding to STA mac\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_NOT_FOUND: Requested resource not found\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_aid(mac: *const u8, aid: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi API configuration storage type\n\n @attention 1. The default value is WIFI_STORAGE_FLASH\n\n @param     storage : storage type\n\n @return\n   - ESP_OK: succeed\n   - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n   - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_storage(storage: wifi_storage_t) -> esp_err_t;
}
#[doc = " @brief     Function signature for received Vendor-Specific Information Element callback.\n @param     ctx Context argument, as passed to esp_wifi_set_vendor_ie_cb() when registering callback.\n @param     type Information element type, based on frame type received.\n @param     sa Source 802.11 address.\n @param     vnd_ie Pointer to the vendor specific element data received.\n @param     rssi Received signal strength indication."]
pub type esp_vendor_ie_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        type_: wifi_vendor_ie_type_t,
        sa: *const u8,
        vnd_ie: *const vendor_ie_data_t,
        rssi: crate::c_types::c_int,
    ),
>;
extern "C" {
    #[doc = " @brief     Set 802.11 Vendor-Specific Information Element\n\n @param     enable If true, specified IE is enabled. If false, specified IE is removed.\n @param     type Information Element type. Determines the frame type to associate with the IE.\n @param     idx  Index to set or clear. Each IE type can be associated with up to two elements (indices 0 & 1).\n @param     vnd_ie Pointer to vendor specific element data. First 6 bytes should be a header with fields matching vendor_ie_data_t.\n            If enable is false, this argument is ignored and can be NULL. Data does not need to remain valid after the function returns.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init()\n    - ESP_ERR_INVALID_ARG: Invalid argument, including if first byte of vnd_ie is not WIFI_VENDOR_IE_ELEMENT_ID (0xDD)\n      or second byte is an invalid length.\n    - ESP_ERR_NO_MEM: Out of memory"]
    pub fn esp_wifi_set_vendor_ie(
        enable: bool,
        type_: wifi_vendor_ie_type_t,
        idx: wifi_vendor_ie_id_t,
        vnd_ie: *const crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register Vendor-Specific Information Element monitoring callback.\n\n @param     cb   Callback function\n @param     ctx  Context argument, passed to callback function.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_vendor_ie_cb(
        cb: esp_vendor_ie_cb_t,
        ctx: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set maximum transmitting power after WiFi start.\n\n @attention 1. Maximum power before wifi startup is limited by PHY init data bin.\n @attention 2. The value set by this API will be mapped to the max_tx_power of the structure wifi_country_t variable.\n @attention 3. Mapping Table {Power, max_tx_power} = {{8,   2}, {20,  5}, {28,  7}, {34,  8}, {44, 11},\n                                                      {52, 13}, {56, 14}, {60, 15}, {66, 16}, {72, 18}, {80, 20}}.\n @attention 4. Param power unit is 0.25dBm, range is [8, 84] corresponding to 2dBm - 20dBm.\n @attention 5. Relationship between set value and actual value. As follows: {set value range, actual value} = {{[8,  19],8}, {[20, 27],20}, {[28, 33],28}, {[34, 43],34}, {[44, 51],44}, {[52, 55],52}, {[56, 59],56}, {[60, 65],60}, {[66, 71],66}, {[72, 79],72}, {[80, 84],80}}.\n\n @param     power  Maximum WiFi transmitting power.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument, e.g. parameter is out of range"]
    pub fn esp_wifi_set_max_tx_power(power: i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get maximum transmitting power after WiFi start\n\n @param     power Maximum WiFi transmitting power, unit is 0.25dBm.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_max_tx_power(power: *mut i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mask to enable or disable some WiFi events\n\n @attention 1. Mask can be created by logical OR of various WIFI_EVENT_MASK_ constants.\n               Events which have corresponding bit set in the mask will not be delivered to the system event handler.\n @attention 2. Default WiFi event mask is WIFI_EVENT_MASK_AP_PROBEREQRECVED.\n @attention 3. There may be lots of stations sending probe request data around.\n               Don't unmask this event unless you need to receive probe request data.\n\n @param     mask  WiFi event mask.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_event_mask(mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mask of WiFi events\n\n @param     mask  WiFi event mask.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_event_mask(mask: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send raw ieee80211 data\n\n @attention Currently only support for sending beacon/probe request/probe response/action and non-QoS\n            data frame\n\n @param     ifx interface if the Wi-Fi mode is Station, the ifx should be WIFI_IF_STA. If the Wi-Fi\n            mode is SoftAP, the ifx should be WIFI_IF_AP. If the Wi-Fi mode is Station+SoftAP, the\n            ifx should be WIFI_IF_STA or WIFI_IF_AP. If the ifx is wrong, the API returns ESP_ERR_WIFI_IF.\n @param     buffer raw ieee80211 buffer\n @param     len the length of raw buffer, the len must be <= 1500 Bytes and >= 24 Bytes\n @param     en_sys_seq indicate whether use the internal sequence number. If en_sys_seq is false, the\n            sequence in raw buffer is unchanged, otherwise it will be overwritten by WiFi driver with\n            the system sequence number.\n            Generally, if esp_wifi_80211_tx is called before the Wi-Fi connection has been set up, both\n            en_sys_seq==true and en_sys_seq==false are fine. However, if the API is called after the Wi-Fi\n            connection has been set up, en_sys_seq must be true, otherwise ESP_ERR_INVALID_ARG is returned.\n\n @return\n    - ESP_OK: success\n    - ESP_ERR_WIFI_IF: Invalid interface\n    - ESP_ERR_INVALID_ARG: Invalid parameter\n    - ESP_ERR_WIFI_NO_MEM: out of memory"]
    pub fn esp_wifi_80211_tx(
        ifx: wifi_interface_t,
        buffer: *const crate::c_types::c_void,
        len: crate::c_types::c_int,
        en_sys_seq: bool,
    ) -> esp_err_t;
}
#[doc = " @brief The RX callback function of Channel State Information(CSI)  data.\n\n        Each time a CSI data is received, the callback function will be called.\n\n @param ctx context argument, passed to esp_wifi_set_csi_rx_cb() when registering callback function.\n @param data CSI data received. The memory that it points to will be deallocated after callback function returns.\n"]
pub type wifi_csi_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void, data: *mut wifi_csi_info_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function of CSI data.\n\n        Each time a CSI data is received, the callback function will be called.\n\n @param cb  callback\n @param ctx context argument, passed to callback function\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_csi_rx_cb(cb: wifi_csi_cb_t, ctx: *mut crate::c_types::c_void)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set CSI data configuration\n\n @param config configuration\n\n return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi_config(config: *const wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get CSI data configuration\n\n @param config configuration\n\n return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_csi_config(config: *mut wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable CSI\n\n @param en true - enable, false - disable\n\n return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna GPIO configuration\n\n @param     config  Antenna GPIO configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: Invalid argument, e.g. parameter is NULL, invalid GPIO number etc"]
    pub fn esp_wifi_set_ant_gpio(config: *const wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna GPIO configuration\n\n @param     config  Antenna GPIO configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant_gpio(config: *mut wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna configuration\n\n @param     config  Antenna configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: Invalid argument, e.g. parameter is NULL, invalid antenna mode or invalid GPIO number"]
    pub fn esp_wifi_set_ant(config: *const wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna configuration\n\n @param     config  Antenna configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant(config: *mut wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the TSF time\n             In Station mode or SoftAP+Station mode if station is not connected or station doesn't receive at least\n             one beacon after connected, will return 0\n\n @attention  Enabling power save may cause the return value inaccurate, except WiFi modem sleep\n\n @param      interface The interface whose tsf_time is to be retrieved.\n\n @return     0 or the TSF time"]
    pub fn esp_wifi_get_tsf_time(interface: wifi_interface_t) -> i64;
}
extern "C" {
    #[doc = " @brief     Set the inactive time of the STA or AP\n\n @attention 1. For Station, If the station does not receive a beacon frame from the connected SoftAP during the inactive time,\n               disconnect from SoftAP. Default 6s.\n @attention 2. For SoftAP, If the softAP doesn't receive any data from the connected STA during inactive time,\n               the softAP will force deauth the STA. Default is 300s.\n @attention 3. The inactive time configuration is not stored into flash\n\n @param     ifx  interface to be configured.\n @param     sec  Inactive time. Unit seconds.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument, For Station, if sec is less than 3. For SoftAP, if sec is less than 10."]
    pub fn esp_wifi_set_inactive_time(ifx: wifi_interface_t, sec: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get inactive time of specified interface\n\n @param     ifx  Interface to be configured.\n @param     sec  Inactive time. Unit seconds.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_inactive_time(ifx: wifi_interface_t, sec: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Dump WiFi statistics\n\n @param     modules statistic modules to be dumped\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_statis_dump(modules: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set RSSI threshold, if average rssi gets lower than threshold, WiFi task will post event WIFI_EVENT_STA_BSS_RSSI_LOW.\n\n @attention  If the user wants to receive another WIFI_EVENT_STA_BSS_RSSI_LOW event after receiving one, this API needs to be\n             called again with an updated/same RSSI threshold.\n\n @param      rssi threshold value in dbm between -100 to 10\n             Note that in some rare cases where signal strength is very strong, rssi values can be slightly positive.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_rssi_threshold(rssi: i32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Start an FTM Initiator session by sending FTM request\n             If successful, event WIFI_EVENT_FTM_REPORT is generated with the result of the FTM procedure\n\n @attention  1. Use this API only in Station mode.\n @attention  2. If FTM is initiated on a different channel than Station is connected in or internal SoftAP is started in,\n                FTM defaults to a single burst in ASAP mode.\n\n @param      cfg  FTM Initiator session configuration\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_initiate_session(cfg: *mut wifi_ftm_initiator_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      End the ongoing FTM Initiator session\n\n @attention  This API works only on FTM Initiator\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_end_session() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set offset in cm for FTM Responder. An equivalent offset is calculated in picoseconds\n             and added in TOD of FTM Measurement frame (T1).\n\n @attention  Use this API only in AP mode before performing FTM as responder\n\n @param      offset_cm  T1 Offset to be added in centimeters\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_resp_set_offset(offset_cm: i16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get FTM measurements report copied into a user provided buffer.\n\n @attention  1. To get the FTM report, user first needs to allocate a buffer of size\n                (sizeof(wifi_ftm_report_entry_t) * num_entries) where the API will fill up to num_entries\n                valid FTM measurements in the buffer. Total number of entries can be found in the event\n                WIFI_EVENT_FTM_REPORT as ftm_report_num_entries\n @attention  2. The internal FTM report is freed upon use of this API which means the API can only be used\n                once after every FTM session initiated\n @attention  3. Passing the buffer as NULL merely frees the FTM report\n\n @param      report  Pointer to the buffer for receiving the FTM report\n @param      num_entries Number of FTM report entries to be filled in the report\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_get_report(
        report: *mut wifi_ftm_report_entry_t,
        num_entries: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Enable or disable 11b rate of specified interface\n\n @attention  1. This API should be called after esp_wifi_init() and before esp_wifi_start().\n @attention  2. Only when really need to disable 11b rate call this API otherwise don't call this.\n\n @param      ifx  Interface to be configured.\n @param      disable true means disable 11b rate while false means enable 11b rate.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_11b_rate(ifx: wifi_interface_t, disable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set wake interval for connectionless modules to wake up periodically.\n\n @attention 1. Only one wake interval for all connectionless modules.\n @attention 2. This configuration could work at connected status.\n               When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status.\n @attention 3. Event WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START would be posted each time wake interval starts.\n @attention 4. Recommend to configure interval in multiples of hundred. (e.g. 100ms)\n @attention 5. Recommend to configure interval to ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE to get stable performance at coexistence mode.\n\n @param      wake_interval  Milliseconds after would the chip wake up, from 1 to 65535."]
    pub fn esp_wifi_connectionless_module_set_wake_interval(wake_interval: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Request extra reference of Wi-Fi radio.\n             Wi-Fi keep active state(RF opened) to be able to receive packets.\n\n @attention  Please pair the use of `esp_wifi_force_wakeup_acquire` with `esp_wifi_force_wakeup_release`.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_force_wakeup_acquire() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Release extra reference of Wi-Fi radio.\n             Wi-Fi go to sleep state(RF closed) if no more use of radio.\n\n @attention  Please pair the use of `esp_wifi_force_wakeup_acquire` with `esp_wifi_force_wakeup_release`.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_force_wakeup_release() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country\n\n @attention 1. When ieee80211d_enabled, the country info of the AP to which\n               the station is connected is used. E.g. if the configured country is US\n               and the country info of the AP to which the station is connected is JP\n               then the country info that will be used is JP. If the station disconnected\n               from the AP the country info is set back to the country info of the station automatically,\n               US in the example.\n @attention 2. When ieee80211d_enabled is disabled, then the configured country info is used always.\n @attention 3. When the country info is changed because of configuration or because the station connects to a different\n               external AP, the country IE in probe response/beacon of the soft-AP is also changed.\n @attention 4. The country configuration is stored into flash.\n @attention 5. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the\n               country info.\n @attention 6. Supported country codes are \"01\"(world safe mode) \"AT\",\"AU\",\"BE\",\"BG\",\"BR\",\n               \"CA\",\"CH\",\"CN\",\"CY\",\"CZ\",\"DE\",\"DK\",\"EE\",\"ES\",\"FI\",\"FR\",\"GB\",\"GR\",\"HK\",\"HR\",\"HU\",\n               \"IE\",\"IN\",\"IS\",\"IT\",\"JP\",\"KR\",\"LI\",\"LT\",\"LU\",\"LV\",\"MT\",\"MX\",\"NL\",\"NO\",\"NZ\",\"PL\",\"PT\",\n               \"RO\",\"SE\",\"SI\",\"SK\",\"TW\",\"US\"\n\n @attention 7. When country code \"01\" (world safe mode) is set, SoftAP mode won't contain country IE.\n @attention 8. The default country is \"01\" (world safe mode) and ieee80211d_enabled is TRUE.\n @attention 9. The third octet of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '.\n\n @param     country   the configured country ISO code\n @param     ieee80211d_enabled   802.11d is enabled or not\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country_code(
        country: *const crate::c_types::c_char,
        ieee80211d_enabled: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country code\n\n @param     country  country code\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country_code(country: *mut crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config 80211 tx rate of specified interface\n\n @attention  1. This API should be called after esp_wifi_init() and before esp_wifi_start().\n\n @param      ifx  Interface to be configured.\n @param      rate Phy rate to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_80211_tx_rate(ifx: wifi_interface_t, rate: wifi_phy_rate_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Disable PMF configuration for specified interface\n\n @attention  This API should be called after esp_wifi_set_config() and before esp_wifi_start().\n\n @param      ifx  Interface to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_disable_pmf_config(ifx: wifi_interface_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the Association id assigned to STA by AP\n\n @param[out] aid  store the aid\n\n @attention aid = 0 if station is not connected to AP.\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_get_aid(aid: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated phymode after connection.\n\n @param[out] phymode  store the negotiated phymode.\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_get_negotiated_phymode(phymode: *mut wifi_phy_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config dynamic carrier sense\n\n @attention  This API should be called after esp_wifi_start().\n\n @param      enabled Dynamic carrier sense is enabled or not.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_set_dynamic_cs(enabled: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the rssi information of AP to which the device is associated with\n\n @attention 1. This API should be called after station connected to AP.\n @attention 2. Use this API only in WIFI_MODE_STA or WIFI_MODE_APSTA mode.\n\n @param      rssi store the rssi info received from last beacon.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_FAIL: failed"]
    pub fn esp_wifi_sta_get_rssi(rssi: *mut crate::c_types::c_int) -> esp_err_t;
}
#[doc = "< protocol: ESPTouch"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH: smartconfig_type_t = 0;
#[doc = "< protocol: AirKiss"]
pub const smartconfig_type_t_SC_TYPE_AIRKISS: smartconfig_type_t = 1;
#[doc = "< protocol: ESPTouch and AirKiss"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_AIRKISS: smartconfig_type_t = 2;
#[doc = "< protocol: ESPTouch v2"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_V2: smartconfig_type_t = 3;
pub type smartconfig_type_t = crate::c_types::c_uint;
#[doc = "< Station smartconfig has finished to scan for APs"]
pub const smartconfig_event_t_SC_EVENT_SCAN_DONE: smartconfig_event_t = 0;
#[doc = "< Station smartconfig has found the channel of the target AP"]
pub const smartconfig_event_t_SC_EVENT_FOUND_CHANNEL: smartconfig_event_t = 1;
#[doc = "< Station smartconfig got the SSID and password"]
pub const smartconfig_event_t_SC_EVENT_GOT_SSID_PSWD: smartconfig_event_t = 2;
#[doc = "< Station smartconfig has sent ACK to cellphone"]
pub const smartconfig_event_t_SC_EVENT_SEND_ACK_DONE: smartconfig_event_t = 3;
#[doc = " Smartconfig event declarations"]
pub type smartconfig_event_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief smartconfig event base declaration"]
    pub static SC_EVENT: esp_event_base_t;
}
#[doc = " Argument structure for SC_EVENT_GOT_SSID_PSWD event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smartconfig_event_got_ssid_pswd_t {
    #[doc = "< SSID of the AP. Null terminated string."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of the AP. Null terminated string."]
    pub password: [u8; 64usize],
    #[doc = "< whether set MAC address of target AP or not."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP."]
    pub bssid: [u8; 6usize],
    #[doc = "< Type of smartconfig(ESPTouch or AirKiss)."]
    pub type_: smartconfig_type_t,
    #[doc = "< Token from cellphone which is used to send ACK to cellphone."]
    pub token: u8,
    #[doc = "< IP address of cellphone."]
    pub cellphone_ip: [u8; 4usize],
}
#[doc = " Configure structure for esp_smartconfig_start"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smartconfig_start_config_t {
    #[doc = "< Enable smartconfig logs."]
    pub enable_log: bool,
    #[doc = "< Enable ESPTouch v2 crypt."]
    pub esp_touch_v2_enable_crypt: bool,
    #[doc = "< ESPTouch v2 crypt key, len should be 16."]
    pub esp_touch_v2_key: *mut crate::c_types::c_char,
}
extern "C" {
    #[doc = " @brief  Get the version of SmartConfig.\n\n @return\n     - SmartConfig version const char."]
    pub fn esp_smartconfig_get_version() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP.\n            Device sniffer special packets from the air that containing SSID and password of target AP.\n\n @attention 1. This API can be called in station or softAP-station mode.\n @attention 2. Can not call esp_smartconfig_start twice before it finish, please call\n               esp_smartconfig_stop first.\n\n @param     config pointer to smartconfig start configure structure\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_start(config: *const smartconfig_start_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start.\n\n @attention Whether connect to AP succeed or not, this API should be called to free\n            memory taken by smartconfig_start.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set timeout of SmartConfig process.\n\n @attention Timing starts from SC_STATUS_FIND_CHANNEL status. SmartConfig will restart if timeout.\n\n @param     time_s  range 15s~255s, offset:45s.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_esptouch_set_timeout(time_s: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of SmartConfig.\n\n @attention If users need to set the SmartConfig type, please set it before calling\n            esp_smartconfig_start.\n\n @param     type  Choose from the smartconfig_type_t.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_set_type(type_: smartconfig_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mode of SmartConfig. default normal mode.\n\n @attention 1. Please call it before API esp_smartconfig_start.\n @attention 2. Fast mode have corresponding APP(phone).\n @attention 3. Two mode is compatible.\n\n @param     enable  false-disable(default); true-enable;\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_fast_mode(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get reserved data of ESPTouch v2.\n\n @param     rvd_data  reserved  data\n @param     len length  of  reserved data\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_get_rvd_data(rvd_data: *mut u8, len: u8) -> esp_err_t;
}
#[doc = "< Set the configuration of STA's HT2040 coexist management"]
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_SET_STA_HT2040_COEX: wifi_ioctl_cmd_t = 1;
#[doc = "< Get the configuration of STA's HT2040 coexist management"]
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_GET_STA_HT2040_COEX: wifi_ioctl_cmd_t = 2;
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_MAX: wifi_ioctl_cmd_t = 3;
#[doc = " @brief WiFi ioctl command type\n"]
pub type wifi_ioctl_cmd_t = crate::c_types::c_uint;
#[doc = " @brief Configuration for STA's HT2040 coexist management\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ht2040_coex_t {
    #[doc = "< Indicate whether STA's HT2040 coexist management is enabled or not"]
    pub enable: crate::c_types::c_int,
}
#[doc = " @brief Configuration for WiFi ioctl\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ioctl_config_t {
    #[doc = "< Configuration of ioctl command"]
    pub data: wifi_ioctl_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_ioctl_config_t__bindgen_ty_1 {
    #[doc = "< Configuration of STA's HT2040 coexist management"]
    pub ht2040_coex: wifi_ht2040_coex_t,
}
pub const wifi_beacon_drop_t_WIFI_BEACON_DROP_DISABLED: wifi_beacon_drop_t = 0;
pub const wifi_beacon_drop_t_WIFI_BEACON_DROP_AUTO: wifi_beacon_drop_t = 1;
pub const wifi_beacon_drop_t_WIFI_BEACON_DROP_FORCED: wifi_beacon_drop_t = 2;
#[doc = " @brief Mode for WiFi beacon drop\n"]
pub type wifi_beacon_drop_t = crate::c_types::c_uint;
#[doc = " @brief WiFi beacon monitor parameter configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_beacon_monitor_config_t {
    #[doc = "< Enable or disable beacon monitor"]
    pub enable: bool,
    #[doc = "< Beacon lost timeout"]
    pub loss_timeout: u8,
    #[doc = "< Maximum number of consecutive lost beacons allowed"]
    pub loss_threshold: u8,
    #[doc = "< Delta early time for RF PHY on"]
    pub delta_intr_early: u8,
    #[doc = "< Delta timeout time for RF PHY off"]
    pub delta_loss_timeout: u8,
    #[doc = "< Whether to drop the beacon if the beacon lost exceeds loss_threshold"]
    pub beacon_drop: wifi_beacon_drop_t,
}
#[doc = " @brief WiFi beacon sample parameter configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_beacon_offset_config_t {
    #[doc = "< Sample beacon period, unit: number of beacons"]
    pub sample_period: u16,
    #[doc = "< Resample period if beacon drop is active under the auto mode, unit: hours */\n/**< Standard triggers beacon drop when the expected rx beacon probability falls below this value under the auto mode, unit: percentage"]
    pub resample_period: u8,
    pub standard: u8,
    pub difference: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_static_queue_t {
    #[doc = "< FreeRTOS queue handler"]
    pub handle: QueueHandle_t,
    #[doc = "< storage for FreeRTOS queue"]
    pub storage: *mut crate::c_types::c_void,
}
pub const wifi_log_level_t_WIFI_LOG_NONE: wifi_log_level_t = 0;
pub const wifi_log_level_t_WIFI_LOG_ERROR: wifi_log_level_t = 1;
pub const wifi_log_level_t_WIFI_LOG_WARNING: wifi_log_level_t = 2;
pub const wifi_log_level_t_WIFI_LOG_INFO: wifi_log_level_t = 3;
pub const wifi_log_level_t_WIFI_LOG_DEBUG: wifi_log_level_t = 4;
pub const wifi_log_level_t_WIFI_LOG_VERBOSE: wifi_log_level_t = 5;
#[doc = " @brief WiFi log level\n"]
pub type wifi_log_level_t = crate::c_types::c_uint;
pub const wifi_log_module_t_WIFI_LOG_MODULE_ALL: wifi_log_module_t = 0;
pub const wifi_log_module_t_WIFI_LOG_MODULE_WIFI: wifi_log_module_t = 1;
pub const wifi_log_module_t_WIFI_LOG_MODULE_COEX: wifi_log_module_t = 2;
pub const wifi_log_module_t_WIFI_LOG_MODULE_MESH: wifi_log_module_t = 3;
#[doc = " @brief WiFi log module definition\n"]
pub type wifi_log_module_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief Initialize Wi-Fi Driver\n     Alloc resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n     WiFi NVS structure among others.\n\n For the most part, you need not call this function directly. It gets called\n from esp_wifi_init().\n\n This function may be called, if you only need to initialize the Wi-Fi driver\n without having to use the network stack on top.\n\n @param  config provide WiFi init configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_NO_MEM: out of memory\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init_internal(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize Wi-Fi Driver\n     Free resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n     WiFi NVS structure among others.\n\n For the most part, you need not call this function directly. It gets called\n from esp_wifi_deinit().\n\n This function may be called, if you call esp_wifi_init_internal to initialize\n WiFi driver.\n\n @return\n    - ESP_OK: succeed\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_deinit_internal() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  free the rx buffer which allocated by wifi driver\n\n @param  void* buffer: rx buffer pointer"]
    pub fn esp_wifi_internal_free_rx_buffer(buffer: *mut crate::c_types::c_void);
}
extern "C" {
    #[doc = " @brief  transmit the buffer via wifi driver\n\n This API makes a copy of the input buffer and then forwards the buffer\n copy to WiFi driver.\n\n @param  wifi_interface_t wifi_if : wifi interface id\n @param  void *buffer : the buffer to be transmit\n @param  uint16_t len : the length of buffer\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF : WiFi interface is invalid\n    - ESP_ERR_WIFI_CONN : WiFi interface is not created, e.g. send the data to STA while WiFi mode is AP mode\n    - ESP_ERR_WIFI_NOT_STARTED : WiFi is not started\n    - ESP_ERR_WIFI_STATE : WiFi internal state is not ready, e.g. WiFi is not started\n    - ESP_ERR_WIFI_NOT_ASSOC : WiFi is not associated\n    - ESP_ERR_WIFI_TX_DISALLOW : WiFi TX is disallowed, e.g. WiFi hasn't pass the authentication\n    - ESP_ERR_WIFI_POST : caller fails to post event to WiFi task"]
    pub fn esp_wifi_internal_tx(
        wifi_if: wifi_interface_t,
        buffer: *mut crate::c_types::c_void,
        len: u16,
    ) -> crate::c_types::c_int;
}
#[doc = " @brief     The net stack buffer reference counter callback function\n"]
pub type wifi_netstack_buf_ref_cb_t =
    ::core::option::Option<unsafe extern "C" fn(netstack_buf: *mut crate::c_types::c_void)>;
#[doc = " @brief     The net stack buffer free callback function\n"]
pub type wifi_netstack_buf_free_cb_t =
    ::core::option::Option<unsafe extern "C" fn(netstack_buf: *mut crate::c_types::c_void)>;
extern "C" {
    #[doc = " @brief  transmit the buffer by reference via wifi driver\n\n This API firstly increases the reference counter of the input buffer and\n then forwards the buffer to WiFi driver. The WiFi driver will free the buffer\n after processing it. Use esp_wifi_internal_tx() if the uplayer buffer doesn't\n supports reference counter.\n\n @param  wifi_if : wifi interface id\n @param  buffer : the buffer to be transmit\n @param  len : the length of buffer\n @param  netstack_buf : the netstack buffer related to buffer\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF : WiFi interface is invalid\n    - ESP_ERR_WIFI_CONN : WiFi interface is not created, e.g. send the data to STA while WiFi mode is AP mode\n    - ESP_ERR_WIFI_NOT_STARTED : WiFi is not started\n    - ESP_ERR_WIFI_STATE : WiFi internal state is not ready, e.g. WiFi is not started\n    - ESP_ERR_WIFI_NOT_ASSOC : WiFi is not associated\n    - ESP_ERR_WIFI_TX_DISALLOW : WiFi TX is disallowed, e.g. WiFi hasn't pass the authentication\n    - ESP_ERR_WIFI_POST : caller fails to post event to WiFi task"]
    pub fn esp_wifi_internal_tx_by_ref(
        ifx: wifi_interface_t,
        buffer: *mut crate::c_types::c_void,
        len: usize,
        netstack_buf: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Initialize WAPI function when wpa_supplicant initialize.\n\n This API is privately used, be careful not open to external applicantion.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WAPI_INTERNAL : Internal error"]
    pub fn esp_wifi_internal_wapi_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize WAPI function when wpa_supplicant de-initialize.\n\n This API is privately used, be careful not open to external applicantion.\n\n @return\n          - ESP_OK : succeed"]
    pub fn esp_wifi_internal_wapi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  register the net stack buffer reference increasing and free callback\n\n @param  ref : net stack buffer reference callback\n @param  free: net stack buffer free callback\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - others  : failed to register the callback"]
    pub fn esp_wifi_internal_reg_netstack_buf_cb(
        ref_: wifi_netstack_buf_ref_cb_t,
        free: wifi_netstack_buf_free_cb_t,
    ) -> esp_err_t;
}
#[doc = " @brief     The WiFi RX callback function\n\n            Each time the WiFi need to forward the packets to high layer, the callback function will be called"]
pub type wifi_rxcb_t = ::core::option::Option<
    unsafe extern "C" fn(
        buffer: *mut crate::c_types::c_void,
        len: u16,
        eb: *mut crate::c_types::c_void,
    ) -> esp_err_t,
>;
extern "C" {
    #[doc = " @brief     Set the WiFi RX callback\n\n @attention 1. Currently we support only one RX callback for each interface\n\n @param     wifi_interface_t ifx : interface\n @param     wifi_rxcb_t fn : WiFi RX callback\n\n @return\n     - ESP_OK : succeed\n     - others : fail"]
    pub fn esp_wifi_internal_reg_rxcb(ifx: wifi_interface_t, fn_: wifi_rxcb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Notify WIFI driver that the station got ip successfully\n\n @return\n     - ESP_OK : succeed\n     - others : fail"]
    pub fn esp_wifi_internal_set_sta_ip() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  enable or disable transmitting WiFi MAC frame with fixed rate\n\n @attention 1. If fixed rate is enabled, both management and data frame are transmitted with fixed rate\n @attention 2. Make sure that the receiver is able to receive the frame with the fixed rate if you want the frame to be received\n @attention 3. Not support to set fix rate for espnow and 80211_tx\n\n @param  ifx : wifi interface\n @param  en : false - disable, true - enable\n @param  rate : PHY rate\n\n @return\n    - ERR_OK  : succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_WIFI_IF : invalid WiFi interface\n    - ESP_ERR_INVALID_ARG : invalid rate\n    - ESP_ERR_NOT_SUPPORTED : do not support to set fixed rate if TX AMPDU is enabled"]
    pub fn esp_wifi_internal_set_fix_rate(
        ifx: wifi_interface_t,
        en: bool,
        rate: wifi_phy_rate_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP.\n            Device sniffer special packets from the air that containing SSID and password of target AP.\n\n @attention 1. This API can be called in station or softAP-station mode.\n @attention 2. Can not call esp_smartconfig_start twice before it finish, please call\n               esp_smartconfig_stop first.\n\n @param     config pointer to smartconfig start configure structure\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_internal_start(config: *const smartconfig_start_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start.\n\n @attention Whether connect to AP succeed or not, this API should be called to free\n            memory taken by smartconfig_start.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_internal_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the OS adapter header files in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_osi_funcs_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the crypto types header files in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_crypto_funcs_md5_check(
        md5: *const crate::c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_types.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_wifi_type_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_he_types.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_wifi_he_type_md5_check(
        md5: *const crate::c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_esp_wifi_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_he.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_esp_wifi_he_md5_check(md5: *const crate::c_types::c_char)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Allocate a chunk of memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_malloc(size: usize) -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief     Reallocate a chunk of memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     void * ptr  : Pointer to previously allocated memory, or NULL for a new allocation.\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_realloc(
        ptr: *mut crate::c_types::c_void,
        size: usize,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief     Callocate memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     size_t n    : Number of continuing chunks of memory to allocate\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_calloc(n: usize, size: usize) -> *mut crate::c_types::c_void;
}
#[doc = " @brief     Update WiFi MAC time\n\n @param     uint32_t time_delta : time duration since the WiFi/BT common clock is disabled\n\n @return    Always returns ESP_OK"]
pub type wifi_mac_time_update_cb_t =
    ::core::option::Option<unsafe extern "C" fn(time_delta: u32) -> esp_err_t>;
extern "C" {
    #[doc = " @brief     Update WiFi MAC time\n\n @param     uint32_t time_delta : time duration since the WiFi/BT common clock is disabled\n\n @return    Always returns ESP_OK"]
    pub fn esp_wifi_internal_update_mac_time(time_delta: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi log level\n\n @param     level   Log level.\n\n @return\n    - ESP_OK: succeed\n    - ESP_FAIL: level is invalid"]
    pub fn esp_wifi_internal_set_log_level(level: wifi_log_level_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current log module and submodule\n\n @param     module      Log module\n @param     submodule   Log submodule\n @param     enable      enable or disable\n            If module == 0 && enable == 0, all log modules are disabled.\n            If module == 0 && enable == 1, all log modules are enabled.\n            If submodule == 0 && enable == 0, all log submodules are disabled.\n            If submodule == 0 && enable == 1, all log submodules are enabled.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_internal_set_log_mod(
        module: wifi_log_module_t,
        submodule: u32,
        enable: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi log info\n\n @param     log_level  the return log level.\n @param     log_mod    the return log module and submodule\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_log(
        log_level: *mut wifi_log_level_t,
        log_mod: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     A general API to set/get WiFi internal configuration, it's for debug only\n\n @param     cmd : ioctl command type\n @param     cfg : configuration for the command\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_internal_ioctl(
        cmd: crate::c_types::c_int,
        cfg: *mut wifi_ioctl_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the user-configured channel info\n\n @param     ifx : WiFi interface\n @param     primary : store the configured primary channel\n @param     second : store the configured second channel\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_config_channel(
        ifx: wifi_interface_t,
        primary: *mut u8,
        second: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated channel info after WiFi connection established\n\n @param     ifx : WiFi interface\n @param     aid : the connection number when a STA connects to the softAP\n @param     primary : store the negotiated primary channel\n @param     second : store the negotiated second channel\n @attention the aid param is only works when the device in softAP/softAP+STA mode\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_negotiated_channel(
        ifx: wifi_interface_t,
        aid: u8,
        primary: *mut u8,
        second: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated bandwidth info after WiFi connection established\n\n @param     ifx : WiFi interface\n @param     bw : store the negotiated bandwidth\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_negotiated_bandwidth(
        ifx: wifi_interface_t,
        aid: u8,
        bw: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wifi power domain power on"]
    pub fn esp_wifi_power_domain_on();
}
extern "C" {
    #[doc = " @brief Wifi power domain power off"]
    pub fn esp_wifi_power_domain_off();
}
#[doc = " @brief    TxDone callback function type. Should be registered using esp_wifi_set_tx_done_cb()\n\n @param    ifidx The interface id that the tx callback has been triggered from\n @param    data Pointer to the data transmitted\n @param    data_len Length of the data transmitted\n @param    txStatus True:if the data was transmitted successfully False: if data transmission failed"]
pub type wifi_tx_done_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ifidx: u8, data: *mut u8, data_len: *mut u16, txStatus: bool),
>;
extern "C" {
    #[doc = " @brief    Register the txDone callback function of type wifi_tx_done_cb_t\n\n @param    cb The callback function\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_set_tx_done_cb(cb: wifi_tx_done_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set device spp amsdu attributes\n\n @param     ifx: WiFi interface\n @param     spp_cap: spp amsdu capable\n @param     spp_req: spp amsdu require\n\n @return\n     - ESP_OK: succeed\n     - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n     - ESP_ERR_WIFI_IF : invalid WiFi interface"]
    pub fn esp_wifi_internal_set_spp_amsdu(
        ifidx: wifi_interface_t,
        spp_cap: bool,
        spp_req: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Update WIFI light sleep default parameters\n\n @param   min_freq_mhz: minimum frequency of DFS\n @param   max_freq_mhz: maximum frequency of DFS"]
    pub fn esp_wifi_internal_update_light_sleep_default_params(
        min_freq_mhz: crate::c_types::c_int,
        max_freq_mhz: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " @brief   Update WIFI modem sleep default parameters"]
    pub fn esp_wifi_internal_update_modem_sleep_default_params();
}
extern "C" {
    #[doc = " @brief   Set the min active time for wifi to enter the sleep state when light sleep\n\n @param   min_active_time: minimum timeout time  for waiting to receive\n                      data, when no data is received during the timeout period,\n                      the wifi enters the sleep process."]
    pub fn esp_wifi_set_sleep_min_active_time(min_active_time: u32);
}
extern "C" {
    #[doc = " @brief   Set wifi keep alive time\n\n @param   keep_alive_time: keep alive time"]
    pub fn esp_wifi_set_keep_alive_time(keep_alive_time: u32);
}
extern "C" {
    #[doc = " @brief      Set the min broadcast data wait time for wifi to enter the sleep state\n\n @attention  Default sleep wait broadcast data time is 15000, Uint µs.\n\n @param      time: When the station knows through the beacon that the AP\n                   will send broadcast packet, it will wait for a minimum of\n                   wait_broadcast_data_time before entering the sleep process."]
    pub fn esp_wifi_set_sleep_wait_broadcast_data_time(time: u32);
}
extern "C" {
    #[doc = " @brief   Configure wifi beacon montior default parameters\n\n @param   config: the configuration parameters for wifi beacon monitor"]
    pub fn esp_wifi_beacon_monitor_configure(config: *mut wifi_beacon_monitor_config_t);
}
extern "C" {
    #[doc = " @brief   Set modem state mode to require WiFi to enable or disable Advanced DTIM sleep function\n\n @param   require_modem_state: true for require WiFi to enable Advanced DTIM sleep function,\n                              false for require WiFi to disable Advanced DTIM sleep function.\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_modem_state_configure(require_modem_state: bool);
}
extern "C" {
    #[doc = " @brief   Set light sleep mode to require WiFi to enable or disable Advanced DTIM sleep function\n\n @param   light_sleep_enable: true for light sleep mode is enabled, false for light sleep mode is disabled.\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_light_sleep_configure(light_sleep_enable: bool);
}
extern "C" {
    #[doc = " @brief      Start Publishing a service in the NAN cluster\n\n @attention  This API should be called after esp_wifi_start() in NAN Mode.\n\n @param      publish_cfg  Configuration parameters for publishing a service.\n @param      id  Identifier for the Publish service.\n @param      cancel  Cancel the service identified by the id.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_publish_service(
        publish_cfg: *const wifi_nan_publish_cfg_t,
        id: *mut u8,
        cancel: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Subscribe for a service within the NAN cluster\n\n @attention  This API should be called after esp_wifi_start() in NAN Mode.\n\n @param      subscribe_cfg  Configuration parameters for subscribing for a service.\n @param      id  Identifier for the Subscribe service.\n @param      cancel  Cancel the service identified by the id.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_subscribe_service(
        subscribe_cfg: *const wifi_nan_subscribe_cfg_t,
        id: *mut u8,
        cancel: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Follow-up to the Publisher with matching service\n\n @attention  This API should be called after WIFI_EVENT_NAN_SVC_MATCH event is received.\n\n @param      fup_params  Configuration parameters for sending a Follow-up to the Peer.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_send_followup(
        fup_params: *const wifi_nan_followup_params_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Datapath Request to the Publisher with matching service\n\n @attention  This API should be called after WIFI_EVENT_NAN_SVC_MATCH event is received.\n\n @param      req  NAN Datapath Request parameters.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_datapath_req(
        req: *mut wifi_nan_datapath_req_t,
        ndp_id: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Datapath Response to accept or reject the received request\n\n @attention  This API should be called on the Publisher after receiving WIFI_EVENT_NDP_INDICATION event.\n\n @param      resp  NAN Datapath Response parameters.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_datapath_resp(resp: *mut wifi_nan_datapath_resp_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      End NAN Datapath that is active\n\n @attention  This API should be called after receiving WIFI_EVENT_NDP_CONFIRM event.\n\n @param      req  NAN Datapath end request parameters.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_nan_internal_datapath_end(req: *mut wifi_nan_datapath_end_req_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Connect WiFi station to the AP.\n\n @attention 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_MODE: WiFi mode error\n    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong\n    - ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid"]
    pub fn esp_wifi_connect_internal() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Disconnect WiFi station from the AP.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_FAIL: other WiFi internal errors\n"]
    pub fn esp_wifi_disconnect_internal() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the time information from the MAC clock. The time is precise only if modem sleep or light sleep is not enabled.\n\n @return 32-bit time value, unit: microsecond. This time is only 32 bits, which means it will overflow and reset to 0 after approximately 71 minutes.\n         Therefore, when using it, the time difference between two consecutive readings should not be too long."]
    pub fn esp_wifi_internal_get_mac_clock_time() -> u32;
}
extern "C" {
    #[doc = " @brief empty init pm_beacon_offset."]
    pub fn pm_beacon_offset_funcs_empty_init();
}
extern "C" {
    #[doc = " @brief This API is not context safe and enable easy fragment just for internal test only."]
    pub fn esp_wifi_enable_easy_fragment(enable: bool);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_osi_funcs_t {
    pub _version: i32,
    pub _env_is_chip: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _set_intr: ::core::option::Option<
        unsafe extern "C" fn(cpu_no: i32, intr_source: u32, intr_num: u32, intr_prio: i32),
    >,
    pub _clear_intr: ::core::option::Option<unsafe extern "C" fn(intr_source: u32, intr_num: u32)>,
    pub _set_isr: ::core::option::Option<
        unsafe extern "C" fn(
            n: i32,
            f: *mut crate::c_types::c_void,
            arg: *mut crate::c_types::c_void,
        ),
    >,
    pub _ints_on: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _ints_off: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _is_from_isr: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _spin_lock_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _spin_lock_delete:
        ::core::option::Option<unsafe extern "C" fn(lock: *mut crate::c_types::c_void)>,
    pub _wifi_int_disable: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut crate::c_types::c_void) -> u32,
    >,
    pub _wifi_int_restore: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut crate::c_types::c_void, tmp: u32),
    >,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create: ::core::option::Option<
        unsafe extern "C" fn(max: u32, init: u32) -> *mut crate::c_types::c_void,
    >,
    pub _semphr_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void)>,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut crate::c_types::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void) -> i32>,
    pub _wifi_thread_semphr_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _recursive_mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _mutex_delete:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void)>,
    pub _mutex_lock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void) -> i32>,
    pub _mutex_unlock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void) -> i32>,
    pub _queue_create: ::core::option::Option<
        unsafe extern "C" fn(queue_len: u32, item_size: u32) -> *mut crate::c_types::c_void,
    >,
    pub _queue_delete:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void)>,
    pub _queue_send: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            hptw: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _queue_send_to_back: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_to_front: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_recv: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_msg_waiting:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void) -> u32>,
    pub _event_group_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _event_group_delete:
        ::core::option::Option<unsafe extern "C" fn(event: *mut crate::c_types::c_void)>,
    pub _event_group_set_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut crate::c_types::c_void, bits: u32) -> u32,
    >,
    pub _event_group_clear_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut crate::c_types::c_void, bits: u32) -> u32,
    >,
    pub _event_group_wait_bits: ::core::option::Option<
        unsafe extern "C" fn(
            event: *mut crate::c_types::c_void,
            bits_to_wait_for: u32,
            clear_on_exit: crate::c_types::c_int,
            wait_for_all_bits: crate::c_types::c_int,
            block_time_tick: u32,
        ) -> u32,
    >,
    pub _task_create_pinned_to_core: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut crate::c_types::c_void,
            name: *const crate::c_types::c_char,
            stack_depth: u32,
            param: *mut crate::c_types::c_void,
            prio: u32,
            task_handle: *mut crate::c_types::c_void,
            core_id: u32,
        ) -> i32,
    >,
    pub _task_create: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut crate::c_types::c_void,
            name: *const crate::c_types::c_char,
            stack_depth: u32,
            param: *mut crate::c_types::c_void,
            prio: u32,
            task_handle: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _task_delete:
        ::core::option::Option<unsafe extern "C" fn(task_handle: *mut crate::c_types::c_void)>,
    pub _task_delay: ::core::option::Option<unsafe extern "C" fn(tick: u32)>,
    pub _task_ms_to_tick: ::core::option::Option<unsafe extern "C" fn(ms: u32) -> i32>,
    pub _task_get_current_task:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _task_get_max_priority: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    pub _malloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut crate::c_types::c_void)>,
    pub _event_post: ::core::option::Option<
        unsafe extern "C" fn(
            event_base: *const crate::c_types::c_char,
            event_id: i32,
            event_data: *mut crate::c_types::c_void,
            event_data_size: usize,
            ticks_to_wait: u32,
        ) -> i32,
    >,
    pub _get_free_heap_size: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _rand: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _dport_access_stall_other_cpu_start_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _dport_access_stall_other_cpu_end_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_apb80m_request: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_apb80m_release: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_common_clock_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_common_clock_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_update_country_info: ::core::option::Option<
        unsafe extern "C" fn(country: *const crate::c_types::c_char) -> crate::c_types::c_int,
    >,
    pub _read_mac: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut u8, type_: crate::c_types::c_uint) -> crate::c_types::c_int,
    >,
    pub _timer_arm: ::core::option::Option<
        unsafe extern "C" fn(timer: *mut crate::c_types::c_void, tmout: u32, repeat: bool),
    >,
    pub _timer_disarm:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut crate::c_types::c_void)>,
    pub _timer_done:
        ::core::option::Option<unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut crate::c_types::c_void,
            pfunction: *mut crate::c_types::c_void,
            parg: *mut crate::c_types::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void, us: u32, repeat: bool),
    >,
    pub _wifi_reset_mac: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_clock_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_clock_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_rtc_enable_iso: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_rtc_disable_iso: ::core::option::Option<unsafe extern "C" fn()>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _nvs_set_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: i8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut i8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_set_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: u8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut u8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_set_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: u16,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut u16,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_open: ::core::option::Option<
        unsafe extern "C" fn(
            name: *const crate::c_types::c_char,
            open_mode: crate::c_types::c_uint,
            out_handle: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_close: ::core::option::Option<unsafe extern "C" fn(handle: u32)>,
    pub _nvs_commit:
        ::core::option::Option<unsafe extern "C" fn(handle: u32) -> crate::c_types::c_int>,
    pub _nvs_set_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: *const crate::c_types::c_void,
            length: usize,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut crate::c_types::c_void,
            length: *mut usize,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_erase_key: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
        ) -> crate::c_types::c_int,
    >,
    pub _get_random: ::core::option::Option<
        unsafe extern "C" fn(buf: *mut u8, len: usize) -> crate::c_types::c_int,
    >,
    pub _get_time: ::core::option::Option<
        unsafe extern "C" fn(t: *mut crate::c_types::c_void) -> crate::c_types::c_int,
    >,
    pub _random: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_ulong>,
    pub _slowclk_cal_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _log_write: ::core::option::Option<
        unsafe extern "C" fn(
            level: crate::c_types::c_uint,
            tag: *const crate::c_types::c_char,
            format: *const crate::c_types::c_char,
            ...
        ),
    >,
    pub _log_writev: ::core::option::Option<
        unsafe extern "C" fn(
            level: crate::c_types::c_uint,
            tag: *const crate::c_types::c_char,
            format: *const crate::c_types::c_char,
            args: va_list,
        ),
    >,
    pub _log_timestamp: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _realloc_internal: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut crate::c_types::c_void,
            size: usize,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _calloc_internal: ::core::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut crate::c_types::c_void,
    >,
    pub _zalloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _wifi_malloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _wifi_realloc: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut crate::c_types::c_void,
            size: usize,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_calloc: ::core::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_zalloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut crate::c_types::c_void>,
    pub _wifi_create_queue: ::core::option::Option<
        unsafe extern "C" fn(
            queue_len: crate::c_types::c_int,
            item_size: crate::c_types::c_int,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_delete_queue:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void)>,
    pub _coex_init: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_deinit: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_enable: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_status_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_condition_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, dissatisfy: bool)>,
    pub _coex_wifi_request: ::core::option::Option<
        unsafe extern "C" fn(event: u32, latency: u32, duration: u32) -> crate::c_types::c_int,
    >,
    pub _coex_wifi_release:
        ::core::option::Option<unsafe extern "C" fn(event: u32) -> crate::c_types::c_int>,
    pub _coex_wifi_channel_set: ::core::option::Option<
        unsafe extern "C" fn(primary: u8, secondary: u8) -> crate::c_types::c_int,
    >,
    pub _coex_event_duration_get: ::core::option::Option<
        unsafe extern "C" fn(event: u32, duration: *mut u32) -> crate::c_types::c_int,
    >,
    pub _coex_pti_get: ::core::option::Option<
        unsafe extern "C" fn(event: u32, pti: *mut u8) -> crate::c_types::c_int,
    >,
    pub _coex_schm_status_bit_clear:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, status: u32)>,
    pub _coex_schm_status_bit_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, status: u32)>,
    pub _coex_schm_interval_set:
        ::core::option::Option<unsafe extern "C" fn(interval: u32) -> crate::c_types::c_int>,
    pub _coex_schm_interval_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_schm_curr_period_get: ::core::option::Option<unsafe extern "C" fn() -> u8>,
    pub _coex_schm_curr_phase_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _coex_schm_process_restart:
        ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_schm_register_cb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: crate::c_types::c_int,
            cb: ::core::option::Option<
                unsafe extern "C" fn(arg1: crate::c_types::c_int) -> crate::c_types::c_int,
            >,
        ) -> crate::c_types::c_int,
    >,
    pub _coex_register_start_cb: ::core::option::Option<
        unsafe extern "C" fn(
            cb: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
        ) -> crate::c_types::c_int,
    >,
    pub _coex_schm_flexible_period_set:
        ::core::option::Option<unsafe extern "C" fn(arg1: u8) -> crate::c_types::c_int>,
    pub _coex_schm_flexible_period_get: ::core::option::Option<unsafe extern "C" fn() -> u8>,
    pub _coex_schm_get_phase_by_idx: ::core::option::Option<
        unsafe extern "C" fn(arg1: crate::c_types::c_int) -> *mut crate::c_types::c_void,
    >,
    pub _magic: i32,
}
extern "C" {
    pub static g_wifi_default_mesh_crypto_funcs: mesh_crypto_funcs_t;
}
extern "C" {
    #[doc = " @brief     Supplicant initialization\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_NO_MEM : out of memory"]
    pub fn esp_supplicant_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Supplicant deinitialization\n\n @return\n          - ESP_OK : succeed\n          - others: failed"]
    pub fn esp_supplicant_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable or enable the caching of Pairwise Master Keys (PMK) in the supplicant.\n\n This function allows disabling or enabling the caching of Pairwise Master Keys (PMK).\n PMK caching is used in Wi-Fi Protected Access (WPA/WPA2/WPA3) networks to speed up the reconnection process\n by storing the PMK generated during the initial connection. Disabling PMK caching may result in slightly\n longer reconnection times. PMK caching is enabled by default, this configuration has been provided\n in case the AP is known not to support PMK caching or has a buggy implementation for PMK caching.\n\n @param disable Boolean indicating whether to disable (true) or enable (false) PMK caching.\n @return\n     - ESP_OK: Success\n     - An error code if disabling or enabling PMK caching fails."]
    pub fn esp_supplicant_disable_pmk_caching(disable: bool) -> esp_err_t;
}
#[doc = " @brief Structure holding PHY init parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_init_data_t {
    #[doc = "< opaque PHY initialization parameters"]
    pub params: [u8; 128usize],
}
#[doc = "< PHY modem WIFI"]
pub const esp_phy_modem_t_PHY_MODEM_WIFI: esp_phy_modem_t = 1;
#[doc = "< PHY modem BT"]
pub const esp_phy_modem_t_PHY_MODEM_BT: esp_phy_modem_t = 2;
#[doc = "< PHY modem IEEE802154"]
pub const esp_phy_modem_t_PHY_MODEM_IEEE802154: esp_phy_modem_t = 4;
#[doc = "< Don't use it. Used by ESP_PHY_MODEM_COUNT_MAX"]
pub const esp_phy_modem_t_PHY_MODEM_MAX: esp_phy_modem_t = 5;
#[doc = " @brief PHY enable or disable modem"]
pub type esp_phy_modem_t = crate::c_types::c_uint;
#[doc = " @brief Opaque PHY calibration data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_calibration_data_t {
    #[doc = "< PHY version"]
    pub version: [u8; 4usize],
    #[doc = "< The MAC address of the station"]
    pub mac: [u8; 6usize],
    #[doc = "< calibration data"]
    pub opaque: [u8; 1894usize],
}
#[doc = "< Do part of RF calibration. This should be used after power-on reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_PARTIAL: esp_phy_calibration_mode_t = 0;
#[doc = "< Don't do any RF calibration. This mode is only suggested to be used after deep sleep reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_NONE: esp_phy_calibration_mode_t = 1;
#[doc = "< Do full RF calibration. Produces best results, but also consumes a lot of time and current. Suggested to be used once."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_FULL: esp_phy_calibration_mode_t = 2;
#[doc = " @brief PHY calibration mode\n"]
pub type esp_phy_calibration_mode_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief Get PHY init data\n\n If \"Use a partition to store PHY init data\" option is set in menuconfig,\n This function will load PHY init data from a partition. Otherwise,\n PHY init data will be compiled into the application itself, and this function\n will return a pointer to PHY init data located in read-only memory (DROM).\n\n If \"Use a partition to store PHY init data\" option is enabled, this function\n may return NULL if the data loaded from flash is not valid.\n\n @note Call esp_phy_release_init_data to release the pointer obtained using\n this function after the call to esp_wifi_init.\n\n @return pointer to PHY init data structure"]
    pub fn esp_phy_get_init_data() -> *const esp_phy_init_data_t;
}
extern "C" {
    #[doc = " @brief Release PHY init data\n @param data  pointer to PHY init data structure obtained from\n              esp_phy_get_init_data function"]
    pub fn esp_phy_release_init_data(data: *const esp_phy_init_data_t);
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_load_cal_and_init to load PHY calibration data\n\n This is a convenience function which can be used to load PHY calibration\n data from NVS. Data can be stored to NVS using esp_phy_store_cal_data_to_nvs\n function.\n\n If calibration data is not present in the NVS, or\n data is not valid (was obtained for a chip with a different MAC address,\n or obtained for a different version of software), this function will\n return an error.\n\n @param out_cal_data pointer to calibration data structure to be filled with\n                     loaded data.\n @return ESP_OK on success"]
    pub fn esp_phy_load_cal_data_from_nvs(
        out_cal_data: *mut esp_phy_calibration_data_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_load_cal_and_init to store PHY calibration data\n\n This is a convenience function which can be used to store PHY calibration\n data to the NVS. Calibration data is returned by esp_phy_load_cal_and_init function.\n Data saved using this function to the NVS can later be loaded using\n esp_phy_store_cal_data_to_nvs function.\n\n @param cal_data pointer to calibration data which has to be saved.\n @return ESP_OK on success"]
    pub fn esp_phy_store_cal_data_to_nvs(cal_data: *const esp_phy_calibration_data_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase PHY calibration data which is stored in the NVS\n\n This is a function which can be used to trigger full calibration as a last-resort remedy\n if partial calibration is used. It can be called in the application based on some conditions\n (e.g. an option provided in some diagnostic mode).\n\n @return ESP_OK on success\n @return others on fail. Please refer to NVS API return value error number."]
    pub fn esp_phy_erase_cal_data_in_nvs() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable PHY and RF module\n\n PHY and RF module should be enabled in order to use WiFi or BT.\n Now PHY and RF enabling job is done automatically when start WiFi or BT. Users should not\n call this API in their application.\n\n @param modem the modem to call the phy enable."]
    pub fn esp_phy_enable(modem: esp_phy_modem_t);
}
extern "C" {
    #[doc = " @brief Disable PHY and RF module\n\n PHY module should be disabled in order to shutdown WiFi or BT.\n Now PHY and RF disabling job is done automatically when stop WiFi or BT. Users should not\n call this API in their application.\n\n @param modem the modem to call the phy disable."]
    pub fn esp_phy_disable(modem: esp_phy_modem_t);
}
extern "C" {
    #[doc = " @brief Enable BTBB module\n\n BTBB module should be enabled in order to use IEEE802154 or BT.\n Now BTBB enabling job is done automatically when start IEEE802154 or BT. Users should not\n call this API in their application.\n"]
    pub fn esp_btbb_enable();
}
extern "C" {
    #[doc = " @brief Disable BTBB module\n\n Disable BTBB module, used by IEEE802154 or Bluetooth.\n Users should not call this API in their application.\n"]
    pub fn esp_btbb_disable();
}
extern "C" {
    #[doc = " @brief Load calibration data from NVS and initialize PHY and RF module"]
    pub fn esp_phy_load_cal_and_init();
}
extern "C" {
    #[doc = " @brief Initialize backup memory for Phy power up/down"]
    pub fn esp_phy_modem_init();
}
extern "C" {
    #[doc = " @brief Deinitialize backup memory for Phy power up/down\n Set phy_init_flag if all modems deinit on ESP32C3"]
    pub fn esp_phy_modem_deinit();
}
extern "C" {
    #[doc = " @brief Enable WiFi/BT common clock\n"]
    pub fn esp_phy_common_clock_enable();
}
extern "C" {
    #[doc = " @brief Disable WiFi/BT common clock\n"]
    pub fn esp_phy_common_clock_disable();
}
extern "C" {
    #[doc = " @brief            Get the time stamp when PHY/RF was switched on\n @return           return 0 if PHY/RF is never switched on. Otherwise return time in\n                   microsecond since boot when phy/rf was last switched on"]
    pub fn esp_phy_rf_get_on_ts() -> i64;
}
extern "C" {
    #[doc = " @brief Update the corresponding PHY init type according to the country code of Wi-Fi.\n\n @param country country code\n @return ESP_OK on success.\n @return esp_err_t code describing the error on fail"]
    pub fn esp_phy_update_country_info(country: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get PHY lib version\n @return PHY lib version."]
    pub fn get_phy_version_str() -> *mut crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief Set PHY init parameters\n @param param is 1 means combo module"]
    pub fn phy_init_param_set(param: u8);
}
extern "C" {
    #[doc = " @brief Wi-Fi RX enable\n @param enable True for enable wifi receiving mode as default, false for closing wifi receiving mode as default."]
    pub fn phy_wifi_enable_set(enable: u8);
}
extern "C" {
    #[doc = " @brief Power on Bluetooth Wi-Fi power domain"]
    pub fn esp_wifi_bt_power_domain_on();
}
extern "C" {
    #[doc = " @brief Power off Bluetooth Wi-Fi power domain"]
    pub fn esp_wifi_bt_power_domain_off();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_i2c_master_command_attribute_t {
    pub cmd_type: u8,
    pub config: phy_i2c_master_command_attribute_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_i2c_master_command_attribute_t__bindgen_ty_1 {
    pub start: u8,
    pub end: u8,
    pub host_id: u8,
}
extern "C" {
    #[doc = " @brief Return ROM function pointer table from PHY library."]
    pub fn phy_get_romfunc_addr();
}
extern "C" {
    #[doc = " @brief Initialize PHY module and do RF calibration\n @param[in] init_data Initialization parameters to be used by the PHY\n @param[inout] cal_data As input, calibration data previously obtained. As output, will contain new calibration data.\n @param[in] cal_mode  RF calibration mode\n @return ESP_CAL_DATA_CHECK_FAIL if the calibration data checksum fails or if the calibration data is outdated, other values are reserved for future use"]
    pub fn register_chipv7_phy(
        init_data: *const esp_phy_init_data_t,
        cal_data: *mut esp_phy_calibration_data_t,
        cal_mode: esp_phy_calibration_mode_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get the format version of calibration data used by PHY library.\n @return Format version number, OR'ed with BIT(16) if PHY is in WIFI only mode."]
    pub fn phy_get_rf_cal_version() -> u32;
}
extern "C" {
    #[doc = " @brief Set RF/BB for only WIFI mode or coexist(WIFI & BT) mode\n @param[in] true is for only WIFI mode, false is for coexist mode. default is 0.\n @return NULL"]
    pub fn phy_set_wifi_mode_only(wifi_only: bool);
}
extern "C" {
    #[doc = " @brief Set BT the highest priority in coexist mode.\n @return NULL"]
    pub fn coex_bt_high_prio();
}
extern "C" {
    #[doc = " @brief Open PHY and RF."]
    pub fn phy_wakeup_init();
}
extern "C" {
    #[doc = " @brief Shutdown PHY and RF."]
    pub fn phy_close_rf();
}
extern "C" {
    #[doc = " @brief Disable PHY temperature sensor."]
    pub fn phy_xpd_tsens();
}
extern "C" {
    #[doc = " @brief Store and load PHY digital registers.\n\n @param     backup_en  if backup_en is true, store PHY digital registers to memory. Otherwise load PHY digital registers from memory\n @param     mem_addr   Memory address to store and load PHY digital registers\n\n @return    memory size"]
    pub fn phy_dig_reg_backup(backup_en: bool, mem_addr: *mut u32) -> u8;
}
extern "C" {
    #[doc = " @brief Phy version select for ESP32S2"]
    pub fn phy_eco_version_sel(chip_ver: u8);
}
extern "C" {
    #[doc = " @brief Enable phy track pll\n"]
    pub fn phy_track_pll_init();
}
extern "C" {
    #[doc = " @brief Disable phy track pll\n"]
    pub fn phy_track_pll_deinit();
}
extern "C" {
    #[doc = " @brief Set the flag recorded which modem has already enabled phy\n"]
    pub fn phy_set_modem_flag(modem: esp_phy_modem_t);
}
extern "C" {
    #[doc = " @brief Clear the flag to record which modem calls phy disenable"]
    pub fn phy_clr_modem_flag(modem: esp_phy_modem_t);
}
extern "C" {
    #[doc = " @brief Get the flag recorded which modem has already enabled phy\n"]
    pub fn phy_get_modem_flag() -> esp_phy_modem_t;
}
extern "C" {
    #[doc = " @brief Get the PHY lock, only used in esp_phy, the user should not use this function.\n"]
    pub fn phy_get_lock() -> _lock_t;
}
extern "C" {
    #[doc = " @brief Call this funnction to track pll immediately.\n"]
    pub fn phy_track_pll();
}
extern "C" {
    #[doc = " @brief PHY antenna default configuration\n"]
    pub fn ant_dft_cfg(default_ant: bool);
}
extern "C" {
    #[doc = " @brief PHY tx antenna config\n"]
    pub fn ant_tx_cfg(ant0: u8);
}
extern "C" {
    #[doc = " @brief PHY rx antenna config\n"]
    pub fn ant_rx_cfg(auto_en: bool, ant0: u8, ant1: u8);
}
extern "C" {
    #[doc = " @brief PHY antenna need update\n"]
    pub fn phy_ant_need_update() -> bool;
}
extern "C" {
    #[doc = " @brief PHY antenna need update\n"]
    pub fn phy_ant_clr_update_flag();
}
extern "C" {
    #[doc = " @brief PHY antenna configuration update\n"]
    pub fn phy_ant_update();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_channel_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM channel handle"]
pub type esp_etm_channel_handle_t = *mut esp_etm_channel_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_event_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM event handle"]
pub type esp_etm_event_handle_t = *mut esp_etm_event_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_task_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM task handle"]
pub type esp_etm_task_handle_t = *mut esp_etm_task_t;
#[doc = " @brief ETM channel configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_channel_config_t {}
extern "C" {
    #[doc = " @brief Allocate an ETM channel\n\n @note The channel can later be freed by `esp_etm_del_channel`\n\n @param[in] config ETM channel configuration\n @param[out] ret_chan Returned ETM channel handle\n @return\n      - ESP_OK: Allocate ETM channel successfully\n      - ESP_ERR_INVALID_ARG: Allocate ETM channel failed because of invalid argument\n      - ESP_ERR_NO_MEM: Allocate ETM channel failed because of out of memory\n      - ESP_ERR_NOT_FOUND: Allocate ETM channel failed because all channels are used up and no more free one\n      - ESP_FAIL: Allocate ETM channel failed because of other reasons"]
    pub fn esp_etm_new_channel(
        config: *const esp_etm_channel_config_t,
        ret_chan: *mut esp_etm_channel_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an ETM channel\n\n @param[in] chan ETM channel handle that created by `esp_etm_new_channel`\n @return\n      - ESP_OK: Delete ETM channel successfully\n      - ESP_ERR_INVALID_ARG: Delete ETM channel failed because of invalid argument\n      - ESP_FAIL: Delete ETM channel failed because of other reasons"]
    pub fn esp_etm_del_channel(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable ETM channel\n\n @note This function will transit the channel state from init to enable.\n\n @param[in] chan ETM channel handle that created by `esp_etm_new_channel`\n @return\n      - ESP_OK: Enable ETM channel successfully\n      - ESP_ERR_INVALID_ARG: Enable ETM channel failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Enable ETM channel failed because the channel has been enabled already\n      - ESP_FAIL: Enable ETM channel failed because of other reasons"]
    pub fn esp_etm_channel_enable(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable ETM channel\n\n @note This function will transit the channel state from enable to init.\n\n @param[in] chan ETM channel handle that created by `esp_etm_new_channel`\n @return\n      - ESP_OK: Disable ETM channel successfully\n      - ESP_ERR_INVALID_ARG: Disable ETM channel failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Disable ETM channel failed because the channel is not enabled yet\n      - ESP_FAIL: Disable ETM channel failed because of other reasons"]
    pub fn esp_etm_channel_disable(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Connect an ETM event to an ETM task via a previously allocated ETM channel\n\n @note Setting the ETM event/task handle to NULL means to disconnect the channel from any event/task\n\n @param[in] chan ETM channel handle that created by `esp_etm_new_channel`\n @param[in] event ETM event handle obtained from a driver/peripheral, e.g. `xxx_new_etm_event`\n @param[in] task ETM task handle obtained from a driver/peripheral, e.g. `xxx_new_etm_task`\n @return\n      - ESP_OK: Connect ETM event and task to the channel successfully\n      - ESP_ERR_INVALID_ARG: Connect ETM event and task to the channel failed because of invalid argument\n      - ESP_FAIL: Connect ETM event and task to the channel failed because of other reasons"]
    pub fn esp_etm_channel_connect(
        chan: esp_etm_channel_handle_t,
        event: esp_etm_event_handle_t,
        task: esp_etm_task_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete ETM event\n\n @note Although the ETM event comes from various peripherals, we provide the same user API to delete the event handle seamlessly.\n\n @param[in] event ETM event handle obtained from a driver/peripheral, e.g. `xxx_new_etm_event`\n @return\n      - ESP_OK: Delete ETM event successfully\n      - ESP_ERR_INVALID_ARG: Delete ETM event failed because of invalid argument\n      - ESP_FAIL: Delete ETM event failed because of other reasons"]
    pub fn esp_etm_del_event(event: esp_etm_event_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete ETM task\n\n @note Although the ETM task comes from various peripherals, we provide the same user API to delete the task handle seamlessly.\n\n @param[in] task ETM task handle obtained from a driver/peripheral, e.g. `xxx_new_etm_task`\n @return\n      - ESP_OK: Delete ETM task successfully\n      - ESP_ERR_INVALID_ARG: Delete ETM task failed because of invalid argument\n      - ESP_FAIL: Delete ETM task failed because of other reasons"]
    pub fn esp_etm_del_task(task: esp_etm_task_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dump ETM channel usages to the given IO stream\n\n @param[in] out_stream IO stream (e.g. stdout)\n @return\n      - ESP_OK: Dump ETM channel usages successfully\n      - ESP_ERR_INVALID_ARG: Dump ETM channel usages failed because of invalid argument\n      - ESP_FAIL: Dump ETM channel usages failed because of other reasons"]
    pub fn esp_etm_dump(out_stream: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type representing a single timer handle"]
pub type esp_timer_handle_t = *mut esp_timer;
#[doc = " @brief Timer callback function type\n @param arg pointer to opaque user-specific data"]
pub type esp_timer_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut crate::c_types::c_void)>;
#[doc = "!< Callback is dispatched from esp_timer task"]
pub const esp_timer_dispatch_t_ESP_TIMER_TASK: esp_timer_dispatch_t = 0;
#[doc = "!< Sentinel value for the number of callback dispatch methods"]
pub const esp_timer_dispatch_t_ESP_TIMER_MAX: esp_timer_dispatch_t = 1;
#[doc = " @brief Method to dispatch timer callback"]
pub type esp_timer_dispatch_t = crate::c_types::c_uint;
#[doc = " @brief Timer configuration passed to esp_timer_create()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_timer_create_args_t {
    #[doc = "!< Callback function to execute when timer expires"]
    pub callback: esp_timer_cb_t,
    #[doc = "!< Argument to pass to callback"]
    pub arg: *mut crate::c_types::c_void,
    #[doc = "!< Dispatch callback from task or ISR; if not specified, esp_timer task"]
    pub dispatch_method: esp_timer_dispatch_t,
    #[doc = "!< Timer name, used in esp_timer_dump() function"]
    pub name: *const crate::c_types::c_char,
    #[doc = "!< Setting to skip unhandled events in light sleep for periodic timers"]
    pub skip_unhandled_events: bool,
}
extern "C" {
    #[doc = " @brief Minimal initialization of esp_timer\n\n @note This function is called from startup code. Applications do not need\n to call this function before using other esp_timer APIs.\n\n This function can be called very early in startup process, after this call\n only esp_timer_get_time() function can be used.\n\n @return\n      - ESP_OK on success"]
    pub fn esp_timer_early_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize esp_timer library\n\n @note This function is called from startup code. Applications do not need\n to call this function before using other esp_timer APIs.\n Before calling this function, esp_timer_early_init() must be called by the\n startup code.\n\n This function will be called from startup code on every core.\n If Kconfig option `CONFIG_ESP_TIMER_ISR_AFFINITY` is set to `NO_AFFINITY`,\n it allocates the timer ISR on MULTIPLE cores and\n creates the timer task which can be run on any core.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if allocation has failed\n      - ESP_ERR_INVALID_STATE if already initialized\n      - other errors from interrupt allocator"]
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize esp_timer library\n\n @note Normally this function should not be called from applications\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if not yet initialized"]
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create an esp_timer instance\n\n @note When timer no longer needed, delete it using esp_timer_delete().\n\n @param create_args   Pointer to a structure with timer creation arguments.\n                      Not saved by the library, can be allocated on the stack.\n @param[out] out_handle  Output, pointer to esp_timer_handle_t variable that\n                         holds the created timer handle.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if some of the create_args are not valid\n      - ESP_ERR_INVALID_STATE if esp_timer library is not initialized yet\n      - ESP_ERR_NO_MEM if memory allocation fails"]
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a one-shot timer\n\n Timer represented by `timer` should not be running when this function is called.\n\n @param timer timer handle created using esp_timer_create()\n @param timeout_us timer timeout, in microseconds relative to the current moment\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a periodic timer\n\n Timer represented by `timer` should not be running when this function is called.\n This function starts the timer which will trigger every `period` microseconds.\n\n @param timer timer handle created using esp_timer_create()\n @param period timer period, in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Restart a currently running timer\n\n Type of `timer` | Action\n --------------- | ------\n One-shot timer  | Restarted immediately and times out once in `timeout_us` microseconds\n Periodic timer  | Restarted immediately with a new period of `timeout_us` microseconds\n\n @param timer timer handle created using esp_timer_create()\n @param timeout_us Timeout in microseconds relative to the current time.\n                   In case of a periodic timer, also represents the new period.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_restart(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop a running timer\n\n This function stops the timer previously started using esp_timer_start_once()\n or esp_timer_start_periodic().\n\n @param timer timer handle created using esp_timer_create()\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an esp_timer instance\n\n The timer must be stopped before deleting. A one-shot timer which has expired\n does not need to be stopped.\n\n @param timer timer handle created using esp_timer_create()\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if the timer is running"]
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get time in microseconds since boot\n @return Number of microseconds since the initialization of ESP Timer"]
    pub fn esp_timer_get_time() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp of the next expected timeout\n @return Timestamp of the nearest timer event, in microseconds.\n         The timebase is the same as for the values returned by esp_timer_get_time()."]
    pub fn esp_timer_get_next_alarm() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp of the next expected timeout excluding those timers\n        that should not interrupt light sleep (such timers have\n        ::esp_timer_create_args_t::skip_unhandled_events enabled)\n @return Timestamp of the nearest timer event, in microseconds.\n         The timebase is the same as for the values returned by esp_timer_get_time()."]
    pub fn esp_timer_get_next_alarm_for_wake_up() -> i64;
}
extern "C" {
    #[doc = " @brief Get the period of a timer\n\n This function fetches the timeout period of a timer.\n For a one-shot timer, the timeout period will be 0.\n\n @param timer timer handle created using esp_timer_create()\n @param period memory to store the timer period value in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the arguments are invalid"]
    pub fn esp_timer_get_period(timer: esp_timer_handle_t, period: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the expiry time of a one-shot timer\n\n This function fetches the expiry time of a one-shot timer.\n\n @note Passing the timer handle of a periodic timer will result in an error.\n\n @param timer timer handle created using esp_timer_create()\n @param expiry memory to store the timeout value in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the arguments are invalid\n      - ESP_ERR_NOT_SUPPORTED if the timer type is periodic"]
    pub fn esp_timer_get_expiry_time(timer: esp_timer_handle_t, expiry: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dump the list of timers to a stream\n\n By default, this function prints the list of active (running) timers. The output format is:\n\n | Name | Period | Alarm |\n\n - Name — timer pointer\n - Period — period of timer in microseconds, or 0 for one-shot timer\n - Alarm - time of the next alarm in microseconds since boot, or 0 if the timer is not started\n\n To print the list of all created timers, enable Kconfig option `CONFIG_ESP_TIMER_PROFILING`.\n In this case, the output format is:\n\n | Name | Period | Alarm | Times_armed | Times_trigg | Times_skip | Cb_exec_time |\n\n - Name — timer name\n - Period — same as above\n - Alarm — same as above\n - Times_armed — number of times the timer was armed via esp_timer_start_X\n - Times_triggered - number of times the callback was triggered\n - Times_skipped - number of times the callback was skipped\n - Callback_exec_time - total time taken by callback to execute, across all calls\n\n @param stream stream (such as stdout) to which to dump the information\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if can not allocate temporary buffer for the output"]
    pub fn esp_timer_dump(stream: *mut FILE) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns status of a timer, active or not\n\n This function is used to identify if the timer is still active (running) or not.\n\n @param timer timer handle created using esp_timer_create()\n @return\n      - 1 if timer is still active (running)\n      - 0 if timer is not active"]
    pub fn esp_timer_is_active(timer: esp_timer_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief Get the ETM event handle of esp_timer underlying alarm event\n\n @note The created ETM event object can be deleted later using esp_etm_del_event()\n\n @note The ETM event is generated by the underlying hardware - systimer;\n       therefore, if the esp_timer is not clocked by systimer, then no ETM event will be generated.\n\n @param[out] out_event Returned ETM event handle\n @return\n      - ESP_OK Success\n      - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn esp_timer_new_etm_alarm_event(out_event: *mut esp_etm_event_handle_t) -> esp_err_t;
}
#[doc = "< EAP (Extensible Authentication Protocol)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_EAP: esp_eap_ttls_phase2_types = 0;
#[doc = "< MS-CHAPv2 (Microsoft Challenge Handshake Authentication Protocol - Version 2)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_MSCHAPV2: esp_eap_ttls_phase2_types = 1;
#[doc = "< MS-CHAP (Microsoft Challenge Handshake Authentication Protocol)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_MSCHAP: esp_eap_ttls_phase2_types = 2;
#[doc = "< PAP (Password Authentication Protocol)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_PAP: esp_eap_ttls_phase2_types = 3;
#[doc = "< CHAP (Challenge Handshake Authentication Protocol)"]
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_CHAP: esp_eap_ttls_phase2_types = 4;
#[doc = " @brief Enumeration of phase 2 authentication types for EAP-TTLS.\n\n This enumeration defines the supported phase 2 authentication methods\n that can be used in the EAP-TTLS (Extensible Authentication Protocol -\n Tunneled Transport Layer Security) protocol for the second authentication\n phase."]
pub type esp_eap_ttls_phase2_types = crate::c_types::c_uint;
#[doc = "< No EAP method defined"]
pub const esp_eap_method_t_ESP_EAP_TYPE_NONE: esp_eap_method_t = 0;
#[doc = "< EAP-TLS method"]
pub const esp_eap_method_t_ESP_EAP_TYPE_TLS: esp_eap_method_t = 1;
#[doc = "< EAP-TTLS method"]
pub const esp_eap_method_t_ESP_EAP_TYPE_TTLS: esp_eap_method_t = 2;
#[doc = "< EAP-PEAP method"]
pub const esp_eap_method_t_ESP_EAP_TYPE_PEAP: esp_eap_method_t = 4;
#[doc = "< EAP-FAST method"]
pub const esp_eap_method_t_ESP_EAP_TYPE_FAST: esp_eap_method_t = 8;
#[doc = "< All supported EAP methods"]
pub const esp_eap_method_t_ESP_EAP_TYPE_ALL: esp_eap_method_t = 15;
#[doc = " @brief Bitmask of supported EAP authentication methods."]
pub type esp_eap_method_t = crate::c_types::c_uint;
#[doc = " @brief Configuration settings for EAP-FAST\n        (Extensible Authentication Protocol - Flexible Authentication via Secure Tunneling).\n\n This structure defines the configuration options that can be used to customize the behavior of the\n EAP-FAST authentication protocol, specifically for Fast Provisioning and PAC (Protected Access Credential) handling."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_eap_fast_config {
    #[doc = "< Enable or disable Fast Provisioning in EAP-FAST (0 = disabled, 1 = enabled)"]
    pub fast_provisioning: crate::c_types::c_int,
    #[doc = "< Maximum length of the PAC (Protected Access Credential) list"]
    pub fast_max_pac_list_len: crate::c_types::c_int,
    #[doc = "< Set to true for binary format PAC, false for ASCII format PAC"]
    pub fast_pac_format_binary: bool,
}
extern "C" {
    #[doc = " @brief Enable EAP authentication(WiFi Enterprise) for the station mode.\n\n This function enables Extensible Authentication Protocol (EAP) authentication\n for the Wi-Fi station mode. When EAP authentication is enabled, the ESP device\n will attempt to authenticate with the configured EAP credentials when connecting\n to a secure Wi-Fi network.\n\n @note Before calling this function, ensure that the Wi-Fi configuration and EAP\n credentials (such as username and password) have been properly set using the\n appropriate configuration APIs.\n\n @return\n    - ESP_OK: EAP authentication enabled successfully.\n    - ESP_ERR_NO_MEM: Failed to enable EAP authentication due to memory allocation failure."]
    pub fn esp_wifi_sta_enterprise_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable EAP authentication(WiFi Enterprise) for the station mode.\n\n This function disables Extensible Authentication Protocol (EAP) authentication\n for the Wi-Fi station mode. When EAP authentication is disabled, the ESP device\n will not attempt to authenticate using EAP credentials when connecting to a\n secure Wi-Fi network.\n\n @note Disabling EAP authentication may cause the device to connect to the Wi-Fi\n network using other available authentication methods, if configured using esp_wifi_set_config().\n @note Calling this will reset all eap configuration set using esp_eap_client_xxx APIs.\n Please call esp_eap_client_XXX APIs again to set new config after calling this function.\n\n @return\n    - ESP_OK: EAP authentication disabled successfully.\n    - ESP_ERR_INVALID_STATE: EAP client is in an invalid state for disabling."]
    pub fn esp_wifi_sta_enterprise_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set identity for PEAP/TTLS authentication method.\n\n This function sets the identity to be used during PEAP/TTLS authentication.\n\n @param[in] identity Pointer to the identity data.\n @param[in] len      Length of the identity data (limited to 1~127 bytes).\n\n @return\n    - ESP_OK: The identity was set successfully.\n    - ESP_ERR_INVALID_ARG: Invalid argument (len <= 0 or len >= 128).\n    - ESP_ERR_NO_MEM: Memory allocation failure."]
    pub fn esp_eap_client_set_identity(
        identity: *const crate::c_types::c_uchar,
        len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear the previously set identity for PEAP/TTLS authentication.\n\n This function clears the identity that was previously set for the EAP client.\n After calling this function, the EAP client will no longer use the previously\n configured identity during the authentication process."]
    pub fn esp_eap_client_clear_identity();
}
extern "C" {
    #[doc = " @brief Set username for PEAP/TTLS authentication method.\n\n This function sets the username to be used during PEAP/TTLS authentication.\n\n @param[in] username Pointer to the username data.\n @param[in] len      Length of the username data (limited to 1~127 bytes).\n\n @return\n    - ESP_OK: The username was set successfully.\n    - ESP_ERR_INVALID_ARG: Failed due to an invalid argument (len <= 0 or len >= 128).\n    - ESP_ERR_NO_MEM: Failed due to memory allocation failure."]
    pub fn esp_eap_client_set_username(
        username: *const crate::c_types::c_uchar,
        len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear username for PEAP/TTLS method.\n\n This function clears the previously set username for the EAP client."]
    pub fn esp_eap_client_clear_username();
}
extern "C" {
    #[doc = " @brief Set password for PEAP/TTLS authentication method.\n\n This function sets the password to be used during PEAP/TTLS authentication.\n\n @param[in] password Pointer to the password data.\n @param[in] len      Length of the password data (len > 0).\n\n @return\n    - ESP_OK: The password was set successfully.\n    - ESP_ERR_INVALID_ARG: Failed due to an invalid argument (len <= 0).\n    - ESP_ERR_NO_MEM: Failed due to memory allocation failure."]
    pub fn esp_eap_client_set_password(
        password: *const crate::c_types::c_uchar,
        len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear password for PEAP/TTLS method.\n\n This function clears the previously set password for the EAP client."]
    pub fn esp_eap_client_clear_password();
}
extern "C" {
    #[doc = " @brief Set a new password for MSCHAPv2 authentication method.\n\n This function sets the new password to be used during MSCHAPv2 authentication.\n The new password is used to substitute the old password when an eap-mschapv2 failure request\n message with error code ERROR_PASSWD_EXPIRED is received.\n\n @param[in] new_password Pointer to the new password data.\n @param[in] len          Length of the new password data.\n\n @return\n    - ESP_OK: The new password was set successfully.\n    - ESP_ERR_INVALID_ARG: Failed due to an invalid argument (len <= 0).\n    - ESP_ERR_NO_MEM: Failed due to memory allocation failure."]
    pub fn esp_eap_client_set_new_password(
        new_password: *const crate::c_types::c_uchar,
        len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear new password for MSCHAPv2 method.\n\n This function clears the previously set new password for the EAP client."]
    pub fn esp_eap_client_clear_new_password();
}
extern "C" {
    #[doc = " @brief Set CA certificate for EAP authentication.\n\n This function sets the Certificate Authority (CA) certificate to be used during EAP authentication.\n The CA certificate is passed to the EAP client module through a global pointer.\n\n @param[in] ca_cert     Pointer to the CA certificate data.\n @param[in] ca_cert_len Length of the CA certificate data.\n\n @return\n    - ESP_OK: The CA certificate was set successfully."]
    pub fn esp_eap_client_set_ca_cert(
        ca_cert: *const crate::c_types::c_uchar,
        ca_cert_len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear the previously set Certificate Authority (CA) certificate for EAP authentication.\n\n This function clears the CA certificate that was previously set for the EAP client.\n After calling this function, the EAP client will no longer use the previously\n configured CA certificate during the authentication process."]
    pub fn esp_eap_client_clear_ca_cert();
}
extern "C" {
    #[doc = " @brief Set client certificate and private key for EAP authentication.\n\n This function sets the client certificate and private key to be used during authentication.\n Optionally, a private key password can be provided for encrypted private keys.\n\n @attention 1. The client certificate, private key, and private key password are provided as pointers\n              to the respective data arrays.\n @attention 2. The client_cert, private_key, and private_key_password should be zero-terminated.\n\n @param[in] client_cert           Pointer to the client certificate data.\n @param[in] client_cert_len       Length of the client certificate data.\n @param[in] private_key           Pointer to the private key data.\n @param[in] private_key_len       Length of the private key data (limited to 1~4096 bytes).\n @param[in] private_key_password  Pointer to the private key password data (optional).\n @param[in] private_key_passwd_len Length of the private key password data (can be 0 for no password).\n\n @return\n    - ESP_OK: The certificate, private key, and password (if provided) were set successfully."]
    pub fn esp_eap_client_set_certificate_and_key(
        client_cert: *const crate::c_types::c_uchar,
        client_cert_len: crate::c_types::c_int,
        private_key: *const crate::c_types::c_uchar,
        private_key_len: crate::c_types::c_int,
        private_key_password: *const crate::c_types::c_uchar,
        private_key_passwd_len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear the previously set client certificate and private key for EAP authentication.\n\n This function clears the client certificate and private key that were previously set\n for the EAP client. After calling this function, the EAP client will no longer use the\n previously configured certificate and private key during the authentication process."]
    pub fn esp_eap_client_clear_certificate_and_key();
}
extern "C" {
    #[doc = " @brief Set EAP client certificates time check (disable or not).\n\n This function enables or disables the time check for EAP client certificates.\n When disabled, the certificates' expiration time will not be checked during the authentication process.\n\n @param[in] disable True to disable EAP client certificates time check, false to enable it.\n\n @return\n    - ESP_OK: The EAP client certificates time check setting was updated successfully."]
    pub fn esp_eap_client_set_disable_time_check(disable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get EAP client certificates time check status.\n\n This function retrieves the current status of the EAP client certificates time check.\n\n @param[out] disable Pointer to a boolean variable to store the disable status.\n\n @return\n    - ESP_OK: The status of EAP client certificates time check was retrieved successfully."]
    pub fn esp_eap_client_get_disable_time_check(disable: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set EAP-TTLS phase 2 method.\n\n This function sets the phase 2 method to be used during EAP-TTLS authentication.\n\n @param[in] type The type of phase 2 method to be used (e.g., EAP, MSCHAPv2, MSCHAP, PAP, CHAP).\n\n @return\n    - ESP_OK: The EAP-TTLS phase 2 method was set successfully."]
    pub fn esp_eap_client_set_ttls_phase2_method(type_: esp_eap_ttls_phase2_types) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable Suite-B 192-bit certification checks.\n\n This function enables or disables the 192-bit Suite-B certification checks during EAP-TLS authentication.\n Suite-B is a set of cryptographic algorithms which generally are considered more secure.\n\n @param[in] enable True to enable 192-bit Suite-B certification checks, false to disable it.\n\n @return\n    - ESP_OK: The 192-bit Suite-B certification checks were set successfully."]
    pub fn esp_eap_client_set_suiteb_192bit_certification(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the PAC (Protected Access Credential) file for EAP-FAST authentication.\n\n EAP-FAST requires a PAC file that contains the client's credentials.\n\n @attention  1. For files read from the file system, length has to be decremented by 1 byte.\n @attention  2. Disabling the ESP_WIFI_MBEDTLS_TLS_CLIENT config is required to use EAP-FAST.\n\n @param[in] pac_file     Pointer to the PAC file buffer.\n @param[in] pac_file_len Length of the PAC file buffer.\n\n @return\n    - ESP_OK: The PAC file for EAP-FAST authentication was set successfully."]
    pub fn esp_eap_client_set_pac_file(
        pac_file: *const crate::c_types::c_uchar,
        pac_file_len: crate::c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the parameters for EAP-FAST Phase 1 authentication.\n\n EAP-FAST supports Fast Provisioning, where clients can be authenticated faster using precomputed keys (PAC).\n This function allows configuring parameters for Fast Provisioning.\n\n @attention  1. Disabling the ESP_WIFI_MBEDTLS_TLS_CLIENT config is required to use EAP-FAST.\n\n @param[in] config Configuration structure with Fast Provisioning parameters.\n\n @return\n    - ESP_OK: The parameters for EAP-FAST Phase 1 authentication were set successfully."]
    pub fn esp_eap_client_set_fast_params(config: esp_eap_fast_config) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Use the default certificate bundle for EAP authentication.\n\n By default, the EAP client uses a built-in certificate bundle for server verification.\n Enabling this option allows the use of the default certificate bundle.\n\n @param[in] use_default_bundle True to use the default certificate bundle, false to use a custom bundle.\n\n @return\n    - ESP_OK: The option to use the default certificate bundle was set successfully."]
    pub fn esp_eap_client_use_default_cert_bundle(use_default_bundle: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set Opportunistic key caching support for station.\n\n @param enable Boolean indicating whether to enable (true) or disable (false) OKC support."]
    pub fn esp_wifi_set_okc_support(enable: bool);
}
extern "C" {
    #[doc = " @brief Set the domain name for certificate validation\n\n This function sets the expected domain name for validating the certificate's subject name.\n If the provided domain name does not match the certificate's subject name, validation will fail.\n\n @attention  1. The `domain_name` should be a NULL-terminated string.\n\n @param[in] domain_name The expected domain name. Pass `NULL` to clear the domain matching.\n\n @return\n    - ESP_OK: The domain match was set successfully.\n    - ESP_ERR_INVALID_ARG: Invalid argument (length > 255).\n    - ESP_ERR_NO_MEM: Memory allocation failure.\n    - ESP_ERR_NOT_SUPPORTED: Feature not supported."]
    pub fn esp_eap_client_set_domain_name(domain_name: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set one or more EAP (Extensible Authentication Protocol) methods to be used by the EAP client.\n\n This API sets the allowed EAP authentication methods using a bitmask.\n Multiple methods can be specified by OR-ing together values from `esp_eap_method_t`.\n\n @param[in] methods Bitmask of EAP methods to enable.\n\n @return\n     - ESP_OK on success\n     - ESP_ERR_INVALID_ARG if none of the methods are valid\n\n @note\n If this API is not called, all supported EAP methods will be considered.\n If one or more methods are set using this API, only the specified methods will be considered."]
    pub fn esp_eap_client_set_eap_methods(methods: esp_eap_method_t) -> esp_err_t;
}
#[doc = "< Send ESPNOW data successfully"]
pub const esp_now_send_status_t_ESP_NOW_SEND_SUCCESS: esp_now_send_status_t = 0;
#[doc = "< Send ESPNOW data fail"]
pub const esp_now_send_status_t_ESP_NOW_SEND_FAIL: esp_now_send_status_t = 1;
#[doc = " @brief Status of sending ESPNOW data ."]
pub type esp_now_send_status_t = crate::c_types::c_uint;
#[doc = " @brief ESPNOW peer information parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_peer_info {
    #[doc = "< ESPNOW peer MAC address that is also the MAC address of station or softap"]
    pub peer_addr: [u8; 6usize],
    #[doc = "< ESPNOW peer local master key that is used to encrypt data"]
    pub lmk: [u8; 16usize],
    #[doc = "< Wi-Fi channel that peer uses to send/receive ESPNOW data. If the value is 0,\nuse the current channel which station or softap is on. Otherwise, it must be\nset as the channel that station or softap is on."]
    pub channel: u8,
    #[doc = "< Wi-Fi interface that peer uses to send/receive ESPNOW data"]
    pub ifidx: wifi_interface_t,
    #[doc = "< ESPNOW data that this peer sends/receives is encrypted or not"]
    pub encrypt: bool,
    #[doc = "< ESPNOW peer private data"]
    pub priv_: *mut crate::c_types::c_void,
}
#[doc = " @brief ESPNOW peer information parameters."]
pub type esp_now_peer_info_t = esp_now_peer_info;
#[doc = " @brief Number of ESPNOW peers which exist currently."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_peer_num {
    #[doc = "< Total number of ESPNOW peers, maximum value is ESP_NOW_MAX_TOTAL_PEER_NUM"]
    pub total_num: crate::c_types::c_int,
    #[doc = "< Number of encrypted ESPNOW peers, maximum value is ESP_NOW_MAX_ENCRYPT_PEER_NUM"]
    pub encrypt_num: crate::c_types::c_int,
}
#[doc = " @brief Number of ESPNOW peers which exist currently."]
pub type esp_now_peer_num_t = esp_now_peer_num;
#[doc = " @brief ESPNOW receive packet information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_recv_info {
    #[doc = "< Source address of ESPNOW packet"]
    pub src_addr: *mut u8,
    #[doc = "< Destination address of ESPNOW packet"]
    pub des_addr: *mut u8,
    #[doc = "< Rx control info of ESPNOW packet"]
    pub rx_ctrl: *mut wifi_pkt_rx_ctrl_t,
}
#[doc = " @brief ESPNOW receive packet information"]
pub type esp_now_recv_info_t = esp_now_recv_info;
#[doc = " @brief ESPNOW sending packet information"]
pub type esp_now_send_info_t = wifi_tx_info_t;
#[doc = " @brief ESPNOW rate config"]
pub type esp_now_rate_config_t = wifi_tx_rate_config_t;
#[doc = " @brief     Callback function of receiving ESPNOW data\n @param     esp_now_info received ESPNOW packet information\n @param     data received data\n @param     data_len length of received data\n @attention esp_now_info is a local variable，it can only be used in the callback."]
pub type esp_now_recv_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        esp_now_info: *const esp_now_recv_info_t,
        data: *const u8,
        data_len: crate::c_types::c_int,
    ),
>;
#[doc = " @brief     Callback function of sending ESPNOW data\n @param     tx_info Sending information for ESPNOW data\n @param     status status of sending ESPNOW data (succeed or fail). This is will be removed later, since the tx_info->tx_status also works."]
pub type esp_now_send_cb_t = ::core::option::Option<
    unsafe extern "C" fn(tx_info: *const esp_now_send_info_t, status: esp_now_send_status_t),
>;
extern "C" {
    #[doc = " @brief     Initialize ESPNOW function\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_INTERNAL : Internal error"]
    pub fn esp_now_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize ESPNOW function\n\n @return\n          - ESP_OK : succeed"]
    pub fn esp_now_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the version of ESPNOW. Currently, ESPNOW supports two versions: v1.0 and v2.0.\n\n            The v2.0 devices are capable of receiving packets from both v2.0 and v1.0 devices. In contrast, v1.0 devices can only receive packets from other v1.0 devices.\n            However, v1.0 devices can receive v2.0 packets if the packet length is less than or equal to ESP_NOW_MAX_IE_DATA_LEN.\n            For packets exceeding this length, the v1.0 devices will either truncate the data to the first ESP_NOW_MAX_IE_DATA_LEN bytes or discard the packet entirely.\n            For detailed behavior, please refer to the documentation corresponding to the specific IDF version.\n\n @param     version  ESPNOW version\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_version(version: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of receiving ESPNOW data\n\n @param     cb  callback function of receiving ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_recv_cb(cb: esp_now_recv_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of receiving ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_recv_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of sending ESPNOW data\n\n @param     cb  callback function of sending ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_send_cb(cb: esp_now_send_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of sending ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_send_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send ESPNOW data\n\n @attention 1. If peer_addr is not NULL, send data to the peer whose MAC address matches peer_addr\n @attention 2. If peer_addr is NULL, send data to all of the peers that are added to the peer list\n @attention 3. The maximum length of data must be less than ESP_NOW_MAX_DATA_LEN\n @attention 4. The buffer pointed to by data argument does not need to be valid after esp_now_send returns\n\n @param     peer_addr  peer MAC address\n @param     data  data to send\n @param     len  length of data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_INTERNAL : internal error\n          - ESP_ERR_ESPNOW_NO_MEM : out of memory, when this happens, you can delay a while before sending the next data\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found\n          - ESP_ERR_ESPNOW_IF : current Wi-Fi interface doesn't match that of peer\n          - ESP_ERR_ESPNOW_CHAN: current Wi-Fi channel doesn't match that of peer"]
    pub fn esp_now_send(peer_addr: *const u8, data: *const u8, len: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Add a peer to peer list\n\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_FULL : peer list is full\n          - ESP_ERR_ESPNOW_NO_MEM : out of memory\n          - ESP_ERR_ESPNOW_EXIST : peer has existed"]
    pub fn esp_now_add_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Delete a peer from peer list\n\n @param     peer_addr  peer MAC address\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_del_peer(peer_addr: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Modify a peer\n\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_FULL : peer list is full"]
    pub fn esp_now_mod_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config ESPNOW rate of specified interface\n\n @deprecated please use esp_now_set_peer_rate_config() instead.\n\n @attention  1. This API should be called after esp_wifi_start().\n @attention  2. This API only work when not use Wi-Fi 6 and esp_now_set_peer_rate_config() not called.\n\n @param      ifx  Interface to be configured.\n @param      rate Phy rate to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_espnow_rate(ifx: wifi_interface_t, rate: wifi_phy_rate_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set ESPNOW rate config for each peer\n\n @attention  1. This API should be called after esp_wifi_start() and esp_now_init().\n\n @param      peer_addr  peer MAC address\n @param      config rate config to be configured.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_set_peer_rate_config(
        peer_addr: *const u8,
        config: *mut esp_now_rate_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get a peer whose MAC address matches peer_addr from peer list\n\n @param     peer_addr  peer MAC address\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_get_peer(peer_addr: *const u8, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Fetch a peer from peer list. Only return the peer which address is unicast, for the multicast/broadcast address, the function will ignore and try to find the next in the peer list.\n\n @param     from_head  fetch from head of list or not\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_fetch_peer(from_head: bool, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Peer exists or not\n\n @param     peer_addr  peer MAC address\n\n @return\n          - true : peer exists\n          - false : peer not exists"]
    pub fn esp_now_is_peer_exist(peer_addr: *const u8) -> bool;
}
extern "C" {
    #[doc = " @brief     Get the number of peers\n\n @param     num  number of peers\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_peer_num(num: *mut esp_now_peer_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the primary master key\n\n @param     pmk  primary master key\n\n @attention 1. primary master key is used to encrypt local master key\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_set_pmk(pmk: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set wake window for esp_now to wake up in interval unit\n\n @param     window  Milliseconds would the chip keep waked each interval, from 0 to 65535.\n\n @attention 1. This configuration could work at connected status.\n               When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status.\n @attention 2. Default value is the maximum.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_set_wake_window(window: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the OUI (Organization Identifier) in the vendor-specific element for ESPNOW.\n\n @param     oui  The oui should occupy 3 bytes. If the oui is NULL, then use the default value (0x18fe34).\n\n @return\n          - ESP_OK : succeed"]
    pub fn esp_now_set_user_oui(oui: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the OUI (Organization Identifier) in the vendor-specific element for ESPNOW.\n\n @param     oui  user configured OUI.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_user_oui(oui: *mut u8) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_adpt {
    pub _address: u8,
}

unsafe impl Sync for wifi_init_config_t {}
unsafe impl Sync for wifi_osi_funcs_t {}
